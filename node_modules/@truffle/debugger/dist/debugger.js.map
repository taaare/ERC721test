{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap","external \"debug\"","/Users/leefaria/work/truffle/packages/debugger/lib/helpers/index.js","external \"babel-runtime/helpers/extends\"","external \"@truffle/codec\"","external \"reselect-tree\"","/Users/leefaria/work/truffle/packages/debugger/lib/trace/selectors/index.js","external \"redux-saga/effects\"","external \"redux\"","/Users/leefaria/work/truffle/packages/debugger/lib/evm/selectors/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/solidity/selectors/index.js","external \"babel-runtime/core-js/object/entries\"","external \"babel-runtime/core-js/object/assign\"","/Users/leefaria/work/truffle/packages/debugger/lib/trace/actions/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/trace/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/data/selectors/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/data/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/session/actions/index.js","external \"babel-runtime/core-js/object/values\"","external \"json-pointer\"","external \"bn.js\"","/Users/leefaria/work/truffle/packages/debugger/lib/stacktrace/selectors/index.js","external \"babel-runtime/helpers/asyncToGenerator\"","/Users/leefaria/work/truffle/packages/debugger/lib/controller/actions/index.js","external \"babel-runtime/core-js/object/keys\"","/Users/leefaria/work/truffle/packages/debugger/lib/txlog/selectors/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/session/selectors/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/evm/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/controller/selectors/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/ast/selectors/index.js","external \"semver\"","/Users/leefaria/work/truffle/packages/debugger/lib/data/actions/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/evm/actions/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/web3/sagas/index.js","external \"web3\"","external \"util\"","/Users/leefaria/work/truffle/packages/debugger/lib/controller/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/txlog/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/txlog/actions/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/solidity/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/solidity/actions/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/stacktrace/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/stacktrace/actions/index.js","/Users/leefaria/work/truffle/node_modules/colors/lib/colors.js","/Users/leefaria/work/truffle/packages/debugger/debugger.js","/Users/leefaria/work/truffle/packages/debugger/lib/debugger.js","/Users/leefaria/work/truffle/packages/debugger/lib/session/index.js","external \"babel-runtime/core-js/promise\"","external \"@truffle/abi-utils\"","external \"json-stable-stringify\"","/Users/leefaria/work/truffle/packages/debugger/lib/store/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/store/production.js","/Users/leefaria/work/truffle/packages/debugger/lib/store/common.js","external \"redux-saga\"","external \"lodash.merge\"","external \"@truffle/source-map-utils\"","external \"lodash.zipwith\"","external \"babel-runtime/core-js/set\"","/Users/leefaria/work/truffle/packages/debugger/lib/web3/actions/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/web3/adapter.js","external \"lodash.sum\"","/Users/leefaria/work/truffle/packages/debugger/lib/session/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/ast/sagas/index.js","/Users/leefaria/work/truffle/packages/debugger/lib/session/reducers.js","/Users/leefaria/work/truffle/packages/debugger/lib/data/reducers.js","/Users/leefaria/work/truffle/packages/debugger/lib/evm/reducers.js","/Users/leefaria/work/truffle/packages/debugger/lib/solidity/reducers.js","external \"lodash.flatten\"","/Users/leefaria/work/truffle/packages/debugger/lib/trace/reducers.js","/Users/leefaria/work/truffle/packages/debugger/lib/controller/reducers.js","/Users/leefaria/work/truffle/packages/debugger/lib/stacktrace/reducers.js","/Users/leefaria/work/truffle/packages/debugger/lib/txlog/reducers.js","/Users/leefaria/work/truffle/packages/compile-common/dist/src/index.js","/Users/leefaria/work/truffle/packages/compile-common/dist/src/shims/index.js","/Users/leefaria/work/truffle/packages/compile-common/dist/src/shims/LegacyToNew.js","/Users/leefaria/work/truffle/packages/compile-common/dist/src/shims/NewToLegacy.js","/Users/leefaria/work/truffle/packages/compile-common/dist/src/sources.js","external \"path\"","/Users/leefaria/work/truffle/packages/compile-common/dist/src/errors.js","/Users/leefaria/work/truffle/node_modules/colors/lib/index.js","/Users/leefaria/work/truffle/node_modules/colors/lib/styles.js","/Users/leefaria/work/truffle/node_modules/colors/lib/system/supports-colors.js","external \"os\"","/Users/leefaria/work/truffle/node_modules/colors/lib/system/has-flag.js","/Users/leefaria/work/truffle/node_modules/colors/lib/custom/trap.js","/Users/leefaria/work/truffle/node_modules/colors/lib/custom/zalgo.js","/Users/leefaria/work/truffle/node_modules/colors/lib/maps/america.js","/Users/leefaria/work/truffle/node_modules/colors/lib/maps/zebra.js","/Users/leefaria/work/truffle/node_modules/colors/lib/maps/rainbow.js","/Users/leefaria/work/truffle/node_modules/colors/lib/maps/random.js","/Users/leefaria/work/truffle/node_modules/colors/lib/extendStringPrototype.js","/Users/leefaria/work/truffle/packages/error/dist/src/index.js","/Users/leefaria/work/truffle/packages/compile-common/dist/src/types.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","isDeliberatelySkippedNodeType","isSkippedNodeType","node","includes","nodeType","undefined","typeDescriptions","Codec","Ast","Utils","typeClass","prefixName","prefix","fn","configurable","makePath","sourceId","pointer","popNWhere","array","numToRemove","predicate","newArray","slice","length","top","pop","keccak256","stableKeccak256","makeAssignment","idObj","ref","id","isCallMnemonic","op","isShortCallMnemonic","isDelegateCallMnemonicBroad","isDelegateCallMnemonicStrict","isStaticCallMnemonic","isCreateMnemonic","isSelfDestructMnemonic","args","Conversion","toHexString","Evm","WORD_SIZE","obj","type","PAST_END_OF_TRACE","depth","error","gas","memory","stack","storage","gasCost","pc","trace","createSelectorTree","index","state","proc","loaded","createLeaf","steps","finished","finishedOrUnloaded","transaction","stepsRemaining","step","next","nextOfSameDepth","application","submoduleCount","ZERO_WORD","repeat","determineFullContext","address","binary","instances","search","contexts","contextId","isConstructor","Boolean","context","createStepSelectors","base","programCounter","isCall","isShortCall","isDelegateCallBroad","isDelegateCallStrict","isStaticCall","isCreate","isSelfDestruct","isCreate2","isStore","isLoad","touchesStorage","stores","loads","isPop","path","startsWith","isRelative","isJump","valueStored","callAddress","toAddress","createBinary","offset","parseInt","join","substring","padEnd","callData","short","argOffset","callValue","calls","delegates","isStatic","BN","toBN","createValue","storageAffected","salt","callContext","evm","info","byContext","binaries","Contexts","findContext","globals","tx","block","status","initialCall","startingContext","affectedInstances","byAddress","current","callstack","map","param","createdAddress","create2Address","ZERO_ADDRESS","storageAddress","ADDRESS_SIZE","isInstantCallOrCreate","creates","contextChange","isContextChange","currentDepth","nextDepth","isNormalHalting","isHalting","isExceptionalHalting","returnStatus","isInstaCall","remaining","finalStatus","returnValue","valueLoaded","beneficiary","currentAddress","codex","_","rawStorage","accounts","code","debug","contextRequiresPhantomStackframes","compiler","semver","satisfies","version","includePrerelease","createMultistepSelectors","stepSelector","instruction","modifierDepth","source","sources","file","findOverlappingRange","functions","sourceRange","SourceMapUtils","getSourceRange","pointerAndNode","range","findRange","start","ast","solidity","bottomStackframeRequiresPhantomFrame","sourceIds","compilationId","contextHash","userSources","internalSources","byCompilationId","byIndex","allSources","ids","sourceMap","humanReadableSourceMap","getHumanReadableSourceMap","functionDepthStack","nextFrameIsPhantom","functionDepth","callRequiresPhantomFrame","instructions","getProcessedInstructionsForBinary","instructionAtProgramCounter","isSourceRangeFinalRaw","changesContext","isSourceRangeFinal","isFinal","currentSource","nextSource","internal","functionsByProgramCounter","getFunctionsByProgramCounter","isMultiline","lines","line","end","willJump","jumpDirection","jump","willCall","isInstant","willReturn","nextUserStep","find","overlapFunctions","views","byId","makeOverlapFunction","saveSteps","SAVE_STEPS","NEXT","tick","TICK","tock","TOCK","endTrace","END_OF_TRACE","reset","RESET","unloadTransaction","UNLOAD_TRANSACTION","backtick","BACKTICK","setSubmoduleCount","count","SET_SUBMODULE_COUNT","put","actions","addSubmoduleToCount","increment","select","advance","take","signalTickSagaCompletion","processTrace","callAddresses","selfDestructAddresses","createdBinaries","add","returnStep","returnStack","selfdestructs","creations","unload","saga","waitingForSubmodules","takeEvery","identity","x","findAncestorOfType","types","scopes","parentId","definition","replace","jsonpointer","modifierForInvocation","invocation","rawId","modifierName","referencedDeclaration","baseName","rawNode","nodes","functionKind","debuggerContextToDecoderContext","contractName","contractId","contractKind","abi","payable","AbiData","computeSelectors","fallbackAbi","fallback","item","receive","NOW_DEFINITION","src","typeIdentifier","typeString","MSG_DEFINITION","TX_DEFINITION","BLOCK_DEFINITION","data","atLastInstructionForSourceRange","final","byAstRef","inlined","astRef","scope","userDefinedTypes","referenceDeclarations","Import","definitionToStoredType","contractAllocationInfo","filter","deployedContext","constructorContext","immutableReferences","contractNode","taggedOutputs","concat","mappingKeys","mappedPaths","byType","bySlotAddress","slot","blockNumber","number","toString","toBytes","bySourceId","allocations","calldata","returndata","assignments","words","word","mapping","specials","sender","this","variable","sourceIndex","language","internalSourceFor","internalFor","newScope","linearizedBaseContractsFromBase","linearizedBaseContracts","reverse","variables","visibility","constant","mutability","isSimpleConstant","exportedSymbols","raw","allAllocations","transformedAllocations","allocation","members","member","location","memberAllocation","bareLetsInYulAreHit","contract","contractForBytecode","fallbackOutputForContext","fallbackDefinition","returnParameters","parameters","function","inModifier","inFunctionOrModifier","fallbackBase","errorLocation","stacktrace","innerReturnPosition","lastPosition","innerLocation","lastLocation","errorNode","astId","errorId","errorCall","expression","makeTypeId","aboutToModify","nextInvocation","argument","arguments","kind","modifierInvocation","modifierArgumentIndex","invocationPointer","difference","rawIndex","match","modifierBeingInvoked","identifiers","cur","msg","builtin","now","definitions","thisDefinition","identifier","builtins","solidityVersionHasNoNow","sections","refs","local","push","stackframe","returnAllocation","constructorAllocations","functionAllocations","contractHasFallbackOutput","output","selector","Allocate","FallbackOutputAllocation","currentCallIsCreate","invalid","nodeId","declare","yulScope","yulDeclare","scopePointer","defineType","defineTaggedOutput","decode","decodeReturnValue","currentContext","decoder","decodeReturndata","result","done","response","request","requestCode","decodeCall","decodeCurrent","decodeCalldata","recordAllocations","contracts","storageAllocations","Storage","getStorageAllocations","memoryAllocations","Memory","getMemoryAllocations","abiAllocations","getAbiAllocations","calldataAllocations","getCalldataAllocations","returndataAllocations","getReturndataAllocations","stateAllocations","getStateAllocations","allocate","web3","tickSaga","preambleAssignments","modifier","currentIndex","parametersLeft","adjustment","stackSize","assignParameters","nextModifier","assign","nextPointer","returnSuffixes","returnVariables","vars","parameterSuffixes","bareLetSuffixes","outerIndex","declaration","body","statements","innerIndex","unshift","suffixes","position","suffix","sourceAndPointer","assignment","from","to","Number","subNode","fallbackInputDefinition","varId","parentPointer","parent","variableSourceAndPointer","literalAssignments","baseExpression","isReference","referenceType","isMapping","currentAssignments","fetchBasePath","keyDefinition","indexValue","indexDefinition","indexId","indexIdObj","fullIndexId","indexReference","splicedDefinition","spliceLocation","indexConstantDeclaration","indexConstantDefinition","operator","subExpression","decodeMappingKeyCore","cleanBool","decodeMappingKeySaga","indexExpression","hashPath","isDynamicArray","asBN","muln","storageSize","definitionToType","mapPathAndAssign","structType","memberAllocations","memberName","clone","variablesAndMappingsSaga","internalFunctionsTable","Uint8Array","decodeVariable","NO_CODE","obtainBinaries","addInstance","literal","Stack","Read","readStack","forModifier","reverseParameters","currentPosition","parameter","baseNode","fullId","baseAssignment","referencedId","provider","txHash","START","loadTransaction","LOAD_TRANSACTION","interrupt","INTERRUPT","ready","READY","wait","WAIT","ERROR","recordContracts","RECORD_CONTRACTS","saveTransaction","SAVE_TRANSACTION","saveReceipt","receipt","SAVE_RECEIPT","saveBlock","SAVE_BLOCK","setLightMode","SET_LIGHT_MODE","setFullMode","SET_FULL_MODE","startFullMode","START_FULL_MODE","addCompilations","ADD_COMPILATIONS","generateReport","message","locations","frame","calledFromLocation","shift","names","functionName","report","nameInfo","Error","Panic","panic","custom","strippedLocation","sourcePath","returnCounter","innerReturnStatus","innerErrorIndex","updateIndex","willJumpIn","willJumpOut","revertString","rawRevertMessage","revertDecodings","decodeRevert","decoding","revertStringInfo","asString","Buffer","asHex","positionWillChange","nextLocation","currentLocation","oldLocation","finalReport","ADVANCE","stepNext","STEP_NEXT","stepOver","STEP_OVER","stepInto","STEP_INTO","stepOut","STEP_OUT","continueUntilBreakpoint","breakpoints","CONTINUE","addBreakpoint","breakpoint","ADD_BREAKPOINT","removeBreakpoint","REMOVE_BREAKPOINT","removeAllBreakpoints","REMOVE_ALL_BREAKPOINTS","setInternalStepping","SET_INTERNAL_STEPPING","startStepping","START_STEPPING","doneStepping","DONE_STEPPING","astNode","inInternalSourceOrYul","txlog","transactionLog","byPointer","origin","absorbFirstInternalCall","currentNodePointer","pointerStack","log","waitingForFunctionDefinition","waitingForInternalCallToAbsorb","absorbNextInternalCall","nextCallPointer","internalReturnPointer","externalReturnPointer","onFunctionDefinition","isNextInternal","currentFunctionIsAsExpected","txlogNode","currentFunction","returnData","inputParameterAllocations","functionDefinition","locateParameters","outputParameterAllocations","tie","results","session","creationBinary","creationContext","creationContextId","primarySource","constructorArgs","readyOrError","waiting","lastLoadingError","isError","success","errored","lightMode","addContext","addAffectedInstance","refreshInstances","begin","gasprice","saveGlobals","saveStatus","callstackAndCodexSaga","fail","currentCall","returnedBinary","returnedContext","returnCreate","returnCall","storedValue","store","loadedValue","load","anyNonSkippedInRange","sourceStart","sourceLength","sourceEnd","some","AST","isOldStyleAssembly","controller","executionContext","resolver","adjustedBreakpoint","lineLengths","split","lineStarts","isStepping","stepIntoInternalSources","SCOPE","scopeAstRef","DECLARE","ASSIGN","parentType","MAP_PATH_AND_ASSIGN","DEFINE_TYPE","DEFINE_TAGGED_OUTPUT","ALLOCATE","ADD_CONTEXT","ADD_INSTANCE","ADD_AFFECTED_INSTANCE","REFRESH_INSTANCE","SAVE_GLOBALS","SAVE_STATUS","CALL","CREATE","RETURN_CALL","RETURN_CREATE","FAIL","STORE","LOAD","inspectTransaction","inspect","action","RECEIVE_TRACE","ERROR_WEB3","RECEIVE_CALL","addresses","tasks","all","fork","receiveBinary","fetchBinary","init","padHexString","hexString","padStart","fetchTransactionInfo","adapter","apply","getTrace","e","receiveTrace","getTransaction","getReceipt","getBlock","chainId","getChainId","solidityBlock","coinbase","miner","difficulty","gaslimit","gasLimit","timestamp","chainid","basefee","baseFeePerGas","receiveCall","input","gasPrice","Web3","utils","isAddress","contractAddress","getDeployedCode","RECEIVE_BINARY","INIT_WEB3","Web3Adapter","INSPECT","FETCH_BINARY","STEP_SAGAS","startingDepth","startingLocation","breakpointHit","currentSourceId","currentLine","currentStart","currentLength","startedInUserSource","lastUserSourceId","lastUserLine","lastUserStart","lastUserLength","previousLine","previousStart","previousLength","previousSourceId","race","exec","starting","allowInternal","upcoming","newPointer","recordOrigin","callKind","absorb","externalCall","selfdestruct","decodings","rawData","externalReturn","revert","absorbedCall","internalCall","astMatchesTxLog","outputAllocations","decodedValue","internalReturn","isDelegate","instant","instantExternalCall","instantCreate","inputAllocations","functionNode","identifyFunctionCall","updateTransactionLogSaga","SELECTOR_SIZE","INTERNAL_CALL","ABSORBED_CALL","INTERNAL_RETURN","EXTERNAL_CALL","INSTANT_EXTERNAL_CALL","INSTANT_CREATE","EXTERNAL_RETURN","SELFDESTRUCT","REVERT","IDENTIFY_FUNCTION_CALL","RECORD_ORIGIN","addSources","guard","clearPhantomGuard","functionDepthSaga","ADD_SOURCES","JUMP","CLEAR_PHANTOM_GUARD","positionUpdated","executeReturn","nextParent","jumpIn","jumpOut","nextContext","nextAddress","updatePosition","stacktraceSaga","JUMP_IN","JUMP_OUT","counter","EXECUTE_RETURN","UPDATE_POSITION","colors","themes","util","ansiStyles","styles","defineProps","defineProperties","newLineRegex","RegExp","supportsColor","enabled","enable","disable","stripColors","strip","str","stylize","style","styleMap","open","close","matchOperatorsRe","build","_styles","builder","applyStyle","__proto__","proto","ret","grey","gray","keys","forEach","closeRe","TypeError","escapeStringRegexp","Array","arg","constructor","String","newLinesPresent","indexOf","nestedStyles","setTheme","theme","out","console","sequencer","exploded","trap","zalgo","maps","america","zebra","rainbow","random","Debugger","default","forTx","options","files","compilations","Compilations","shimArtifacts","Session","forProject","createNestedSelector","astSelector","dataSelector","txlogSelector","traceSelector","evmSelector","soliditySelector","stacktraceSelector","sessionSelector","controllerSelector","Abi","dataSagas","controllerSagas","sagas","moduleOptions","sagaMiddleware","reducer","rootSaga","_store","_sagaMiddleware","normalize","dispatch","_ready","accept","reject","unsubscribe","subscribe","view","readyAgainAfterLoading","sessionAction","hasStartedWaiting","user","makeSourceId","compilation","unreliableSourceOrder","primarySourceIndex","bytecode","deployedBytecode","deployedBinary","deployedSourceMap","primarySourceId","generatedSources","deployedGeneratedSources","Shims","NewToLegacy","forBytecode","findIndex","getContractNode","simpleShimSourceMap","normalizeContexts","getState","_runSaga","run","toPromise","stepperAction","resolve","hasStarted","active","decodeReady","decoded","connect","addExternalCompilations","configureStore","sagaArgs","initialState","composeEnhancers","compose","createStore","applyMiddleware","promisify","currentProvider","send","jsonrpc","method","params","Date","getTime","structLogs","eth","getTransactionReceipt","blockNumberOrHash","getCode","processTransaction","LOAD_SAGAS","recordContexts","recordSources","listenersToActivate","listener","visitAll","listenerSaga","mainApps","otherApps","apps","app","forkListeners","err","nonCallStartIndex","recordInstance","fetchTx","affectedInstanceOnly","walk","handleEnter","isArray","child","entries","yulWalk","basePointer","findYulScopePointer","relativePointer","relativeParentPointer","handleYulEnter","_parentId","handleYulExit","handleYul","handleExit","combineReducers","reduceState","DEFAULT_SCOPES","DEFAULT_ALLOCATIONS","GLOBAL_ASSIGNMENTS","special","DEFAULT_ASSIGNMENTS","DEFAULT_PATHS","regularizeTypeIdentifier","hexSlotAddress","slotAddress","parentAddress","newState","newSlot","DEFAULT_CONTEXTS","abiHasPayableFallback","DEFAULT_TX","DEFAULT_BLOCK","DEFAULT_AFFECTED_INSTANCES","DEFAULT_CODEX","topCodex","updateFrameStorage","updateFrameCode","existingPage","safeSave","DEFAULT_SOURCES","hash","delta","belowTop","Math","max","newFrame","ETERNAL_CALL","DEFAULT_TX_LOG","modifiedNode","returnKind","returnValues","currentPointer","currentNode","finalNode","immutables","returnImmutables","__createBinding","k","k2","__setModuleDefault","v","__importStar","mod","__exportStar","Errors","Sources","LegacyToNew","forContract","contract_name","legacyAST","metadata","devdoc","userdoc","db","linkReferences","bytes","linkReference","characterOffset","characterLength","offsets","forContracts","values","reduce","a","b","linkId","unlinked_binary","collectSources","getPortableSourcePath","replacement","sep","replaceRootDirectory","rootDirectory","endsWith","originalSources","originalTargets","baseDirectory","originalSourcePath","isAbsolute","contents","targets","originalSourcePaths","accumulator","__importDefault","CompileError","colors_1","error_1","fancy_message","trim","red","super","codes","bold","dim","italic","underline","inverse","hidden","strikethrough","black","green","yellow","blue","magenta","cyan","white","brightRed","brightGreen","brightYellow","brightBlue","brightMagenta","brightCyan","brightWhite","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","bgGray","bgGrey","bgBrightRed","bgBrightGreen","bgBrightYellow","bgBrightBlue","bgBrightMagenta","bgBrightCyan","bgBrightWhite","blackBG","redBG","greenBG","yellowBG","blueBG","magentaBG","cyanBG","whiteBG","val","os","hasFlag","env","process","forceColor","getSupportLevel","stream","level","hasBasic","has256","has16m","translateLevel","isTTY","min","platform","osRelease","release","versions","sign","CI_NAME","test","TEAMCITY_VERSION","TERM_PROGRAM_VERSION","TERM_PROGRAM","TERM","FORCE_COLOR","stdout","stderr","flag","argv","terminatorPos","pos","text","f","g","h","j","q","u","w","y","z","toLowerCase","chars","rand","floor","soul","up","down","mid","randomNumber","isChar","character","bool","counts","size","arr","heComes","letter","rainbowColors","available","round","addProperty","color","func","__defineGetter__","stringPrototypeBlacklist","prop","themePropApplicator","applyTheme","ExtendableError"],"mappings":"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","file":"debugger.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Debugger\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Debugger\"] = factory();\n\telse\n\t\troot[\"Debugger\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 43);\n","module.exports = require(\"debug\");","import * as Codec from \"@truffle/codec\";\nimport stringify from \"json-stable-stringify\";\n\n/** AST node types that are skipped by stepNext() to filter out some noise */\nexport function isDeliberatelySkippedNodeType(node) {\n  const skippedTypes = [\n    \"ContractDefinition\",\n    \"VariableDeclaration\",\n    \"YulVariableDeclaration\",\n    \"YulBlock\"\n  ];\n  return skippedTypes.includes(node.nodeType);\n}\n\n//HACK\n//these aren't the only types of skipped nodes, but determining all skipped\n//nodes would be too difficult\nexport function isSkippedNodeType(node) {\n  const otherSkippedTypes = [\n    \"VariableDeclarationStatement\",\n    \"Mapping\",\n    \"Block\",\n    \"InlineAssembly\", //definitely do *not* add to deliberately skipped!\n    \"YulTypedName\"\n  ];\n  return (\n    isDeliberatelySkippedNodeType(node) ||\n    otherSkippedTypes.includes(node.nodeType) ||\n    node.nodeType.includes(\"TypeName\") || //HACK\n    //skip string literals too -- we'll handle that manually\n    (node.typeDescriptions !== undefined && //seems this sometimes happens?\n      Codec.Ast.Utils.typeClass(node) === \"stringliteral\")\n  );\n}\n\nexport function prefixName(prefix, fn) {\n  Object.defineProperty(fn, \"name\", {\n    value: `${prefix}.${fn.name}`,\n    configurable: true\n  });\n\n  return fn;\n}\n\nexport function makePath(sourceId, pointer) {\n  return `${sourceId}:${pointer}`;\n}\n\n/**\n * returns a new array which is a copy of array but with\n * elements popped from the top until numToRemove elements\n * satisfying the predicate have been removed (or until the\n * array is empty)\n */\nexport function popNWhere(array, numToRemove, predicate) {\n  let newArray = array.slice();\n  //I'm going to write this the C way, hope you don't mind :P\n  while (numToRemove > 0 && newArray.length > 0) {\n    let top = newArray[newArray.length - 1];\n    if (predicate(top)) {\n      numToRemove--;\n    }\n    newArray.pop();\n  }\n  return newArray;\n}\n\n/**\n * @return 0x-prefix string of keccak256 hash\n */\nexport function keccak256(...args) {\n  return Codec.Conversion.toHexString(\n    Codec.Evm.Utils.keccak256(...args),\n    Codec.Evm.Utils.WORD_SIZE\n  );\n}\n\n/**\n * Given an object, return a stable hash by first running it through a stable\n * stringify operation before hashing\n */\nexport function stableKeccak256(obj) {\n  return keccak256({ type: \"string\", value: stringify(obj) });\n}\n\n/*\n * used by data; takes an id object and a ref (pointer) and returns a full\n * corresponding assignment object\n */\nexport function makeAssignment(idObj, ref) {\n  let id = stableKeccak256(idObj);\n  return { ...idObj, id, ref };\n}\n\n/*\n * Given a mmemonic, determine whether it's the mnemonic of a calling\n * instruction (does NOT include creation instructions)\n */\nexport function isCallMnemonic(op) {\n  const calls = [\"CALL\", \"DELEGATECALL\", \"STATICCALL\", \"CALLCODE\"];\n  return calls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that take only 6 args instead of 7\n */\nexport function isShortCallMnemonic(op) {\n  const shortCalls = [\"DELEGATECALL\", \"STATICCALL\"];\n  return shortCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that delegate storage\n */\nexport function isDelegateCallMnemonicBroad(op) {\n  const delegateCalls = [\"DELEGATECALL\", \"CALLCODE\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that delegate everything\n */\nexport function isDelegateCallMnemonicStrict(op) {\n  const delegateCalls = [\"DELEGATECALL\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for static calls\n */\nexport function isStaticCallMnemonic(op) {\n  const delegateCalls = [\"STATICCALL\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * Given a mmemonic, determine whether it's the mnemonic of a creation\n * instruction\n */\nexport function isCreateMnemonic(op) {\n  const creates = [\"CREATE\", \"CREATE2\"];\n  return creates.includes(op);\n}\n\n/*\n * Given a mmemonic, determine whether it's the mnemonic of a self-destruct\n * instruction\n */\nexport function isSelfDestructMnemonic(op) {\n  const creates = [\"SELFDESTRUCT\", \"SUICIDE\"]; //latter name shouldn't be used anymore but let's be safe\n  return creates.includes(op);\n}\n","module.exports = require(\"babel-runtime/helpers/extends\");","module.exports = require(\"@truffle/codec\");","module.exports = require(\"reselect-tree\");","import { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nconst PAST_END_OF_TRACE = {\n  depth: -1, //this is the part that matters!\n  //the rest of this is just to look like a trace step\n  error: \"\",\n  gas: 0,\n  memory: [],\n  stack: [],\n  storage: {},\n  gasCost: 0,\n  op: \"STOP\",\n  pc: -1 //this is not at all valid but that's fine\n};\n\nlet trace = createSelectorTree({\n  /**\n   * trace.index\n   *\n   * current step index\n   */\n  index: state => state.trace.proc.index,\n\n  /*\n   * trace.loaded\n   * is a trace loaded?\n   */\n  loaded: createLeaf([\"/steps\"], steps => steps !== null),\n\n  /**\n   * trace.finished\n   * is the trace finished?\n   */\n  finished: state => state.trace.proc.finished,\n\n  /**\n   * trace.finishedOrUnloaded\n   *\n   * is the trace finished, including if it's unloaded?\n   */\n  finishedOrUnloaded: createLeaf(\n    [\"/finished\", \"/loaded\"],\n    (finished, loaded) => finished || !loaded\n  ),\n\n  /**\n   * trace.steps\n   *\n   * all trace steps\n   */\n  steps: state => state.trace.transaction.steps,\n\n  /**\n   * trace.stepsRemaining\n   *\n   * number of steps remaining in trace\n   */\n  stepsRemaining: createLeaf(\n    [\"./steps\", \"./index\"],\n    (steps, index) => steps.length - index\n  ),\n\n  /**\n   * trace.step\n   *\n   * current trace step\n   * HACK: if no steps,\n   * we will return a spoofed \"past end\" step\n   */\n  step: createLeaf(\n    [\"./steps\", \"./index\"],\n    (steps, index) =>\n      steps ? (steps.length > 0 ? steps[index] : PAST_END_OF_TRACE) : null //null if no tx loaded\n  ),\n\n  /**\n   * trace.next\n   *\n   * next trace step\n   * HACK: if at the end,\n   * we will return a spoofed \"past end\" step\n   */\n  next: createLeaf([\"./steps\", \"./index\"], (steps, index) =>\n    index < steps.length - 1 ? steps[index + 1] : PAST_END_OF_TRACE\n  ),\n\n  /*\n   * trace.nextOfSameDepth\n   * next trace step that's at the same depth as this one\n   * NOTE: if there is none, will return undefined\n   * (should not be used in such cases)\n   * NOTE: for additional correctness, will stop searching once\n   * it hits something of *lower* depth (yes that makes the name\n   * a little misleading, but the idea is to find the return step\n   * for a given call step)\n   */\n  nextOfSameDepth: createLeaf([\"./steps\", \"./index\"], (steps, index) => {\n    let depth = steps[index].depth;\n    for (let step of steps.slice(index + 1)) {\n      //start searching after current step\n      //using a manual for loop here instead of .find in order to\n      //cut off the search early if needed\n      if (step.depth === depth) {\n        return step;\n      }\n      if (step.depth < depth) {\n        return undefined;\n      }\n    }\n    return undefined;\n  }),\n\n  /**\n   * trace.application\n   */\n  application: {\n    /**\n     * trace.application.submoduleCount\n     */\n    submoduleCount: state => state.trace.application.submoduleCount\n  }\n});\n\nexport default trace;\n","module.exports = require(\"redux-saga/effects\");","module.exports = require(\"redux\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:selectors\"); // eslint-disable-line no-unused-vars\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport BN from \"bn.js\";\n\nimport trace from \"lib/trace/selectors\";\n\nimport * as Codec from \"@truffle/codec\";\nimport {\n  keccak256,\n  isCallMnemonic,\n  isCreateMnemonic,\n  isShortCallMnemonic,\n  isDelegateCallMnemonicBroad,\n  isDelegateCallMnemonicStrict,\n  isStaticCallMnemonic,\n  isSelfDestructMnemonic\n} from \"lib/helpers\";\n\nconst ZERO_WORD = \"00\".repeat(Codec.Evm.Utils.WORD_SIZE);\n\nfunction determineFullContext(\n  { address, binary },\n  instances,\n  search,\n  contexts\n) {\n  let contextId;\n  let isConstructor = Boolean(binary);\n  if (address) {\n    //if we're in a call to a deployed contract, we must have recorded\n    //the context in the codex, so we don't need to do any further\n    //searching\n    ({ context: contextId, binary } = instances[address]);\n  } else if (isConstructor) {\n    //otherwise, if we're in a constructor, we'll need to actually do a\n    //search\n    contextId = search(binary);\n  } else {\n    //exceptional case: no transaction is loaded\n    return null;\n  }\n\n  if (contextId != undefined) {\n    //if we found the context, use it\n    let context = contexts[contextId];\n    return {\n      ...context,\n      binary\n    };\n  } else {\n    //otherwise we'll construct something default\n    return {\n      binary,\n      isConstructor\n    };\n  }\n}\n\n/**\n * create EVM-level selectors for a given trace step selector\n * may specify additional selectors to include\n */\nfunction createStepSelectors(step, state = null) {\n  let base = {\n    /**\n     * .trace\n     *\n     * trace step info related to operation\n     */\n    trace: createLeaf([step], step => {\n      if (!step) {\n        return null;\n      }\n      let { gasCost, op, pc } = step;\n      return { gasCost, op, pc };\n    }),\n\n    /**\n     * .programCounter\n     */\n    programCounter: createLeaf([\"./trace\"], step => (step ? step.pc : null)),\n\n    /**\n     * .isCall\n     *\n     * whether the opcode will switch to another calling context\n     */\n    isCall: createLeaf([\"./trace\"], step => isCallMnemonic(step.op)),\n\n    /**\n     * .isShortCall\n     *\n     * for calls that only take 6 arguments instead of 7\n     */\n    isShortCall: createLeaf([\"./trace\"], step => isShortCallMnemonic(step.op)),\n\n    /**\n     * .isDelegateCallBroad\n     *\n     * for calls that delegate storage\n     */\n    isDelegateCallBroad: createLeaf([\"./trace\"], step =>\n      isDelegateCallMnemonicBroad(step.op)\n    ),\n\n    /**\n     * .isDelegateCallStrict\n     *\n     * for calls that additionally delegate sender and value\n     */\n    isDelegateCallStrict: createLeaf([\"./trace\"], step =>\n      isDelegateCallMnemonicStrict(step.op)\n    ),\n\n    /**\n     * .isStaticCall\n     */\n    isStaticCall: createLeaf([\"./trace\"], step =>\n      isStaticCallMnemonic(step.op)\n    ),\n\n    /**\n     * .isCreate\n     * (includes CREATE2)\n     */\n    isCreate: createLeaf([\"./trace\"], step => isCreateMnemonic(step.op)),\n\n    /**\n     * .isSelfDestruct\n     */\n    isSelfDestruct: createLeaf([\"./trace\"], step =>\n      isSelfDestructMnemonic(step.op)\n    ),\n\n    /**\n     * .isCreate2\n     */\n    isCreate2: createLeaf([\"./trace\"], step => step.op === \"CREATE2\"),\n\n    /*\n     * .isStore\n     */\n    isStore: createLeaf([\"./trace\"], step => step.op === \"SSTORE\"),\n\n    /*\n     * .isLoad\n     */\n    isLoad: createLeaf([\"./trace\"], step => step.op === \"SLOAD\"),\n\n    /*\n     * .touchesStorage\n     *\n     * whether the instruction involves storage\n     */\n    touchesStorage: createLeaf(\n      [\"./isStore\", \"isLoad\"],\n      (stores, loads) => stores || loads\n    ),\n\n    /*\n     * .isPop\n     * used by data\n     */\n    isPop: createLeaf([\"./trace\"], step => step.op === \"POP\")\n  };\n\n  if (state) {\n    const isRelative = path =>\n      typeof path === \"string\" &&\n      (path.startsWith(\"./\") || path.startsWith(\"../\"));\n\n    if (isRelative(state)) {\n      state = `../${state}`;\n    }\n\n    Object.assign(base, {\n      /**\n       * .isJump\n       */\n      isJump: createLeaf(\n        [\"./trace\", state],\n        (step, { stack }) =>\n          step.op === \"JUMP\" ||\n          (step.op === \"JUMPI\" && stack[stack.length - 2] !== ZERO_WORD)\n      ),\n\n      /**\n       * .valueStored\n       * the storage written, as determined by looking at the stack\n       * rather than at storage (since valueLoaded is now being done\n       * this way, may as well do valueStored this way as well and\n       * completely remove our dependence on the storage field!)\n       */\n      valueStored: createLeaf([\"./isStore\", state], (isStore, { stack }) => {\n        if (!isStore) {\n          return null;\n        }\n        return stack[stack.length - 2];\n      }),\n\n      /**\n       * .callAddress\n       *\n       * address transferred to by call operation\n       */\n      callAddress: createLeaf(\n        [\"./isCall\", state],\n\n        (isCall, { stack }) => {\n          if (!isCall) {\n            return null;\n          }\n\n          let address = stack[stack.length - 2];\n          return Codec.Evm.Utils.toAddress(address);\n        }\n      ),\n\n      /**\n       * .createBinary\n       *\n       * binary code to execute via create operation\n       */\n      createBinary: createLeaf(\n        [\"./isCreate\", state],\n\n        (isCreate, { stack, memory }) => {\n          if (!isCreate) {\n            return null;\n          }\n\n          // Get the code that's going to be created from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 2], 16) * 2;\n          const length = parseInt(stack[stack.length - 3], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * .callData\n       *\n       * data passed to EVM call\n       */\n      callData: createLeaf(\n        [\"./isCall\", \"./isShortCall\", state],\n        (isCall, short, { stack, memory }) => {\n          if (!isCall) {\n            return null;\n          }\n\n          //if it's 6-argument call, the data start and offset will be one spot\n          //higher in the stack than they would be for a 7-argument call, so\n          //let's introduce an offset to handle this\n          let argOffset = short ? 1 : 0;\n\n          // Get the data from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 4 + argOffset], 16) * 2;\n          const length = parseInt(stack[stack.length - 5 + argOffset], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * .callValue\n       *\n       * value for the call (not create); returns null for DELEGATECALL\n       */\n      callValue: createLeaf(\n        [\"./isCall\", \"./isDelegateCallStrict\", \"./isStaticCall\", state],\n        (calls, delegates, isStatic, { stack }) => {\n          if (!calls || delegates) {\n            return null;\n          }\n\n          if (isStatic) {\n            return new BN(0);\n          }\n\n          //otherwise, for CALL and CALLCODE, it's the 3rd argument\n          let value = stack[stack.length - 3];\n          return Codec.Conversion.toBN(value);\n        }\n      ),\n\n      /**\n       * .createValue\n       *\n       * value for the create\n       */\n      createValue: createLeaf([\"./isCreate\", state], (isCreate, { stack }) => {\n        if (!isCreate) {\n          return null;\n        }\n\n        //creates have the value as the first argument\n        let value = stack[stack.length - 1];\n        return Codec.Conversion.toBN(value);\n      }),\n\n      /**\n       * .storageAffected\n       *\n       * storage slot being stored to or loaded from\n       * we do NOT prepend \"0x\"\n       */\n      storageAffected: createLeaf(\n        [\"./touchesStorage\", state],\n\n        (touchesStorage, { stack }) => {\n          if (!touchesStorage) {\n            return null;\n          }\n\n          return stack[stack.length - 1];\n        }\n      ),\n\n      /**\n       * .salt\n       */\n      salt: createLeaf(\n        [\"./isCreate2\", state],\n\n        (isCreate2, { stack }) => {\n          if (!isCreate2) {\n            return null;\n          }\n\n          return \"0x\" + stack[stack.length - 4];\n        }\n      ),\n\n      /**\n       * .callContext\n       *\n       * context of what this step is calling/creating (if applicable)\n       */\n      callContext: createLeaf(\n        [\n          \"./callAddress\",\n          \"./createBinary\",\n          \"/current/codex/instances\",\n          \"/info/binaries/search\",\n          \"/info/contexts\"\n        ],\n        (address, binary, instances, search, contexts) =>\n          determineFullContext({ address, binary }, instances, search, contexts)\n      )\n    });\n  }\n\n  return base;\n}\n\nconst evm = createSelectorTree({\n  /**\n   * evm.state\n   */\n  state: state => state.evm,\n\n  /**\n   * evm.info\n   */\n  info: {\n    /**\n     * evm.info.contexts\n     */\n    contexts: createLeaf([\"/state\"], state => state.info.contexts.byContext),\n\n    /**\n     * evm.info.binaries\n     */\n    binaries: {\n      /**\n       * evm.info.binaries.search\n       *\n       * returns function (binary) => context (returns the *ID* of the context)\n       * (returns null on no match)\n       */\n      search: createLeaf([\"/info/contexts\"], contexts => binary =>\n        //HACK: the type of contexts doesn't actually match!! fortunately\n        //it's good enough to work\n        (Codec.Contexts.Utils.findContext(contexts, binary) || { context: null }).context\n      )\n    }\n  },\n\n  /**\n   * evm.transaction\n   */\n  transaction: {\n    /**\n     * evm.transaction.globals\n     */\n    globals: {\n      /**\n       * evm.transaction.globals.tx\n       */\n      tx: createLeaf([\"/state\"], state => state.transaction.globals.tx),\n\n      /**\n       * evm.transaction.globals.block\n       */\n      block: createLeaf([\"/state\"], state => state.transaction.globals.block)\n    },\n\n    /**\n     * evm.transaction.status\n     */\n    status: createLeaf([\"/state\"], state => state.transaction.status),\n\n    /**\n     * evm.transaction.initialCall\n     */\n    initialCall: createLeaf([\"/state\"], state => state.transaction.initialCall),\n\n    /**\n     * evm.transaction.startingContext\n     */\n    startingContext: createLeaf(\n      [\n        \"/current/callstack\", //we're just getting bottom stackframe, so this is in fact tx-level\n        \"/current/codex/instances\", //this should also be fine?\n        \"/info/binaries/search\",\n        \"/info/contexts\"\n      ],\n      (stack, instances, search, contexts) =>\n        stack.length > 0\n          ? determineFullContext(stack[0], instances, search, contexts)\n          : null\n    ),\n\n    /**\n     * evm.transaction.affectedInstances\n     */\n    affectedInstances: createLeaf(\n      [\"/state\"],\n      state => state.transaction.affectedInstances.byAddress\n    )\n  },\n\n  /**\n   * evm.current\n   */\n  current: {\n    /**\n     * evm.current.callstack\n     */\n    callstack: state => state.evm.proc.callstack,\n\n    /**\n     * evm.current.call\n     */\n    call: createLeaf(\n      [\"./callstack\"],\n\n      stack => (stack.length ? stack[stack.length - 1] : {})\n    ),\n\n    /**\n     * evm.current.context\n     */\n    context: createLeaf(\n      [\n        \"./call\",\n        \"./codex/instances\",\n        \"/info/binaries/search\",\n        \"/info/contexts\"\n      ],\n      determineFullContext\n    ),\n\n    /**\n     * evm.current.state\n     *\n     * evm state info: as of last operation, before op defined in step\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\", \"storage\"].map(param => ({\n        [param]: createLeaf([trace.step], step => step[param])\n      }))\n    ),\n\n    /**\n     * evm.current.step\n     */\n    step: {\n      ...createStepSelectors(trace.step, \"./state\"),\n\n      //the following step selectors only exist for current, not next or any\n      //other step\n\n      /**\n       * evm.current.step.createdAddress\n       *\n       * address created by the current create step\n       */\n      createdAddress: createLeaf(\n        [\n          \"./isCreate\",\n          \"/nextOfSameDepth/state/stack\",\n          \"./isCreate2\",\n          \"./create2Address\"\n        ],\n        (isCreate, stack, isCreate2, create2Address) => {\n          if (!isCreate) {\n            return null;\n          }\n          let address = stack //may be null if the create step itself fails\n            ? Codec.Evm.Utils.toAddress(stack[stack.length - 1])\n            : Codec.Evm.Utils.ZERO_ADDRESS; //nothing got created, so...\n          if (address === Codec.Evm.Utils.ZERO_ADDRESS && isCreate2) {\n            return create2Address;\n          }\n          return address;\n        }\n      ),\n\n      /**\n       * evm.current.step.create2Address\n       *\n       * address created by the current create2 step\n       * (computed, not read off the return)\n       */\n      create2Address: createLeaf(\n        [\"./isCreate2\", \"./createBinary\", \"../call\", \"../state/stack\"],\n        (isCreate2, binary, { storageAddress }, stack) =>\n          isCreate2\n            ? Codec.Evm.Utils.toAddress(\n                \"0x\" +\n                  keccak256({\n                    type: \"bytes\",\n                    value:\n                      //slice 2's are for cutting off initial \"0x\" where we've prepended this\n                      //0xff, then address, then salt, then code hash\n                      \"0xff\" +\n                      storageAddress.slice(2) +\n                      stack[stack.length - 4] +\n                      keccak256({ type: \"bytes\", value: binary }).slice(2)\n                  }).slice(\n                    2 +\n                      2 *\n                        (Codec.Evm.Utils.WORD_SIZE -\n                          Codec.Evm.Utils.ADDRESS_SIZE)\n                  )\n                //slice off initial 0x and initial 12 bytes (note we've re-prepended the\n                //0x at the beginning)\n              )\n            : null\n      ),\n\n      /**\n       * evm.current.step.isInstantCallOrCreate\n       *\n       * are we doing a call or create for which there are no trace steps?\n       * This can happen if:\n       * 1. we call a precompile\n       * 2. we call an externally-owned account (or other account w/no code)\n       * 3. we do a call or create but the call stack is exhausted\n       * 4. we attempt to transfer more ether than we have\n       */\n      isInstantCallOrCreate: createLeaf(\n        [\"./isCall\", \"./isCreate\", \"./isContextChange\"],\n        (calls, creates, contextChange) => (calls || creates) && !contextChange\n      ),\n\n      /**\n       * evm.current.step.isContextChange\n       * groups together calls, creates, halts, and exceptional halts\n       */\n      isContextChange: createLeaf(\n        [\"/current/state/depth\", \"/next/state/depth\"],\n        (currentDepth, nextDepth) => currentDepth !== nextDepth\n      ),\n\n      /**\n       * evm.current.step.isNormalHalting\n       */\n      isNormalHalting: createLeaf(\n        [\"./isHalting\", \"./returnStatus\"],\n        (isHalting, status) => isHalting && status\n      ),\n\n      /**\n       * evm.current.step.isHalting\n       *\n       * whether the instruction halts or returns from a calling context\n       * HACK: the check for stepsRemainining === 0 is a hack to cover\n       * the special case when there are no trace steps; normally this\n       * is unnecessary because the spoofed step past the end covers it\n       */\n      isHalting: createLeaf(\n        [\"/current/state/depth\", \"/next/state/depth\", trace.stepsRemaining],\n        (currentDepth, nextDepth, stepsRemaining) =>\n          nextDepth < currentDepth || stepsRemaining === 0\n      ),\n\n      /**\n       * evm.current.step.isExceptionalHalting\n       */\n      isExceptionalHalting: createLeaf(\n        [\"./isHalting\", \"./returnStatus\"],\n        (isHalting, status) => isHalting && !status\n      ),\n\n      /**\n       * evm.current.step.returnStatus\n       * checks the return status of the *current* halting instruction or insta-call\n       * returns null if not halting & not an insta-call\n       * (returns a boolean -- true for success, false for failure)\n       */\n      returnStatus: createLeaf(\n        [\n          \"./isHalting\",\n          \"./isInstantCallOrCreate\",\n          \"/next/state\",\n          trace.stepsRemaining,\n          \"/transaction/status\"\n        ],\n        (isHalting, isInstaCall, { stack }, remaining, finalStatus) => {\n          if (!isHalting && !isInstaCall) {\n            return null; //not clear this'll do much good since this may get\n            //read as false, but, oh well, may as well\n          }\n          if (remaining <= 1) {\n            return finalStatus;\n          } else {\n            return stack[stack.length - 1] !== ZERO_WORD;\n          }\n        }\n      ),\n\n      /**\n       * evm.current.step.returnValue\n       *\n       * for a [successful] RETURN or REVERT instruction, the value returned;\n       * we DO prepend \"0x\"\n       * for everything else, including unsuccessful RETURN, just returns \"0x\"\n       * (which is what the return value would be if the instruction were to\n       * fail) (or succeed in the case of STOP or SELFDESTRUCT)\n       * NOTE: technically this will be wrong if a REVERT fails, but that case\n       * is hard to detect and it barely matters\n       */\n      returnValue: createLeaf(\n        [\"./trace\", \"./isExceptionalHalting\", \"../state\"],\n\n        (step, isExceptionalHalting, { stack, memory }) => {\n          if (step.op !== \"RETURN\" && step.op !== \"REVERT\") {\n            return \"0x\";\n          }\n          if (isExceptionalHalting && step.op !== \"REVERT\") {\n            return \"0x\";\n          }\n          // Get the data from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 1], 16) * 2;\n          const length = parseInt(stack[stack.length - 2], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * evm.current.step.valueLoaded\n       * the storage loaded on an SLOAD. determined by examining\n       * the next stack, rather than storage (we're avoiding\n       * relying on storage to support old versions of Geth and Besu)\n       * we do not include an initial \"0x\"\n       */\n      valueLoaded: createLeaf(\n        [\"./isLoad\", \"/next/state\"],\n        (isLoad, { stack }) => {\n          if (!isLoad) {\n            return null;\n          }\n          return stack[stack.length - 1];\n        }\n      ),\n\n      /**\n       * evm.current.step.beneficiary\n       * NOTE: for a value-destroying selfdestruct, returns null\n       */\n      beneficiary: createLeaf(\n        [\"./isSelfDestruct\", \"../state\", \"../call\"],\n\n        (isSelfDestruct, { stack }, { storageAddress: currentAddress }) => {\n          if (!isSelfDestruct) {\n            return null;\n          }\n          const beneficiary = Codec.Evm.Utils.toAddress(\n            stack[stack.length - 1]\n          );\n          return beneficiary !== currentAddress ? beneficiary : null;\n        }\n      )\n    },\n\n    /**\n     * evm.current.codex (namespace)\n     */\n    codex: {\n      /**\n       * evm.current.codex (selector)\n       * the whole codex! not that that's very much at the moment\n       */\n      _: createLeaf([\"/state\"], state => state.proc.codex),\n\n      /**\n       * evm.current.codex.storage\n       * the current storage, as fetched from the codex... unless we're in a\n       * failed creation call, then we just fall back on the state (which will\n       * work, since nothing else can interfere with the storage of a failed\n       * creation call!)\n       */\n      storage: createLeaf(\n        [\"./_\", \"../state/storage\", \"../call\"],\n        (codex, rawStorage, { storageAddress }) =>\n          storageAddress === Codec.Evm.Utils.ZERO_ADDRESS\n            ? rawStorage //HACK -- if zero address ignore the codex\n            : codex[codex.length - 1].accounts[storageAddress].storage\n      ),\n\n      /*\n       * evm.current.codex.instances\n       */\n      instances: createLeaf([\"./_\"], codex =>\n        Object.assign(\n          {},\n          ...Object.entries(codex[codex.length - 1].accounts).map(\n            ([address, { code, context }]) => ({\n              [address]: { address, binary: code, context }\n            })\n          )\n        )\n      )\n    }\n  },\n\n  /**\n   * evm.next\n   */\n  next: {\n    /**\n     * evm.next.state\n     *\n     * evm state as a result of next step operation\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\", \"storage\"].map(param => ({\n        [param]: createLeaf([trace.next], step => step[param])\n      }))\n    ),\n\n    /*\n     * evm.next.step\n     */\n    step: createStepSelectors(trace.next, \"./state\")\n  },\n\n  /**\n   * evm.nextOfSameDepth\n   */\n  nextOfSameDepth: {\n    /**\n     * evm.nextOfSameDepth.state\n     *\n     * evm state at the next step of same depth\n     * individual parts of the state will return null if there\n     * is no such step\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\", \"storage\"].map(param => ({\n        [param]: createLeaf([trace.nextOfSameDepth], step =>\n          step ? step[param] : null\n        )\n      }))\n    )\n  }\n});\n\nexport default evm;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:solidity:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport SourceMapUtils from \"@truffle/source-map-utils\";\n\nimport semver from \"semver\";\n\nimport evm from \"lib/evm/selectors\";\nimport trace from \"lib/trace/selectors\";\n\nfunction contextRequiresPhantomStackframes(context) {\n  debug(\"context: %O\", context);\n  return (\n    context.compiler !== undefined && //(do NOT just put context.compiler here,\n    //we need this to be a boolean, not undefined, because it gets put in the state)\n    context.compiler.name === \"solc\" &&\n    semver.satisfies(context.compiler.version, \">=0.5.1\", {\n      includePrerelease: true\n    }) &&\n    !context.isConstructor //constructors should not get a phantom stackframe!\n  );\n}\n\n//function to create selectors that need both a current and next version\nfunction createMultistepSelectors(stepSelector) {\n  return {\n    /**\n     * .instruction\n     */\n    instruction: createLeaf(\n      [\"/current/instructionAtProgramCounter\", stepSelector.programCounter],\n      //HACK: we use solidity.current.instructionAtProgramCounter\n      //even if we're looking at solidity.next.\n      //This is harmless... so long as the current instruction isn't a context\n      //change.  So, don't use solidity.next when it is.\n\n      (map, pc) => map[pc] || {}\n    ),\n\n    /**\n     * .modifierDepth\n     */\n    modifierDepth: createLeaf(\n      [\"./instruction\"],\n      instruction => instruction.modifierDepth\n    ),\n\n    /**\n     * .source\n     */\n    source: createLeaf(\n      //HACK: same hack as with instruction (we use current sources).\n      //but I don't need to give the same warning twice.\n      [\"/current/sources\", \"./instruction\"],\n\n      (sources, { file: index }) => (sources ? sources[index] || {} : {})\n    ),\n\n    /**\n     * HACK... you get the idea\n     */\n    findOverlappingRange: createLeaf(\n      [\"./source\", \"/current/overlapFunctions\"],\n      ({ index }, functions) => (functions || {})[index]\n    ),\n\n    /**\n     * .sourceRange\n     */\n    sourceRange: createLeaf([\"./instruction\"], SourceMapUtils.getSourceRange),\n\n    /**\n     * .pointerAndNode\n     */\n    pointerAndNode: createLeaf(\n      [\"./findOverlappingRange\", \"./sourceRange\"],\n\n      (findOverlappingRange, range) =>\n        findOverlappingRange\n          ? SourceMapUtils.findRange(\n              findOverlappingRange,\n              range.start,\n              range.length\n            )\n          : null\n    ),\n\n    /**\n     * .pointer\n     */\n    pointer: createLeaf(\n      [\"./pointerAndNode\"],\n\n      pointerAndNode => (pointerAndNode ? pointerAndNode.pointer : null)\n    ),\n\n    /**\n     * .node\n     */\n    node: createLeaf(\n      [\"./source\", \"./pointerAndNode\"],\n\n      ({ ast }, pointerAndNode) => (pointerAndNode ? pointerAndNode.node : ast)\n    )\n  };\n}\n\nlet solidity = createSelectorTree({\n  /**\n   * solidity.state\n   */\n  state: state => state.solidity,\n\n  /**\n   * solidity.info\n   */\n  info: {\n    /**\n     * solidity.info.sources\n     */\n    sources: createLeaf([\"/state\"], state => state.info.sources)\n  },\n\n  /**\n   * solidity.transaction\n   */\n  transaction: {\n    /**\n     * solidity.transaction.bottomStackframeRequiresPhantomFrame\n     */\n    bottomStackframeRequiresPhantomFrame: createLeaf(\n      [evm.transaction.startingContext],\n      contextRequiresPhantomStackframes\n    )\n  },\n\n  /**\n   * solidity.current\n   */\n  current: {\n    /**\n     * solidity.current.sourceIds\n     * like solidity.current.sources, but just has the IDs, not the sources\n     */\n    sourceIds: createLeaf(\n      [\"/info/sources\", evm.current.context],\n      (sources, context) => {\n        if (!context) {\n          debug(\"no context\");\n          return null; //no tx loaded, return null\n        }\n\n        const { compilationId, context: contextHash } = context;\n        debug(\"compilationId: %o\", compilationId);\n\n        let userSources = [];\n        let internalSources = [];\n\n        if (compilationId && sources.byCompilationId[compilationId]) {\n          userSources = sources.byCompilationId[compilationId].byIndex;\n        }\n\n        if (sources.byContext[contextHash]) {\n          internalSources = sources.byContext[contextHash].byIndex;\n        }\n\n        //we assign to [] rather than {} because we want the result to be an array\n        return Object.assign([], userSources, internalSources);\n      }\n    ),\n\n    /**\n     * solidity.current.sources\n     * This takes the place of the old solidity.info.sources,\n     * returning only the sources for the current compilation and context.\n     */\n    sources: createLeaf(\n      [\"/views/sources\", \"/current/sourceIds\"],\n      (allSources, ids) => (ids ? ids.map(id => allSources[id]) : null)\n    ),\n\n    /**\n     * solidity.current.sourceMap\n     */\n    sourceMap: createLeaf(\n      [evm.current.context],\n\n      context => (context ? context.sourceMap : null) //null when no tx loaded\n    ),\n\n    /**\n     * solidity.current.humanReadableSourceMap\n     */\n    humanReadableSourceMap: createLeaf([\"./sourceMap\"], sourceMap =>\n      sourceMap ? SourceMapUtils.getHumanReadableSourceMap(sourceMap) : null\n    ),\n\n    /**\n     * solidity.current.functionDepthStack\n     */\n    functionDepthStack: state => state.solidity.proc.functionDepthStack,\n\n    /**\n     * solidity.current.nextFrameIsPhantom\n     */\n    nextFrameIsPhantom: state => state.solidity.proc.nextFrameIsPhantom,\n\n    /**\n     * solidity.current.functionDepth\n     */\n    functionDepth: createLeaf(\n      [\"./functionDepthStack\"],\n      stack => stack[stack.length - 1]\n    ),\n\n    /**\n     * solidity.current.callRequiresPhantomFrame\n     */\n    callRequiresPhantomFrame: createLeaf(\n      [evm.current.context],\n      contextRequiresPhantomStackframes\n    ),\n\n    /**\n     * solidity.current.instructions\n     */\n    instructions: createLeaf(\n      [\"./sources\", evm.current.context, \"./humanReadableSourceMap\"],\n\n      (sources, context, sourceMap) => {\n        if (!context) {\n          return [];\n        }\n\n        debug(\"sources before processing: %O\", sources);\n        return SourceMapUtils.getProcessedInstructionsForBinary(\n          (sources || []).map(source => (source ? source.source : undefined)),\n          context.binary,\n          sourceMap\n        );\n      }\n    ),\n\n    /**\n     * solidity.current.instructionAtProgramCounter\n     */\n    instructionAtProgramCounter: createLeaf(\n      [\"./instructions\"],\n\n      instructions =>\n        Object.assign(\n          {},\n          ...instructions.map(instruction => ({\n            [instruction.pc]: instruction\n          }))\n        )\n    ),\n\n    ...createMultistepSelectors(evm.current.step),\n\n    /**\n     * solidity.current.isSourceRangeFinalRaw\n     * the old version; doesn't account for internal-source problems\n     */\n    isSourceRangeFinalRaw: createLeaf(\n      [\n        \"./instructionAtProgramCounter\",\n        evm.current.step.programCounter,\n        evm.next.step.programCounter,\n        evm.current.step.isContextChange\n      ],\n\n      (map, current, next, changesContext) => {\n        if (changesContext || !map[next]) {\n          return true;\n        }\n\n        current = map[current];\n        next = map[next];\n\n        return (\n          current.start != next.start ||\n          current.length != next.length ||\n          current.file != next.file\n        );\n      }\n    ),\n\n    /**\n     * solidity.current.isSourceRangeFinal\n     * if there's no context change, then don't return final\n     * on jumping from a user source to an internal source\n     */\n    isSourceRangeFinal: createLeaf(\n      [\n        \"./isSourceRangeFinalRaw\",\n        \"./source\",\n        \"/next/source\",\n        evm.current.step.isContextChange\n      ],\n\n      (isFinal, currentSource, nextSource, changesContext) => {\n        return (\n          changesContext ||\n          (isFinal && (currentSource.internal || !nextSource.internal))\n        );\n      }\n    ),\n\n    /*\n     * solidity.current.functionsByProgramCounter\n     */\n    functionsByProgramCounter: createLeaf(\n      [\n        \"./instructions\",\n        \"./sources\",\n        \"./overlapFunctions\",\n        evm.current.context\n      ],\n      (instructions, sources, functions, { compilationId }) =>\n        //note: we can skip an explicit null check on sources here because\n        //if sources is null then instructions = [] so the problematic map\n        //never occurs\n        SourceMapUtils.getFunctionsByProgramCounter(\n          instructions,\n          sources.map(({ ast }) => ast),\n          functions,\n          compilationId\n        )\n    ),\n\n    /**\n     * solidity.current.isMultiline\n     */\n    isMultiline: createLeaf(\n      [\"./sourceRange\"],\n\n      ({ lines }) => lines.start.line != lines.end.line\n    ),\n\n    /**\n     * solidity.current.willJump\n     */\n    willJump: createLeaf([evm.current.step.isJump], isJump => isJump),\n\n    /**\n     * solidity.current.jumpDirection\n     */\n    jumpDirection: createLeaf([\"./instruction\"], (i = {}) => i.jump || \"-\"),\n\n    /**\n     * solidity.current.willCall\n     * note: includes creations, does *not* include instareturns\n     */\n    willCall: createLeaf(\n      [\n        evm.current.step.isCall,\n        evm.current.step.isCreate,\n        evm.current.step.isInstantCallOrCreate\n      ],\n      (isCall, isCreate, isInstant) => (isCall || isCreate) && !isInstant\n    ),\n\n    /**\n     * solidity.current.willReturn\n     *\n     * covers both normal returns & failures\n     */\n    willReturn: createLeaf(\n      [evm.current.step.isHalting],\n      isHalting => isHalting\n    ),\n\n    /**\n     * solidity.current.nextUserStep\n     * returns the next trace step after this one which is sourcemapped to\n     * a user source (not -1 or an internal source)\n     * HACK: this assumes we're not about to change context! don't use this if\n     * we are!\n     * ALSO, this may return undefined, so be prepared for that\n     */\n    nextUserStep: createLeaf(\n      [\n        \"./instructionAtProgramCounter\",\n        \"/current/sources\",\n        trace.steps,\n        trace.index\n      ],\n      (map, sources, steps, index) =>\n        steps\n          .slice(index + 1)\n          .find(\n            ({ pc }) =>\n              map[pc] &&\n              map[pc].file !== -1 &&\n              !(sources[map[pc].file] && sources[map[pc].file].internal)\n          )\n    ),\n\n    /**\n     * solidity.current.overlapFunctions\n     * like solidity.views.overlapFunctions, but just returns\n     * an array appropriate to the current context (like solidity.current.sources)\n     */\n    overlapFunctions: createLeaf(\n      [\"/views/overlapFunctions\", \"/current/sourceIds\"],\n      (functions, ids) => (ids ? ids.map(id => functions[id]) : null)\n    )\n  },\n\n  /**\n   * solidity.next\n   * HACK WARNING: do not use these selectors when the current instruction is a\n   * context change! (evm call or evm return)\n   */\n  next: createMultistepSelectors(evm.next.step),\n\n  /**\n   * solidity.views\n   */\n  views: {\n    /**\n     * solidity.views.sources\n     * just the byId part of solidity.info.sources\n     * (effectively flattening them)\n     */\n    sources: createLeaf([\"/info/sources\"], sources => sources.byId),\n\n    /**\n     * solidity.views.overlapFunctions\n     * organized by source ID\n     */\n    overlapFunctions: createLeaf([\"/views/sources\"], sources =>\n      Object.assign(\n        {},\n        ...Object.entries(sources).map(([id, { ast }]) => ({\n          [id]: SourceMapUtils.makeOverlapFunction(ast)\n        }))\n      )\n    )\n  }\n});\n\nexport default solidity;\n","module.exports = require(\"babel-runtime/core-js/object/entries\");","module.exports = require(\"babel-runtime/core-js/object/assign\");","export const SAVE_STEPS = \"TRACE_SAVE_STEPS\";\nexport function saveSteps(steps) {\n  return {\n    type: SAVE_STEPS,\n    steps\n  };\n}\n\nexport const NEXT = \"TRACE_NEXT\";\nexport function next() {\n  return { type: NEXT };\n}\n\nexport const TICK = \"TRACE_TICK\";\nexport function tick() {\n  return { type: TICK };\n}\n\nexport const TOCK = \"TRACE_TOCK\";\nexport function tock() {\n  return { type: TOCK };\n}\n\nexport const END_OF_TRACE = \"TRACE_EOT\";\nexport function endTrace() {\n  return { type: END_OF_TRACE };\n}\n\nexport const RESET = \"TRACE_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const UNLOAD_TRANSACTION = \"TRACE_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return { type: UNLOAD_TRANSACTION };\n}\n\nexport const BACKTICK = \"TRACE_BACKTICK\";\nexport function backtick() {\n  return { type: BACKTICK };\n}\n\nexport const SET_SUBMODULE_COUNT = \"TRACE_SET_SUBMODULE_COUNT\";\nexport function setSubmoduleCount(count) {\n  return { type: SET_SUBMODULE_COUNT, count };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:trace:sagas\");\n\nimport {take, takeEvery, put, select} from \"redux-saga/effects\";\nimport {\n  prefixName,\n  isCallMnemonic,\n  isCreateMnemonic,\n  isSelfDestructMnemonic\n} from \"lib/helpers\";\n\nimport * as Codec from \"@truffle/codec\";\n\nimport * as actions from \"../actions\";\n\nimport trace from \"../selectors\";\n\nexport function* setSubmoduleCount(count) {\n  yield put(actions.setSubmoduleCount(count));\n}\n\nexport function* addSubmoduleToCount(increment = 1) {\n  let count = yield select(trace.application.submoduleCount);\n  yield put(actions.setSubmoduleCount(count + increment));\n}\n\nexport function* advance() {\n  yield put(actions.next());\n\n  debug(\"TOCK to take\");\n  yield take([actions.TOCK, actions.END_OF_TRACE]);\n  debug(\"TOCK taken\");\n}\n\nfunction* next() {\n  let remaining = yield select(trace.stepsRemaining);\n  debug(\"remaining: %o\", remaining);\n  let steps = yield select(trace.steps);\n  debug(\"total steps: %o\", steps.length);\n  let waitingForSubmodules = 0;\n\n  if (remaining > 0) {\n    debug(\"putting TICK\");\n    // updates state for current step\n    waitingForSubmodules = yield select(trace.application.submoduleCount);\n    yield put(actions.tick());\n    debug(\"put TICK\");\n\n    //wait for all backticks before continuing\n    while (waitingForSubmodules > 0) {\n      yield take(actions.BACKTICK);\n      debug(\"got BACKTICK\");\n      waitingForSubmodules--;\n    }\n\n    remaining--; // local update, just for convenience\n  }\n\n  if (remaining) {\n    debug(\"putting TOCK\");\n    // updates step to next step in trace\n    yield put(actions.tock());\n    debug(\"put TOCK\");\n  } else {\n    debug(\"putting END_OF_TRACE\");\n    yield put(actions.endTrace());\n    debug(\"put END_OF_TRACE\");\n  }\n}\n\nexport function* signalTickSagaCompletion() {\n  yield put(actions.backtick());\n}\n\nexport function* processTrace(steps) {\n  yield put(actions.saveSteps(steps));\n\n  let callAddresses = new Set();\n  let selfDestructAddresses = new Set();\n  let createdBinaries = {};\n\n  for (let index = 0; index < steps.length; index++) {\n    const {op, depth, stack, memory} = steps[index];\n    if (isCallMnemonic(op)) {\n      callAddresses.add(Codec.Evm.Utils.toAddress(stack[stack.length - 2]));\n    } else if (isCreateMnemonic(op)) {\n      const returnStep = steps\n        .slice(index + 1)\n        .find(step => step.depth === depth);\n      if (returnStep) {\n        const returnStack = returnStep.stack;\n        const address = Codec.Evm.Utils.toAddress(\n          returnStack[returnStack.length - 1]\n        );\n        if (address !== Codec.Evm.Utils.ZERO_ADDRESS) {\n          //now: extract the created binary.\n          //note we multiply by 2 because we're dealing with hex strings.\n          const offset = parseInt(stack[stack.length - 2], 16) * 2;\n          const length = parseInt(stack[stack.length - 3], 16) * 2;\n          const binary =\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\");\n          createdBinaries[address] = binary;\n          //warning: this is a deliberately crude method!\n          //it may warrant replacement later.\n          //(but it should be good enough for most purposes)\n        }\n      }\n    } else if (isSelfDestructMnemonic(op)) {\n      selfDestructAddresses.add(\n        Codec.Evm.Utils.toAddress(stack[stack.length - 1])\n      );\n    }\n  }\n\n  return {\n    calls: [...callAddresses],\n    selfdestructs: [...selfDestructAddresses],\n    creations: createdBinaries\n  };\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* saga() {\n  yield takeEvery(actions.NEXT, next);\n}\n\nexport default prefixName(\"trace\", saga);\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport jsonpointer from \"json-pointer\";\nimport merge from \"lodash.merge\";\nimport semver from \"semver\";\n\nimport { stableKeccak256, makePath } from \"lib/helpers\";\n\nimport trace from \"lib/trace/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport solidity from \"lib/solidity/selectors\";\nimport stacktrace from \"lib/stacktrace/selectors\";\n\nimport * as Codec from \"@truffle/codec\";\n\n/**\n * @private\n */\nconst identity = x => x;\n\nfunction solidityVersionHasNoNow(compiler) {\n  return (\n    compiler &&\n    compiler.name === \"solc\" &&\n    //want to include prerelease versions of 0.7.0\n    semver.satisfies(compiler.version, \"~0.7 || >=0.7.0\", {\n      includePrerelease: true\n    })\n  );\n}\n\nfunction findAncestorOfType(node, types, scopes, pointer = null, root = null) {\n  //note: you may want to include \"SourceUnit\" as a fallback type when using\n  //this function for convenience.\n  //you only need to pass pointer and root if you want this function to work\n  //from Yul.  Otherwise you can omit those and you'll get null if you happen\n  //to be in Yul.\n  while (node && !types.includes(node.nodeType)) {\n    if (node.id !== undefined) {\n      node = scopes[scopes[node.id].parentId].definition;\n    } else {\n      if (pointer === null || root === null || pointer === \"\") {\n        //if we're trying to go up from the root but are still in Yul,\n        //or if we weren't given pointer and root at all,\n        //admit failure and return null\n        return null;\n      }\n      pointer = pointer.replace(/\\/[^/]*$/, \"\"); //chop off end\n      node = jsonpointer.get(root, pointer);\n    }\n  }\n  return node;\n}\n\n//given a modifier invocation (or inheritance specifier) node,\n//get the node for the actual modifier (or constructor)\nfunction modifierForInvocation(invocation, scopes) {\n  let rawId; //raw referencedDeclaration ID extracted from the AST.\n  //if it's a modifier this is what we want, but if it's base\n  //constructor, we'll get the contract instead, and need to find its\n  //constructor.\n  switch (invocation.nodeType) {\n    case \"ModifierInvocation\":\n      rawId = invocation.modifierName.referencedDeclaration;\n      break;\n    case \"InheritanceSpecifier\":\n      rawId = invocation.baseName.referencedDeclaration;\n      break;\n    default:\n      debug(\"bad invocation node\");\n  }\n  let rawNode = scopes[rawId].definition;\n  switch (rawNode.nodeType) {\n    case \"ModifierDefinition\":\n      return rawNode;\n    case \"ContractDefinition\":\n      return rawNode.nodes.find(\n        node =>\n          node.nodeType === \"FunctionDefinition\" &&\n          Codec.Ast.Utils.functionKind(node) === \"constructor\"\n      );\n    default:\n      //we should never hit this case\n      return undefined;\n  }\n}\n\n//see data.views.contexts for an explanation\nfunction debuggerContextToDecoderContext(context) {\n  let {\n    context: contextHash,\n    contractName,\n    binary,\n    contractId,\n    contractKind,\n    isConstructor,\n    abi,\n    payable,\n    compiler,\n    compilationId\n  } = context;\n  return {\n    context: contextHash,\n    contractName,\n    binary,\n    contractId,\n    contractKind,\n    isConstructor,\n    abi: Codec.AbiData.Utils.computeSelectors(abi),\n    fallbackAbi: {\n      fallback: (abi || []).find(item => item.type === \"fallback\") || null,\n      receive: (abi || []).find(item => item.type === \"receive\") || null\n    },\n    payable,\n    compiler,\n    compilationId\n  };\n}\n\n//spoofed definitions we'll need\n//we'll give them id -1 to indicate that they're spoofed\n\nexport const NOW_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"now\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_uint256\",\n    typeString: \"uint256\"\n  }\n};\n\nexport const MSG_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"msg\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_message\",\n    typeString: \"msg\"\n  }\n};\n\nexport const TX_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"tx\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_transaction\",\n    typeString: \"tx\"\n  }\n};\n\nexport const BLOCK_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"block\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_block\",\n    typeString: \"block\"\n  }\n};\n\nfunction spoofThisDefinition(contractName, contractId, contractKind) {\n  let formattedName = contractName.replace(/\\$/g, \"$$\".repeat(3));\n  //note that string.replace treats $'s specially in the replacement string;\n  //we want 3 $'s for each $ in the input, so we need to put *6* $'s in the\n  //replacement string\n  return {\n    id: -1,\n    src: \"0:0:-1\",\n    name: \"this\",\n    nodeType: \"VariableDeclaration\",\n    typeDescriptions: {\n      typeIdentifier: \"t_contract$_\" + formattedName + \"_$\" + contractId,\n      typeString: contractKind + \" \" + contractName\n    }\n  };\n}\n\nconst data = createSelectorTree({\n  state: state => state.data,\n\n  /**\n   * data.views\n   */\n  views: {\n    /*\n     * data.views.atLastInstructionForSourceRange\n     */\n    atLastInstructionForSourceRange: createLeaf(\n      [solidity.current.isSourceRangeFinal],\n      final => final\n    ),\n\n    /**\n     * data.views.scopes (namespace)\n     */\n    scopes: {\n      /*\n       * data.views.scopes (selector)\n       * the raw scopes data, just with intermediate\n       * layers cut out\n       * (no inheritance, no inlining)\n       */\n      _: createLeaf([\"/info/scopes\"], scopes =>\n        Object.assign(\n          {},\n          ...Object.entries(scopes).map(([sourceId, { byAstRef: nodes }]) => ({\n            [sourceId]: nodes\n          }))\n        )\n      ),\n\n      /**\n       * data.views.scopes.inlined\n       * inlines, but still no inheritance data\n       */\n      inlined: createLeaf(\n        [\"./_\", solidity.views.sources],\n\n        (scopes, sources) =>\n          Object.assign(\n            {},\n            ...Object.entries(scopes).map(([sourceId, nodes]) => ({\n              [sourceId]: Object.assign(\n                {},\n                ...Object.entries(nodes).map(([astRef, scope]) => ({\n                  [astRef]: {\n                    ...scope,\n                    definition: jsonpointer.get(\n                      sources[scope.sourceId].ast,\n                      scope.pointer\n                    )\n                  }\n                }))\n              )\n            }))\n          )\n      )\n    },\n\n    /**\n     * data.views.userDefinedTypes\n     * user-defined types for passing to the decoder\n     * NOTE: *not* grouped by compilation or anything, this is flat\n     */\n    userDefinedTypes: createLeaf(\n      [\n        \"/info/userDefinedTypes\",\n        \"./referenceDeclarations\",\n        \"./scopes/inlined\",\n        solidity.views.sources\n      ],\n      (userDefinedTypes, referenceDeclarations, scopes, sources) =>\n        Object.assign(\n          {},\n          ...userDefinedTypes.map(({ sourceId, id }) => {\n            debug(\"id: %d\", id);\n            debug(\"sourceId: %s\", sourceId);\n            debug(\"scope: %o\", scopes[sourceId][id]);\n            const node = scopes[sourceId][id].definition;\n            debug(\"node: %o\", node);\n            const { compilationId, compiler, internal } = sources[sourceId];\n            debug(\"compilationId: %s\", compilationId);\n            if (internal) {\n              return {}; //just to be sure, we assume generated sources don't define types\n            }\n            const type = Codec.Ast.Import.definitionToStoredType(\n              node,\n              compilationId,\n              compiler,\n              referenceDeclarations[compilationId]\n            );\n            debug(\"type: %o\", type);\n            return { [type.id]: type };\n          })\n        )\n    ),\n\n    /**\n     * data.views.contractAllocationInfo\n     */\n    contractAllocationInfo: createLeaf(\n      [\n        \"/info/userDefinedTypes\",\n        \"/views/scopes/inlined\",\n        solidity.views.sources,\n        evm.info.contexts\n      ],\n      (userDefinedTypes, scopes, sources, contexts) =>\n        Object.values(userDefinedTypes)\n          .filter(\n            ({ sourceId, id }) =>\n              !sources[sourceId].internal && //again, assuming internal sources don't define contracts\n              scopes[sourceId][id].definition.nodeType === \"ContractDefinition\"\n          )\n          .map(({ sourceId, id }) => {\n            debug(\"id: %O\", id);\n            const compilationId = sources[sourceId].compilationId;\n            debug(\"compilationId: %O\", compilationId);\n            let deployedContext = Object.values(contexts).find(\n              context =>\n                !context.isConstructor &&\n                context.compilationId === compilationId &&\n                context.contractId === id\n            );\n            let constructorContext = Object.values(contexts).find(\n              context =>\n                context.isConstructor &&\n                context.compilationId === compilationId &&\n                context.contractId === id\n            );\n            let immutableReferences = deployedContext\n              ? deployedContext.immutableReferences\n              : undefined;\n            return {\n              contractNode: scopes[sourceId][id].definition,\n              compilationId,\n              immutableReferences,\n              //we don't just use deployedContext to get compiler because it might not exist!\n              compiler: sources[sourceId].compiler,\n              //the following three are only needed for decoding return values\n              abi: (deployedContext || {}).abi,\n              deployedContext,\n              constructorContext\n            };\n          })\n    ),\n\n    /**\n     * data.views.referenceDeclarations\n     * grouped by compilation because that's how codec wants it;\n     * for simplicity, we will assume that generated sources never define types!\n     */\n    referenceDeclarations: createLeaf(\n      [\n        \"./scopes/inlined\",\n        \"/info/userDefinedTypes\",\n        \"/info/taggedOutputs\",\n        solidity.views.sources\n      ],\n      (scopes, userDefinedTypes, taggedOutputs, sources) =>\n        merge(\n          {},\n          ...userDefinedTypes.concat(taggedOutputs).map(({ id, sourceId }) => {\n            const source = sources[sourceId];\n            return source.internal\n              ? {} //exclude these\n              : {\n                  [source.compilationId]: {\n                    [id]: scopes[sourceId][id].definition\n                  }\n                };\n          })\n        )\n    ),\n\n    /**\n     * data.views.mappingKeys\n     */\n    mappingKeys: createLeaf(\n      [\"/proc/mappedPaths\", \"/current/address\"],\n      (mappedPaths, address) =>\n        []\n          .concat(\n            ...Object.values(\n              (mappedPaths.byAddress[address] || { byType: {} }).byType\n            ).map(({ bySlotAddress }) => Object.values(bySlotAddress))\n          )\n          .filter(slot => slot.key !== undefined)\n    ),\n\n    /*\n     * data.views.blockNumber\n     * returns block number as string\n     */\n    blockNumber: createLeaf([evm.transaction.globals.block], block =>\n      block.number.toString()\n    ),\n\n    /*\n     * data.views.instances\n     * same as evm.current.codex.instances, but we just map address => binary,\n     * we don't bother with context, and also the code is a Uint8Array\n     */\n    instances: createLeaf([evm.current.codex.instances], instances =>\n      Object.assign(\n        {},\n        ...Object.entries(instances).map(([address, { binary }]) => ({\n          [address]: Codec.Conversion.toBytes(binary)\n        }))\n      )\n    ),\n\n    /*\n     * data.views.contexts\n     * same as evm.info.contexts, but:\n     * 0. we only include non-constructor contexts\n     * 1. we strip out sourceMap and primarySource\n     * 2. we alter abi in two ways:\n     * 2a. we strip out everything but functions\n     * 2b. abi is now an object, not an array, and indexed by these signatures\n     */\n    contexts: createLeaf([evm.info.contexts], contexts =>\n      Object.assign(\n        {},\n        ...Object.values(contexts)\n          .filter(context => !context.isConstructor)\n          .map(context => ({\n            [context.contractId]: debuggerContextToDecoderContext(context)\n          }))\n      )\n    )\n  },\n\n  /**\n   * data.info\n   */\n  info: {\n    /**\n     * data.info.scopes\n     */\n    scopes: createLeaf([\"/state\"], state => state.info.scopes.bySourceId),\n\n    /*\n     * data.info.allocations\n     */\n    allocations: {\n      /*\n       * data.info.allocations.storage\n       */\n      storage: createLeaf([\"/state\"], state => state.info.allocations.storage),\n\n      /**\n       * data.info.allocations.state\n       */\n      state: createLeaf([\"/state\"], state => state.info.allocations.state),\n\n      /*\n       * data.info.allocations.memory\n       */\n      memory: createLeaf([\"/state\"], state => state.info.allocations.memory),\n\n      /*\n       * data.info.allocations.abi\n       */\n      abi: createLeaf([\"/state\"], state => state.info.allocations.abi),\n\n      /*\n       * data.info.allocations.calldata\n       */\n      calldata: createLeaf([\"/state\"], state => state.info.allocations.calldata),\n\n      /*\n       * data.info.allocations.returndata\n       */\n      returndata: createLeaf([\"/state\"], state => state.info.allocations.returndata)\n    },\n\n    /**\n     * data.info.userDefinedTypes\n     */\n    userDefinedTypes: createLeaf(\n      [\"/state\"],\n      state => state.info.userDefinedTypes\n    ),\n\n    /**\n     * data.info.taggedOutputs\n     * \"Tagged outputs\" means user-defined things that are output by a contract\n     * (not input to a contract), and which are distinguished by (potentially\n     * ambiguous) selectors.  So, events and custom errors are tagged outputs.  \n     * Function arguments are not tagged outputs (they're not outputs).\n     * Return values are not tagged outputs (they don't have a selector).\n     * Built-in errors (Error(string) and Panic(uint))... OK I guess those could\n     * be considered tagged outputs, but we're only looking at user-defined ones\n     * here.\n     */\n    taggedOutputs: createLeaf(\n      [\"/state\"],\n      state => state.info.taggedOutputs\n    )\n  },\n\n  /**\n   * data.proc\n   */\n  proc: {\n    /**\n     * data.proc.assignments\n     */\n    assignments: createLeaf([\"/state\"], state => state.proc.assignments.byId),\n\n    /*\n     * data.proc.mappedPaths\n     */\n    mappedPaths: createLeaf([\"/state\"], state => state.proc.mappedPaths)\n  },\n\n  /**\n   * data.current\n   */\n  current: {\n    /**\n     * data.current.state\n     */\n    state: {\n      /**\n       * data.current.state.stack\n       */\n      stack: createLeaf(\n        [evm.current.state.stack],\n\n        words => (words || []).map(word => Codec.Conversion.toBytes(word))\n      ),\n\n      /**\n       * data.current.state.memory\n       */\n      memory: createLeaf(\n        [evm.current.state.memory],\n\n        words => Codec.Conversion.toBytes(words.join(\"\"))\n      ),\n\n      /**\n       * data.current.state.code\n       */\n      code: createLeaf([evm.current.context], ({ binary }) =>\n        Codec.Conversion.toBytes(binary)\n      ),\n\n      /**\n       * data.current.state.calldata\n       */\n      calldata: createLeaf(\n        [evm.current.call],\n\n        ({ data }) => Codec.Conversion.toBytes(data)\n      ),\n\n      /**\n       * data.current.state.storage\n       */\n      storage: createLeaf(\n        [evm.current.codex.storage],\n\n        mapping =>\n          Object.assign(\n            {},\n            ...Object.entries(mapping).map(([address, word]) => ({\n              [`0x${address}`]: Codec.Conversion.toBytes(word)\n            }))\n          )\n      ),\n\n      /*\n       * data.current.state.specials\n       * I've named these after the solidity variables they correspond to,\n       * which are *mostly* the same as the corresponding EVM opcodes\n       * (FWIW: this = ADDRESS, sender = CALLER, value = CALLVALUE)\n       */\n      specials: createLeaf(\n        [\"/current/address\", evm.current.call, evm.transaction.globals],\n        (address, { sender, value }, { tx, block }) => ({\n          this: Codec.Conversion.toBytes(address),\n\n          sender: Codec.Conversion.toBytes(sender),\n\n          value: Codec.Conversion.toBytes(value),\n\n          //let's crack open that tx and block!\n          ...Object.assign(\n            {},\n            ...Object.entries(tx).map(([variable, value]) => ({\n              [variable]: Codec.Conversion.toBytes(value)\n            }))\n          ),\n\n          ...Object.assign(\n            {},\n            ...Object.entries(block).map(([variable, value]) => ({\n              [variable]: Codec.Conversion.toBytes(value)\n            }))\n          )\n        })\n      )\n    },\n\n    /**\n     * data.current.compilationId\n     */\n    compilationId: createLeaf(\n      [evm.current.context],\n      ({ compilationId }) => compilationId\n    ),\n\n    /**\n     * data.current.sourceIndex\n     */\n    sourceIndex: createLeaf([solidity.current.source], ({ index }) => index),\n\n    /**\n     * data.current.language\n     */\n    language: createLeaf([solidity.current.source], ({ language }) => language),\n\n    /**\n     * data.current.internalSourceFor\n     * returns null if in a user source\n     */\n    internalSourceFor: createLeaf(\n      [solidity.current.source],\n      ({ internalFor }) => internalFor || null\n    ),\n\n    /**\n     * data.current.root\n     */\n    root: createLeaf([solidity.current.source], ({ ast }) => ast),\n\n    /**\n     * data.current.scopes (namespace)\n     */\n    scopes: {\n      /**\n       * data.current.scopes (selector)\n       * Replacement for the old data.info.scopes;\n       * that one now contains multi-compilation/context info, this\n       * one contains only the current compilation/context\n       */\n      _: createLeaf([\"./raw\", \"./inlined/raw\"], (scopes, inlined) =>\n        Object.assign(\n          {},\n          ...Object.entries(scopes).map(([id, scope]) => {\n            let definition = inlined[id].definition;\n            if (definition.nodeType === \"ContractDefinition\") {\n              //contract definition case: process inheritance\n              debug(\"contract id %d\", id);\n              let newScope = { ...scope };\n              //note that Solidity gives us the linearization in order from most\n              //derived to most base, but we want most base to most derived;\n              //annoyingly, reverse() is in-place, so we clone with slice() first\n              const linearizedBaseContractsFromBase = definition.linearizedBaseContracts\n                .slice()\n                .reverse();\n              linearizedBaseContractsFromBase.pop(); //remove the last element, i.e.,\n              //the contract itself, because we want to treat that one specially\n              //now, we put it all together\n              newScope.variables = []\n                .concat(\n                  //concatenate the variables lists from the base classes\n                  ...linearizedBaseContractsFromBase.map(\n                    contractId => scopes[contractId].variables || []\n                    //we need the || [] because contracts with no state variables\n                    //have variables undefined rather than empty like you'd expect\n                  )\n                )\n                .filter(\n                  variable =>\n                    inlined[variable.astRef].definition.visibility !== \"private\"\n                  //filter out private variables from the base classes\n                )\n                //add in the variables for the contract itself -- note that here\n                //private variables are not filtered out!\n                .concat(scopes[id].variables || [])\n                .filter(variable => {\n                  //HACK: let's filter out those constants we don't know\n                  //how to read.  they'll just clutter things up.\n                  debug(\"variable %O\", variable);\n                  const definition = inlined[variable.astRef].definition;\n                  return (\n                    !(\n                      definition.constant ||\n                      definition.mutability === \"constant\"\n                    ) || Codec.Ast.Utils.isSimpleConstant(definition.value)\n                  );\n                });\n              return { [id]: newScope };\n            } else if (definition.nodeType === \"SourceUnit\") {\n              //source unit case: process imports\n              let newScope = { ...scope };\n              //in this case, handling imports in some sort of tree fashion would\n              //be too much work.  we'll do this the easy way: by checking exported\n              //symbols for constants.\n              newScope.variables = Object.values(definition.exportedSymbols)\n                .map(\n                  array => array[0] //I don't know why these are arrays...?\n                )\n                .filter(astRef => {\n                  //restrict to variables, not other exported symbols!\n                  const definition = inlined[astRef].definition;\n                  return (\n                    definition.nodeType === \"VariableDeclaration\" &&\n                    (definition.constant ||\n                      definition.mutability === \"constant\") &&\n                    //HACK: we'll also again filter out constants we don't know how\n                    //to read\n                    Codec.Ast.Utils.isSimpleConstant(definition.value)\n                  );\n                })\n                .map(astRef => ({\n                  //we'll have to reconstruct the rest from just the astRef\n                  astRef,\n                  name: inlined[astRef].definition.name,\n                  sourceId: inlined[astRef].sourceId\n                }));\n              return { [id]: newScope };\n            } else {\n              //default case, nothing to process\n              return { [id]: scope };\n            }\n          })\n        )\n      ),\n\n      /**\n       * data.current.scopes.raw\n       * Current scopes, with inheritance not handled and no inlining\n       */\n      raw: createLeaf(\n        [\"/views/scopes\", solidity.current.sourceIds],\n        (scopes, sourceIds) =>\n          Object.assign({}, ...sourceIds.map(sourceId => scopes[sourceId]))\n      ),\n\n      /**\n       * data.current.scopes.inlined (namespace)\n       */\n      inlined: {\n        /**\n         * data.current.scopes.inlined (selector)\n         * Replacement for the old data.views.scopes.inlined;\n         * that one now contains multi-compilation info, this\n         * one contains only the current compilation/context\n         */\n        _: createLeaf([\"./raw\", \"../_\"], (inlined, scopes) =>\n          Object.assign(\n            {},\n            ...Object.entries(inlined).map(([astRef, info]) => ({\n              [astRef]: {\n                ...info,\n                variables: scopes[astRef].variables\n              }\n            }))\n          )\n        ),\n\n        /**\n         * data.current.scopes.inlined.raw\n         * inlines definitions but does not account for inheritance\n         */\n        raw: createLeaf(\n          [\"/views/scopes/inlined\", solidity.current.sourceIds],\n          (scopes, sourceIds) =>\n            Object.assign({}, ...sourceIds.map(sourceId => scopes[sourceId]))\n        )\n      }\n    },\n\n    /**\n     * data.current.referenceDeclarations\n     */\n    referenceDeclarations: createLeaf(\n      [\"/views/referenceDeclarations\", \"./compilationId\"],\n      (scopes, compilationId) => scopes[compilationId]\n    ),\n\n    /**\n     * data.current.allocations\n     */\n    allocations: {\n      /**\n       * data.current.allocations.state\n       * Same as data.info.allocations.state, but uses the old allocation\n       * format (more convenient for debugger) where members are stored by ID\n       * in an object instead of by index in an array; also only holds things\n       * from the current compilation\n       * ALSO: if we're in a constructor, replaces all code pointers by appropriate\n       * memory pointers :)\n       */\n      state: createLeaf(\n        [\"/info/allocations/state\", \"../compilationId\", evm.current.context],\n        (allAllocations, compilationId, { isConstructor }) => {\n          debug(\"compilationId: %s\", compilationId);\n          debug(\"allAllocations: %o\", allAllocations);\n          const allocations = compilationId\n            ? allAllocations[compilationId]\n            : {};\n          //several-deep clone\n          let transformedAllocations = Object.assign(\n            {},\n            ...Object.entries(allocations).map(([id, allocation]) => ({\n              [id]: {\n                members: allocation.members.map(member => ({ ...member }))\n              }\n            }))\n          );\n          //if we're not in a constructor, we don't need to actually transform it.\n          //if we are...\n          if (isConstructor) {\n            //...we must transform code pointers!\n            for (const id in transformedAllocations) {\n              const allocation = transformedAllocations[id];\n              //here, the magic number 4 is the number of reserved memory slots\n              //at the start of memory.  immutables go immediately afterward.\n              let start = 4 * Codec.Evm.Utils.WORD_SIZE;\n              for (const member of allocation.members) {\n                //if it's not a code pointer, leave it alone\n                if (\n                  member.pointer.location === \"code\" ||\n                  member.pointer.location === \"nowhere\"\n                ) {\n                  //if it is, transform it\n                  member.pointer = {\n                    location: \"memory\",\n                    start,\n                    length: Codec.Evm.Utils.WORD_SIZE\n                  };\n                  start += Codec.Evm.Utils.WORD_SIZE;\n                }\n              }\n            }\n          }\n          //having now transformed code pointers if needed,\n          //we now index by ID\n          return Object.assign(\n            {},\n            ...Object.entries(transformedAllocations).map(\n              ([id, allocation]) => ({\n                [id]: {\n                  members: Object.assign(\n                    {},\n                    ...allocation.members.map(memberAllocation => ({\n                      [memberAllocation.definition.id]: memberAllocation\n                    }))\n                  )\n                }\n              })\n            )\n          );\n        }\n      )\n    },\n\n    /**\n     * data.current.compiler\n     */\n    compiler: createLeaf([evm.current.context], ({ compiler }) => compiler),\n\n    /**\n     * data.current.bareLetsInYulAreHit\n     */\n    bareLetsInYulAreHit: createLeaf(\n      [\"./compiler\"],\n      compiler =>\n        compiler !== undefined && //if no compiler we'll assume the old way I guess??\n        compiler.name === \"solc\" &&\n        semver.satisfies(compiler.version, \">=0.6.8\", {\n          includePrerelease: true\n        })\n    ),\n\n    /**\n     * data.current.node\n     */\n    node: createLeaf([solidity.current.node], identity),\n\n    /**\n     * data.current.pointer\n     */\n    pointer: createLeaf([solidity.current.pointer], identity),\n\n    /**\n     * data.current.astRef\n     * returns null when not in a mapped source\n     */\n    astRef: createLeaf(\n      [solidity.current.node, solidity.current.pointer, \"./sourceIndex\"],\n      (node, pointer, sourceIndex) =>\n        node\n          ? node.id !== undefined\n            ? node.id\n            : makePath(sourceIndex, pointer)\n          : null\n    ),\n\n    /**\n     * data.current.scope\n     * old alias for data.current.node (deprecated)\n     */\n    scope: createLeaf([\"./node\"], identity),\n\n    /**\n     * data.current.contract\n     * warning: may return null or similar, even though SourceUnit is included\n     * as fallback\n     */\n    contract: createLeaf(\n      [\"./node\", \"./scopes/inlined\", \"./pointer\", \"./root\"],\n      (node, scopes, pointer, root) => {\n        const types = [\"ContractDefinition\", \"SourceUnit\"];\n        //SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes, pointer, root);\n      }\n    ),\n\n    /**\n     * data.current.contractForBytecode\n     * contract node for the executing bytecode -- *not* the current position!\n     * probably not what you usually want\n     */\n    contractForBytecode: createLeaf(\n      [evm.current.context, \"./scopes/inlined\"],\n      ({ contractId }, scopes) =>\n        (scopes[contractId] || { definition: null }).definition\n    ),\n\n    /**\n     * data.current.fallbackOutputForContext\n     * returns null if none\n     */\n    fallbackOutputForContext: createLeaf(\n      [\"./contractForBytecode\"],\n      contract => {\n        if (!contract) {\n          return null;\n        }\n        const fallbackDefinition = contract.nodes.find(\n          node =>\n            node.nodeType === \"FunctionDefinition\" &&\n            Codec.Ast.Utils.functionKind(node) === \"fallback\"\n        );\n        if (!fallbackDefinition) {\n          return null;\n        }\n        return fallbackDefinition.returnParameters.parameters[0] || null;\n      }\n    ),\n\n    /**\n     * data.current.function\n     * may be modifier rather than function!\n     */\n    function: createLeaf(\n      [\"./node\", \"./scopes/inlined\", \"./pointer\", \"./root\"],\n      (node, scopes, pointer, root) => {\n        const types = [\n          \"FunctionDefinition\",\n          \"ModifierDefinition\",\n          \"ContractDefinition\",\n          \"SourceUnit\"\n        ];\n        //SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes, pointer, root);\n      }\n    ),\n\n    /**\n     * data.current.inModifier\n     */\n    inModifier: createLeaf(\n      [\"./function\"],\n      node => node && node.nodeType === \"ModifierDefinition\"\n    ),\n\n    /**\n     * data.current.inFunctionOrModifier\n     */\n    inFunctionOrModifier: createLeaf(\n      [\"./function\"],\n      node =>\n        node &&\n        (node.nodeType === \"FunctionDefinition\" ||\n          node.nodeType === \"ModifierDefinition\")\n    ),\n\n    /**\n     * data.current.functionDepth\n     */\n\n    functionDepth: createLeaf([solidity.current.functionDepth], identity),\n\n    /**\n     * data.current.modifierDepth\n     */\n\n    modifierDepth: createLeaf([solidity.current.modifierDepth], identity),\n\n    /**\n     * data.current.address\n     * NOTE: this is the STORAGE address for the current call, not the CODE\n     * address\n     */\n\n    address: createLeaf([evm.current.call], call => call.storageAddress),\n\n    /**\n     * data.current.functionsByProgramCounter\n     */\n    functionsByProgramCounter: createLeaf(\n      [solidity.current.functionsByProgramCounter],\n      functions => functions\n    ),\n\n    /**\n     * data.current.context\n     */\n    context: createLeaf([evm.current.context], debuggerContextToDecoderContext),\n\n    /**\n     * data.current.fallbackBase\n     * gives the stack position where a fallback input would start\n     * this is 0 if there are no public or external functions, and 1 if there are\n     */\n    fallbackBase: createLeaf(\n      [\"./context\"],\n      ({ abi }) => (Object.keys(abi).length > 0 ? 1 : 0)\n      //note ABI here has been transformed to include functions only\n    ),\n\n    /**\n     * data.current.errorLocation\n     * note: we can't get the actual node from stacktrace,\n     * it doesn't store that\n     */\n    errorLocation: createLeaf(\n      [stacktrace.current.innerReturnPosition, stacktrace.current.lastPosition],\n      (innerLocation, lastLocation) => innerLocation || lastLocation || {}\n    ),\n\n    /**\n     * data.current.errorNode\n     * note: we can't get the actual node from stacktrace,\n     * it only stores the ID\n     */\n    errorNode: createLeaf(\n      [\"./errorLocation\", \"/views/scopes/inlined\"],\n      (errorLocation, scopes) => {\n        const sourceId = (errorLocation.source || {}).id;\n        const astId = (errorLocation.node || {}).id;\n        if (sourceId !== undefined && astId !== undefined) {\n          return scopes[sourceId][astId].definition;\n        } else {\n          return null;\n        }\n      }\n    ),\n\n    /**\n     * data.current.errorId\n     * returns a codec-style ID, not just an AST ID\n     * does not assume that the error is on the correct node...\n     * this could be factored into two selectors (one that finds\n     * the node and one that makes the ID)\n     */\n    errorId: createLeaf(\n      [\"./errorNode\", \"./compilationId\"],\n      (errorNode, compilationId) => {\n        if (errorNode === null) {\n          return undefined;\n        }\n        switch (errorNode.nodeType) {\n          case \"RevertStatement\":\n            //I don't think this case should happen, but I'm including it\n            //for extra certainty\n            errorNode = errorNode.errorCall;\n            //DELIBERATE FALL-THROUGH\n          case \"FunctionCall\":\n            //this should work for both qualified & unqualified errors\n            const errorId = errorNode.expression.referencedDeclaration;\n            return Codec.Contexts.Import.makeTypeId(errorId, compilationId);\n          default:\n            //I'm not going to try to handle other cases that maybe could\n            //occur with the optimizer on\n            return undefined;\n        }\n      }\n    ),\n\n    /**\n     * data.current.aboutToModify\n     * HACK\n     * This selector is used to catch those times when we go straight from a\n     * modifier invocation into the modifier itself, skipping over the\n     * definition node (this includes base constructor calls).  So it should\n     * return true when:\n     * 1. we're on the node corresponding to an argument to a modifier\n     * invocation or base constructor call, or, if said argument is a type\n     * conversion, its argument (or nested argument)\n     * 2. the next node is not a FunctionDefinition, ModifierDefinition, or\n     * in the same modifier / base constructor invocation\n     */\n    aboutToModify: createLeaf(\n      [\n        \"./node\",\n        \"./modifierInvocation\",\n        \"./modifierArgumentIndex\",\n        \"/next/node\",\n        \"/next/modifierInvocation\",\n        evm.current.step.isContextChange\n      ],\n      (node, invocation, index, next, nextInvocation, isContextChange) => {\n        //ensure: current instruction is not a context change (because if it is\n        //we cannot rely on the data.next selectors, but also if it is we know\n        //we're not about to call a modifier or base constructor!)\n        //we also want to return false if we can't find things for whatever\n        //reason\n        if (\n          isContextChange ||\n          !node ||\n          node.id === undefined ||\n          !next ||\n          next.id === undefined ||\n          !invocation ||\n          invocation.id === undefined ||\n          !nextInvocation ||\n          nextInvocation.id === undefined\n        ) {\n          return false;\n        }\n\n        //ensure: current position is in a ModifierInvocation or\n        //InheritanceSpecifier (recall that SourceUnit was included as\n        //fallback)\n        if (invocation.nodeType === \"SourceUnit\") {\n          return false;\n        }\n\n        //ensure: next node is not a function definition or modifier definition\n        if (\n          next.nodeType === \"FunctionDefinition\" ||\n          next.nodeType === \"ModifierDefinition\"\n        ) {\n          return false;\n        }\n\n        //ensure: next node is not in the same invocation\n        if (\n          nextInvocation.nodeType !== \"SourceUnit\" &&\n          nextInvocation.id === invocation.id\n        ) {\n          return false;\n        }\n\n        //now: are we on the node corresponding to an argument, or, if\n        //it's a type conversion, its nested argument?\n        if (index === undefined) {\n          return false;\n        }\n        let argument = invocation.arguments[index];\n        while (argument.kind === \"typeConversion\") {\n          if (node.id === argument.id) {\n            return true;\n          }\n          argument = argument.arguments[0];\n        }\n        return node.id === argument.id;\n      }\n    ),\n\n    /**\n     * data.current.modifierInvocation\n     */\n    modifierInvocation: createLeaf(\n      [\"./node\", \"./scopes/inlined\"],\n      (node, scopes) => {\n        const types = [\n          \"ModifierInvocation\",\n          \"InheritanceSpecifier\",\n          \"SourceUnit\"\n        ];\n        //again, SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes);\n      }\n    ),\n\n    /**\n     * data.current.modifierArgumentIndex\n     * gets the index of the current modifier argument that you're in\n     * (undefined when not in a modifier argument)\n     */\n    modifierArgumentIndex: createLeaf(\n      [\"./scopes\", \"./node\", \"./modifierInvocation\"],\n      (scopes, node, invocation) => {\n        if (!invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        let pointer = scopes[node.id].pointer;\n        let invocationPointer = scopes[invocation.id].pointer;\n\n        //slice the invocation pointer off the beginning\n        let difference = pointer.slice(invocationPointer.length);\n        debug(\"difference %s\", difference);\n        let rawIndex = difference.match(/^\\/arguments\\/(\\d+)/);\n        //note that that \\d+ is greedy\n        debug(\"rawIndex %o\", rawIndex);\n        if (rawIndex === null) {\n          return undefined;\n        }\n        return parseInt(rawIndex[1]);\n      }\n    ),\n\n    /**\n     * data.current.modifierBeingInvoked\n     * gets the node corresponding to the modifier or base constructor\n     * being invoked\n     */\n    modifierBeingInvoked: createLeaf(\n      [\"./modifierInvocation\", \"./scopes/inlined\"],\n      (invocation, scopes) => {\n        if (!invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        return modifierForInvocation(invocation, scopes);\n      }\n    ),\n\n    /**\n     * data.current.identifiers (namespace)\n     */\n    identifiers: {\n      /**\n       * data.current.identifiers (selector)\n       *\n       * returns identifers and corresponding definition node ID or builtin name\n       * (object entries look like [name]: {astRef: astRef}, [name]: {builtin: name})\n       */\n      _: createLeaf(\n        [\n          \"/current/scopes/inlined\",\n          \"/current/node\",\n          \"/current/pointer\",\n          \"/current/sourceIndex\",\n          \"/current/language\"\n        ],\n\n        (scopes, scope, pointer, sourceId, language) => {\n          let variables = {};\n          if (scope !== undefined) {\n            let cur =\n              scope.id !== undefined ? scope.id : makePath(sourceId, pointer);\n\n            while (cur !== null && scopes[cur]) {\n              debug(\"cur: %o\", cur);\n              debug(\"scopes[cur]: %o\", scopes[cur]);\n              variables = Object.assign(\n                variables,\n                ...(scopes[cur].variables || [])\n                  .filter(variable => variable.name !== \"\") //exclude anonymous output params\n                  .filter(variable => variables[variable.name] == undefined) //don't add shadowed vars\n                  .map(variable => ({\n                    [variable.name]: { astRef: variable.astRef }\n                  }))\n              );\n\n              if (scopes[cur].definition.nodeType === \"YulFunctionDefinition\") {\n                //Yul functions make the outside invisible\n                break;\n              }\n\n              if (scopes[cur].parentId !== undefined) {\n                cur = scopes[cur].parentId; //may be null!\n                //(undefined means we don't know what's up,\n                //null means there's nothing)\n              } else {\n                //in this case, cur must be a source-and-pointer, so we'll step\n                //up that way (skipping over any arrays)\n                cur = cur.replace(/\\/[^/]*(\\/\\d+)?$/, \"\");\n              }\n            }\n          }\n\n          let builtins = {\n            msg: { builtin: \"msg\" },\n            tx: { builtin: \"tx\" },\n            block: { builtin: \"block\" },\n            this: { builtin: \"this\" },\n            now: { builtin: \"now\" }\n          };\n\n          if (\n            language !== \"Solidity\" ||\n            (scope &&\n              (scope.nodeType.startsWith(\"Yul\") ||\n                scope.nodeType === \"InlineAssembly\"))\n          ) {\n            //Solidity builtins are for Solidity only!\n            return variables;\n          }\n\n          return { ...builtins, ...variables };\n        }\n      ),\n\n      /**\n       * data.current.identifiers.definitions (namespace)\n       */\n      definitions: {\n        /**\n         * data.current.identifiers.definitions (selector)\n         * definitions for current variables, by identifier\n         */\n        _: createLeaf(\n          [\"/current/scopes/inlined\", \"../_\", \"./this\", \"/current/compiler\"],\n\n          (scopes, identifiers, thisDefinition, compiler) => {\n            debug(\"identifiers: %O\", identifiers);\n            let variables = Object.assign(\n              {},\n              ...Object.entries(identifiers).map(([identifier, variable]) => {\n                if (variable.astRef !== undefined) {\n                  let { definition } = scopes[variable.astRef];\n                  return { [identifier]: definition };\n                  //there used to be separate code for Yul variables here,\n                  //but now that's handled in definitionToType\n                } else {\n                  return {}; //skip over builtins; we'll handle those separately\n                }\n              })\n            );\n            let builtins = {\n              msg: MSG_DEFINITION,\n              tx: TX_DEFINITION,\n              block: BLOCK_DEFINITION\n            };\n            //only include this when it has a proper definition\n            if (thisDefinition) {\n              builtins.this = thisDefinition;\n            }\n            //only include now on versions prior to 0.7.0\n            if (!solidityVersionHasNoNow(compiler)) {\n              debug(\"adding now\");\n              builtins.now = NOW_DEFINITION;\n            }\n            return { ...builtins, ...variables };\n          }\n        ),\n\n        /*\n         * data.current.identifiers.definitions.this\n         *\n         * returns a spoofed definition for the this variable\n         */\n        this: createLeaf([\"/current/contract\"], contractNode =>\n          contractNode && contractNode.nodeType === \"ContractDefinition\"\n            ? spoofThisDefinition(\n                contractNode.name,\n                contractNode.id,\n                contractNode.contractKind\n              )\n            : null\n        )\n      },\n\n      /**\n       * data.current.identifiers.sections\n       * used for printing out the variables in sections\n       */\n      sections: createLeaf(\n        [\"./definitions\", \"./refs\", \"/current/scopes/inlined\"],\n        (definitions, refs, scopes) => {\n          let sections = {\n            builtin: [],\n            global: [],\n            contract: [],\n            local: []\n          };\n          for (const [identifier, ref] of Object.entries(refs)) {\n            if (identifier in definitions) {\n              switch (ref.location) {\n                case \"special\":\n                  sections.builtin.push(identifier);\n                  break;\n                case \"stack\":\n                  sections.local.push(identifier);\n                  break;\n                case \"storage\":\n                case \"code\":\n                case \"nowhere\":\n                case \"memory\":\n                  sections.contract.push(identifier);\n                  break;\n                case \"definition\":\n                  //in this case, look up whether its scope\n                  //is a SourceUnit or a ContractDefinition\n                  const definition = definitions[identifier];\n                  const scope = scopes[definition.scope].definition;\n                  if (scope.nodeType === \"SourceUnit\") {\n                    sections.global.push(identifier);\n                  } else if (scope.nodeType === \"ContractDefinition\") {\n                    sections.contract.push(identifier);\n                  }\n                  //other cases shouldn't happen\n                  break;\n                //other cases shouldn't happen\n              }\n            }\n          }\n          return sections;\n        }\n      ),\n\n      /**\n       * data.current.identifiers.refs\n       *\n       * current variables' value refs\n       */\n      refs: createLeaf(\n        [\n          \"/proc/assignments\",\n          \"./_\",\n          \"./definitions\",\n          \"/current/scopes/inlined\",\n          \"/current/compilationId\",\n          \"/current/internalSourceFor\", //may be null\n          \"/current/functionDepth\", //for pruning things too deep on stack\n          \"/current/modifierDepth\", //when it's useful\n          \"/current/inModifier\"\n        ],\n\n        (\n          assignments,\n          identifiers,\n          definitions,\n          scopes,\n          compilationId,\n          internalFor,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        ) =>\n          Object.assign(\n            {},\n            ...Object.entries(identifiers).map(\n              ([identifier, { astRef, builtin }]) => {\n                let id;\n                debug(\"astRef: %o\", astRef);\n                debug(\"builtin: %s\", builtin);\n\n                //is this an ordinary variable or a builtin?\n                if (astRef !== undefined) {\n                  //ordinary variable case\n                  //first: is this a contract variable?\n                  id = stableKeccak256({\n                    astRef,\n                    compilationId,\n                    internalFor\n                  });\n                  //if not contract, it's local, so identify by stackframe (& etc)\n                  if (!(id in assignments)) {\n                    id = stableKeccak256({\n                      astRef,\n                      compilationId,\n                      internalFor,\n                      stackframe: currentDepth,\n                      modifierDepth: inModifier ? modifierDepth : null\n                    });\n                  }\n                  debug(\"id after local: %s\", id);\n                  //if it's not that either, but it's a constant, maybe it's a\n                  //global (if it is, whip up an assignment rather than extracting\n                  //one from assignments!)\n                  if (!(id in assignments)) {\n                    const definition = definitions[identifier];\n                    debug(\"global definition: %o\", definition);\n                    if (definition.scope !== undefined) {\n                      const scope = scopes[definition.scope].definition;\n                      if (\n                        scope.nodeType === \"SourceUnit\" &&\n                        (definition.constant === true ||\n                          definition.mutability === \"constant\")\n                      ) {\n                        return {\n                          [identifier]: {\n                            location: \"definition\",\n                            definition: definition.value\n                          }\n                        };\n                      }\n                    }\n                  }\n                } else {\n                  //it's a builtin\n                  id = stableKeccak256({\n                    builtin\n                  });\n                }\n\n                //if we still didn't find it, oh well\n                debug(\"id: %s\", id);\n\n                let { ref } = assignments[id] || {};\n                if (!ref) {\n                  return {}; //don't add anything\n                }\n                return {\n                  [identifier]: ref\n                };\n              }\n            )\n          )\n      )\n    },\n\n    /**\n     * data.current.returnStatus\n     */\n    returnStatus: createLeaf(\n      [evm.current.step.returnStatus],\n      status => (status === null ? undefined : status) //convert null to undefined to be safe\n    ),\n\n    /**\n     * data.current.returnAllocation\n     */\n    returnAllocation: createLeaf(\n      [\n        evm.current.call,\n        \"/current/context\",\n        \"/info/allocations/calldata\",\n        \"./fallbackOutputForContext\"\n      ],\n      (\n        { data: calldata },\n        { context, isConstructor, fallbackAbi },\n        { constructorAllocations, functionAllocations },\n        contractHasFallbackOutput //just using truthiness here\n      ) => {\n        if (isConstructor) {\n          //we're in a constructor call\n          let allocation = constructorAllocations[context];\n          if (!allocation) {\n            return null;\n          }\n          return allocation.output;\n        } else {\n          //usual case\n          let selector = calldata.slice(0, 2 + 4 * 2); //extract first 4 bytes of hex string\n          debug(\"selector: %s\", selector);\n          debug(\"bySelector: %o\", functionAllocations[context]);\n          let allocation = (functionAllocations[context] || {})[selector];\n          if (allocation) {\n            return allocation.output;\n          } else {\n            //we're in a fallback or receive, presumably.\n            //so is it a fallback, and does it have output?\n            if (\n              (calldata !== \"0x\" || fallbackAbi.receive === null) &&\n              fallbackAbi.fallback !== null && //this check is redundant, but let's include it\n              contractHasFallbackOutput\n            ) {\n              return Codec.AbiData.Allocate.FallbackOutputAllocation;\n            } else {\n              return null;\n            }\n          }\n        }\n      }\n    ),\n\n    /**\n     * data.current.isCall\n     */\n    isCall: createLeaf([evm.current.step.isCall], identity),\n\n    /**\n     * data.current.isCreate\n     */\n    isCreate: createLeaf([evm.current.step.isCreate], identity),\n\n    /**\n     * data.current.currentCallIsCreate\n     */\n    currentCallIsCreate: createLeaf(\n      [evm.current.call],\n      call => call.binary !== undefined\n    ),\n\n    /**\n     * data.current.callContext\n     * note that we convert to decoder context!\n     */\n    callContext: createLeaf(\n      [evm.current.step.callContext],\n      debuggerContextToDecoderContext\n    ),\n\n    /**\n     * data.current.isPop\n     */\n    isPop: createLeaf([evm.current.step.isPop], identity)\n  },\n\n  /**\n   * data.next\n   */\n  next: {\n    /**\n     * data.next.state\n     * Yes, I'm just repeating the code for data.current.state.stack here;\n     * not worth the trouble to factor out\n     */\n    state: {\n      /**\n       * data.next.state.stack\n       */\n      stack: createLeaf(\n        [evm.next.state.stack],\n\n        words => (words || []).map(word => Codec.Conversion.toBytes(word))\n      ),\n\n      /**\n       * data.next.state.returndata\n       * NOTE: this is only for use by decodeReturnValue(); this is *not*\n       * an accurate reflection of the current contents of returndata!\n       * we don't track that at the moment\n       */\n      returndata: createLeaf([evm.current.step.returnValue], data =>\n        Codec.Conversion.toBytes(data)\n      ),\n\n      /**\n       * data.next.state.calldata\n       * NOTE: this is only for use by decodeCall(); this is *not*\n       * necessarily the actual next contents of calldata!\n       */\n      calldata: createLeaf(\n        [\n          evm.current.step.isCall,\n          evm.current.step.isCreate,\n          evm.current.step.callData,\n          evm.current.step.createBinary\n        ],\n        (isCall, isCreate, data, binary) => {\n          if (!isCall && !isCreate) {\n            return null;\n          }\n          return Codec.Conversion.toBytes(isCall ? data : binary);\n        }\n      )\n    },\n\n    //HACK WARNING\n    //the following selectors depend on solidity.next\n    //do not use them when the current instruction is a context change!\n\n    /**\n     * data.next.node\n     */\n    node: createLeaf([solidity.next.node], identity),\n\n    /**\n     * data.next.pointer\n     */\n    pointer: createLeaf([solidity.next.pointer], identity),\n\n    /**\n     * data.next.modifierInvocation\n     * Note: yes, I'm just repeating the code from data.current here but with\n     * invalid added\n     */\n    modifierInvocation: createLeaf(\n      [\"./node\", \"/current/scopes/inlined\", evm.current.step.isContextChange],\n      (node, scopes, invalid) => {\n        //don't attempt this at a context change!\n        //(also don't attempt this if we can't find the node for whatever\n        //reason)\n        if (invalid) {\n          return undefined;\n        }\n        const types = [\n          \"ModifierInvocation\",\n          \"InheritanceSpecifier\",\n          \"SourceUnit\"\n        ];\n        //again, SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes);\n      }\n    ),\n\n    /**\n     * data.next.modifierBeingInvoked\n     */\n    modifierBeingInvoked: createLeaf(\n      [\n        \"./modifierInvocation\",\n        \"/current/scopes/inlined\",\n        evm.current.step.isContextChange\n      ],\n      (invocation, scopes, invalid) => {\n        if (invalid || !invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        return modifierForInvocation(invocation, scopes);\n      }\n    )\n    //END HACK WARNING\n  },\n\n  /**\n   * data.nextUserStep\n   */\n  nextUserStep: {\n    /**\n     * data.nextUserStep.state\n     * Yes, I'm just repeating the code for data.current.state.stack here;\n     * not worth the trouble to factor out\n     * HACK: this assumes we're not about to change context! don't use this if we\n     * are!\n     */\n    state: {\n      /**\n       * data.nextUserStep.state.stack\n       */\n      stack: createLeaf(\n        [solidity.current.nextUserStep],\n\n        step =>\n          ((step || {}).stack || []).map(word => Codec.Conversion.toBytes(word))\n      )\n    }\n  },\n\n  /**\n   * data.nextOfSameDepth\n   */\n  nextOfSameDepth: {\n    /**\n     * data.nextOfSameDepth.state\n     * Yes, I'm just repeating the code for data.current.state.stack here but\n     * with an extra guard... *still* not worth the trouble to factor out\n     * HOWEVER, this one also returns null if there is no nextOfSameDepth\n     */\n    state: {\n      /**\n       * data.nextOfSameDepth.state.stack\n       */\n      stack: createLeaf(\n        [trace.nextOfSameDepth],\n\n        step =>\n          step\n            ? (step.stack || []).map(word => Codec.Conversion.toBytes(word))\n            : null\n      )\n    }\n  }\n});\n\nexport default data;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\n\nimport {\n  prefixName,\n  stableKeccak256,\n  makeAssignment,\n  makePath\n} from \"lib/helpers\";\n\nimport { TICK } from \"lib/trace/actions\";\nimport * as actions from \"../actions\";\nimport * as trace from \"lib/trace/sagas\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as web3 from \"lib/web3/sagas\";\n\nimport data from \"../selectors\";\n\nimport sum from \"lodash.sum\";\nimport jsonpointer from \"json-pointer\";\n\nimport * as Codec from \"@truffle/codec\";\nimport BN from \"bn.js\";\n\nexport function* scope(nodeId, pointer, parentId, sourceIndex, sourceId) {\n  yield put(actions.scope(nodeId, pointer, parentId, sourceIndex, sourceId));\n}\n\nexport function* declare(node, sourceId) {\n  yield put(actions.declare(node.name, node.id, node.scope, sourceId));\n}\n\nexport function* yulScope(pointer, sourceIndex, sourceId, parentId) {\n  yield put(\n    //node ID is always undefined\n    actions.scope(undefined, pointer, parentId, sourceIndex, sourceId)\n  );\n}\n\nexport function* yulDeclare(\n  node,\n  pointer,\n  scopePointer,\n  sourceIndex,\n  sourceId\n) {\n  yield put(\n    actions.declare(\n      node.name,\n      makePath(sourceIndex, pointer),\n      makePath(sourceIndex, scopePointer),\n      sourceId\n    )\n  );\n}\n\nexport function* defineType(node, sourceId) {\n  yield put(actions.defineType(node, sourceId));\n}\n\nexport function* defineTaggedOutput(node, sourceId) {\n  yield put(actions.defineTaggedOutput(node, sourceId));\n}\n\nfunction* tickSaga() {\n  yield* variablesAndMappingsSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\nexport function* decode(definition, ref, compilationId) {\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const state = yield select(data.current.state);\n  const mappingKeys = yield select(data.views.mappingKeys);\n  const allocations = yield select(data.info.allocations);\n  const contexts = yield select(data.views.contexts);\n  const currentContext = yield select(data.current.context);\n  const internalFunctionsTable = yield select(\n    data.current.functionsByProgramCounter\n  );\n\n  debug(\"definition: %o\");\n  debug(\"ref: %o\");\n  debug(\"compilationId: %s\", compilationId);\n\n  const ZERO_WORD = new Uint8Array(Codec.Evm.Utils.WORD_SIZE); //automatically filled with zeroes\n\n  const decoder = Codec.decodeVariable(\n    definition,\n    ref,\n    {\n      userDefinedTypes,\n      state,\n      mappingKeys,\n      allocations,\n      contexts,\n      currentContext,\n      internalFunctionsTable\n    },\n    compilationId\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      case \"storage\":\n        //the debugger supplies all storage it knows at the beginning.\n        //any storage it does not know is presumed to be zero.\n        response = ZERO_WORD;\n        break;\n      case \"code\":\n        response = yield* requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  debug(\"decoded value: %O\", result.value);\n  return result.value;\n}\n\nexport function* decodeReturnValue() {\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const state = yield select(data.next.state); //next state has the return data\n  const allocations = yield select(data.info.allocations);\n  const contexts = yield select(data.views.contexts);\n  const currentContext = yield select(data.current.context);\n  const status = yield select(data.current.returnStatus); //may be undefined\n  const returnAllocation = yield select(data.current.returnAllocation); //may be null\n  const errorId = yield select(data.current.errorId);\n  debug(\"returnAllocation: %O\", returnAllocation);\n\n  const decoder = Codec.decodeReturndata(\n    {\n      userDefinedTypes,\n      state,\n      allocations,\n      contexts,\n      currentContext\n    },\n    returnAllocation,\n    status,\n    errorId\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      //skip storage case, it won't happen here\n      case \"code\":\n        response = yield* requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  debug(\"decoded value: %O\", result.value);\n  return result.value;\n}\n\n//by default, decodes the call being made at the current step;\n//if the flag is passed, instead decodes the call you're currently in\nexport function* decodeCall(decodeCurrent = false) {\n  const isCall = yield select(data.current.isCall);\n  const isCreate = yield select(data.current.isCreate);\n  if (!isCall && !isCreate && !decodeCurrent) {\n    return null;\n  }\n  const currentCallIsCreate = yield select(data.current.currentCallIsCreate);\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  let state = decodeCurrent\n    ? yield select(data.current.state)\n    : yield select(data.next.state);\n  if (decodeCurrent && currentCallIsCreate) {\n    //if we want to decode the *current* call, but the current call\n    //is a creation, we had better pass in the code, not the calldata\n    state = {\n      ...state,\n      calldata: state.code\n    };\n  }\n  const allocations = yield select(data.info.allocations);\n  debug(\"allocations: %O\", allocations);\n  const contexts = yield select(data.views.contexts);\n  const context = decodeCurrent\n    ? yield select(data.current.context)\n    : yield select(data.current.callContext);\n  const isConstructor = decodeCurrent\n    ? yield select(data.current.currentCallIsCreate)\n    : isCreate;\n\n  const decoder = Codec.decodeCalldata(\n    {\n      state,\n      userDefinedTypes,\n      allocations,\n      contexts,\n      currentContext: context\n    },\n    isConstructor\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      //skip storage case, it won't happen here\n      case \"code\":\n        response = yield* requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  return result.value;\n}\n\n//NOTE: calling this *can* add a new instance, which will not\n//go away on a reset!  Yes, this is a little weird, but we\n//decided this is OK for now\nfunction* requestCode(address) {\n  const NO_CODE = new Uint8Array(); //empty array\n  const blockNumber = yield select(data.views.blockNumber);\n  const instances = yield select(data.views.instances);\n\n  if (address in instances) {\n    return instances[address];\n  } else if (address === Codec.Evm.Utils.ZERO_ADDRESS) {\n    //HACK: to avoid displaying the zero address to the user as an\n    //affected address just because they decoded a contract or external\n    //function variable that hadn't been initialized yet, we give the\n    //zero address's codelessness its own private cache :P\n    return NO_CODE;\n  } else {\n    //I don't want to write a new web3 saga, so let's just use\n    //obtainBinaries with a one-element array\n    debug(\"fetching binary\");\n    let binary = (yield* web3.obtainBinaries([address], blockNumber))[0];\n    debug(\"adding instance\");\n    yield* evm.addInstance(address, binary);\n    return Codec.Conversion.toBytes(binary);\n  }\n}\n\nfunction* variablesAndMappingsSaga() {\n  // stack is only ready for interpretation after the last step of each\n  // source range\n  //\n  // the data module always looks at the result of a particular opcode\n  // (i.e., the following trace step's stack/memory/storage), so this\n  // asserts that the _current_ operation is the final one before\n  // proceeding\n  if (!(yield select(data.views.atLastInstructionForSourceRange))) {\n    return;\n  }\n\n  let node = yield select(data.current.node);\n  //can mutate in FunctionTypeName, YulLiteral, and YulIdentifier cases\n\n  if (!node) {\n    return;\n  }\n\n  //set up stack; see default case for what normally goes on\n  let stack;\n  switch (node.nodeType) {\n    case \"IndexAccess\":\n    case \"MemberAccess\":\n      stack = yield select(data.nextUserStep.state.stack);\n      //HACK: unfortunately, in some cases, data.next.state.stack gets the wrong\n      //results due to unmapped/internal instructions intervening.  So, we get the stack at\n      //the next mapped-to-user-source stack instead.  This is something of a hack and won't\n      //work if we're about to change context, but it should work in the cases that\n      //need it.\n      break;\n    case \"YulFunctionCall\":\n      stack = yield select(data.nextOfSameDepth.state.stack);\n      //if the step we're on is a CALL (or similar), as can happen with Yul,\n      //we don't want to look at the stack on the *next* step, but rather\n      //the step when it returns; hence this\n      break;\n    default:\n      stack = yield select(data.next.state.stack); //note the use of next!\n      //in this saga we are interested in the *results* of the current instruction\n      //note that the decoder is still based on data.current.state; that's fine\n      //though.  There's already a delay between when we record things off the\n      //stack and when we decode them, after all.  Basically, nothing serious\n      //should happen after an index node but before the index access node that\n      //would cause storage, memory, or calldata to change, meaning that even if\n      //the literal we recorded was a pointer, it will still be valid at the time\n      //we use it.  (The other literals we make use of, for the base expressions,\n      //are not decoded, so no potential mismatch there would be relevant anyway.)\n      break;\n  }\n\n  if (!stack) {\n    //note: should only happen in YulFunctionCall case\n    return;\n  }\n\n  const top = stack.length - 1;\n\n  //set up other variables\n  let pointer = yield select(data.current.pointer); //can mutate in YulLiteral and YulIdentifier cases\n  const currentDepth = yield select(data.current.functionDepth);\n  const modifierDepth = yield select(data.current.modifierDepth);\n  const inModifier = yield select(data.current.inModifier);\n  const address = yield select(data.current.address); //storage address, not code address\n  const compilationId = yield select(data.current.compilationId);\n  const internalFor = yield select(data.current.internalSourceFor);\n  //just in case it ever becomes possible to have a Solidity generated source\n\n  let assignments, preambleAssignments;\n\n  //HACK: modifier preamble\n  //modifier definitions are typically skipped (this includes constructor\n  //definitions when called as a base constructor); as such I've added this\n  //\"modifier preamble\" to catch them\n  if (yield select(data.current.aboutToModify)) {\n    const modifier = yield select(data.current.modifierBeingInvoked);\n    //may be either a modifier or base constructor\n    const currentIndex = yield select(data.current.modifierArgumentIndex);\n    debug(\"currentIndex %d\", currentIndex);\n    const parameters = modifier.parameters.parameters;\n    //now: look at the parameters *after* the current index.  we'll need to\n    //adjust for those.\n    const parametersLeft = parameters.slice(currentIndex + 1);\n    const adjustment = sum(parametersLeft.map(Codec.Ast.Utils.stackSize));\n    debug(\"adjustment %d\", adjustment);\n    preambleAssignments = assignParameters(\n      compilationId,\n      internalFor,\n      parameters,\n      top + adjustment,\n      currentDepth,\n      modifierDepth,\n      modifier.nodeType === \"ModifierDefinition\"\n    );\n  } else {\n    preambleAssignments = {};\n  }\n\n  switch (node.nodeType) {\n    case \"FunctionDefinition\":\n    case \"ModifierDefinition\":\n      //NOTE: this will *not* catch most modifier definitions!\n      //the rest hopefully will be caught by the modifier preamble\n      //(in fact they won't all be, but...)\n\n      //HACK: prevent parameter allocation while popping\n      //sometimes Solidity's sourcemapping will jump back to the function\n      //definition after a bare block while it pops the stack a bit.\n      //we don't want to allocate then, so we'll break out if the current\n      //instruction is a POP.\n      if (yield select(data.current.isPop)) {\n        break;\n      }\n\n      //HACK: filter out some garbage\n      //this filters out the case where we're really in an invocation of a\n      //modifier or base constructor, but have temporarily hit the definition\n      //node for some reason.  However this obviously can have a false positive\n      //in the case where a function has the same modifier twice.\n      const nextModifier = yield select(data.next.modifierBeingInvoked);\n      if (nextModifier && nextModifier.id === node.id) {\n        break;\n      }\n\n      const parameters = node.parameters.parameters;\n      //note that we do *not* include return parameters, since those are\n      //handled by the VariableDeclaration case (no, I don't know why it\n      //works out that way)\n\n      //we can skip preambleAssignments here, that isn't used in this case\n      assignments = assignParameters(\n        compilationId,\n        internalFor,\n        parameters,\n        top,\n        currentDepth,\n        modifierDepth,\n        inModifier\n      );\n\n      debug(\"Function definition case\");\n      debug(\"assignments %O\", assignments);\n\n      yield put(actions.assign(assignments));\n      break;\n\n    case \"YulFunctionDefinition\": {\n      const nextPointer = yield select(data.next.pointer);\n      if (\n        nextPointer === null ||\n        !(\n          nextPointer.startsWith(`${pointer}/body/`) ||\n          nextPointer.startsWith(`${pointer}/returnVariables`)\n        )\n      ) {\n        //in this case, we're seeing the function\n        //as it's being defined, rather than as it's\n        //being called\n        //notice the final slash; when you enter a function, you go *strictly inside*\n        //its body (if you hit the body node itself you are seeing the definition)\n        //(as of Solidity 0.8.4, you may also go to the return parameters; rather\n        //than switch on the version, and use a different mechanism for that,\n        //we'll use the same mechanism but alter the condition above to account\n        //for that)\n        break;\n      }\n      //yul parameters are a bit weird.\n      //whereas solidity parameters go bottom to top,\n      //first inputs then outputs (and we skip handling the outputs),\n      //yul parameters have the inputs go top to bottom,\n      //and the outputs go bottom to top (again with the outputs on top)\n      //For Solidity <0.8.4, we need to handle both inputs and outputs\n      //here; for Solidity >=0.8.4, we handle only inputs here and handle\n      //outputs separately\n      let returnSuffixes = [];\n      if (nextPointer.startsWith(`${pointer}/body/`)) {\n        returnSuffixes = (node.returnVariables || []).map(\n          (_, index, vars) => `/returnVariables/${vars.length - 1 - index}`\n        );\n      }\n      const parameterSuffixes = (node.parameters || []).map(\n        (_, index) => `/parameters/${index}`\n      );\n      //HACK: prior to 0.6.8, we *also* need to account for any bare lets (ones\n      //w/no value given) at the beginning of the function body because these\n      //will throw off our count otherwise\n      let bareLetSuffixes = []; //when hack is not invoked, we just leave this empty\n      if (!(yield select(data.current.bareLetsInYulAreHit))) {\n        let outerIndex = 0;\n        for (const declaration of node.body.statements) {\n          if (\n            declaration.nodeType !== \"YulVariableDeclaration\" ||\n            declaration.value != null\n          ) {\n            //deliberate != for future Solidity versions\n            break;\n          }\n          for (\n            let innerIndex = 0;\n            innerIndex < declaration.variables.length;\n            innerIndex++\n          ) {\n            //we want to process from top to bottom, so we'll put the earlier\n            //variables last\n            bareLetSuffixes.unshift(\n              `/body/statements/${outerIndex}/variables/${innerIndex}`\n            );\n          }\n          outerIndex++;\n        }\n      }\n      //both outputs and inputs in the appropriate order (top to bottom)\n      //(well, and those lets...)\n      const suffixes = bareLetSuffixes.concat(\n        returnSuffixes,\n        parameterSuffixes\n      );\n      debug(\"suffixes: %O\", suffixes);\n      assignments = {};\n      let position = top; //because that's how we'll process things\n      const sourceIndex = yield select(data.current.sourceIndex);\n      for (const suffix of suffixes) {\n        //we only care about the pointer, not the variable\n        const sourceAndPointer = makePath(sourceIndex, pointer + suffix);\n        const assignment = makeAssignment(\n          {\n            compilationId,\n            internalFor,\n            astRef: sourceAndPointer,\n            stackframe: currentDepth,\n            modifierDepth: inModifier ? modifierDepth : null\n          },\n          {\n            location: \"stack\",\n            from: position, //all Yul variables are size 1\n            to: position\n          }\n        );\n        assignments[assignment.id] = assignment;\n        position--;\n      }\n      yield put(actions.assign(assignments));\n      break;\n    }\n\n    case \"ContractDefinition\": {\n      const allocations = yield select(data.current.allocations.state);\n      const allocation = allocations[node.id];\n\n      debug(\"Contract definition case\");\n      debug(\"allocations %O\", allocations);\n      debug(\"allocation %O\", allocation);\n      assignments = {};\n      for (let id in allocation.members) {\n        id = Number(id); //used for .. in loop so get them as strings\n        const idObj = {\n          compilationId,\n          internalFor,\n          astRef: id\n        };\n        //these aren't locals, so we omit stackframe and modifier info\n        const ref = allocation.members[id].pointer;\n        const assignment = makeAssignment(idObj, ref);\n        assignments[assignment.id] = assignment;\n      }\n      //one more: add in the fallback input assignment here\n      const fallbackDefinition = node.nodes.find(\n        subNode => subNode.nodeType === \"FunctionDefinition\" &&\n          Codec.Ast.Utils.functionKind(subNode) === \"fallback\"\n      );\n      if (fallbackDefinition) {\n        const fallbackInputDefinition = fallbackDefinition.parameters.parameters[0]; //may be undefined\n        if (fallbackInputDefinition) {\n          const base = yield select(data.current.fallbackBase);\n          const ref = { \n            location: \"stack\",\n            from: base,\n            to: base + Codec.Ast.Utils.stackSize(fallbackInputDefinition) - 1\n            //note: we will always have to===from+1, since it's always bytes calldata, but\n            //we'll do it this way just to be safe\n          }; //fallback input is always at the very bottom\n          const idObj = {\n            compilationId,\n            internalFor,\n            astRef: fallbackInputDefinition.id,\n            stackframe: currentDepth, //note the lack of a jump into fallbacks\n            modifierDepth: null //it's a function body variable\n          };\n          const assignment =\n            makeAssignment(idObj, ref);\n          assignments[assignment.id] = assignment;\n        }\n      }\n      debug(\"assignments %O\", assignments);\n\n      //this case doesn't need preambleAssignments either\n      yield put(actions.assign(assignments));\n      break;\n    }\n\n    case \"FunctionTypeName\": {\n      //HACK\n      //for some reasons, for declarations of local variables of function type,\n      //we land on the FunctionTypeName instead of the VariableDeclaration,\n      //so we replace the node with its parent (the VariableDeclaration)\n      const scopes = yield select(data.current.scopes.inlined);\n      node = scopes[scopes[node.id].parentId].definition;\n      //let's do a quick check that it *is* a VariableDeclaration before\n      //continuing\n      if (node.nodeType !== \"VariableDeclaration\") {\n        break;\n      }\n    }\n    //otherwise, deliberately fall through to the VariableDeclaration case\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"VariableDeclaration\": {\n      const varId = node.id;\n      debug(\"Variable declaration case\");\n      debug(\"currentDepth %d varId %d\", currentDepth, varId);\n\n      const inFunctionOrModifier = yield select(\n        data.current.inFunctionOrModifier\n      );\n      if (!inFunctionOrModifier) {\n        //if we're not in a function or modifier, then this is a contract\n        //variable, not a local variable, and should not be included\n        debug(\"already a contract variable!\");\n        break;\n      }\n\n      //otherwise, go ahead and make the assignment\n      const assignment = makeAssignment(\n        {\n          compilationId,\n          internalFor,\n          astRef: varId,\n          stackframe: currentDepth,\n          modifierDepth: inModifier ? modifierDepth : null\n        },\n        {\n          location: \"stack\",\n          from: top - Codec.Ast.Utils.stackSize(node) + 1,\n          to: top\n        }\n      );\n      assignments = { [assignment.id]: assignment };\n      //this case doesn't need preambleAssignments either\n      debug(\"assignments: %O\", assignments);\n      yield put(actions.assign(assignments));\n      break;\n    }\n\n    case \"YulFunctionCall\": {\n      const nextPointer = yield select(data.next.pointer);\n      if (nextPointer !== null && nextPointer.startsWith(pointer)) {\n        //if we're moving inside the function call itself, ignore it\n        break;\n      }\n    }\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"YulLiteral\":\n    case \"YulIdentifier\":\n      //yul variable declaration, maybe\n      const parentPointer = pointer.replace(/\\/[^/]*$/, \"\"); //chop off end\n      const root = yield select(data.current.root);\n      const parent = jsonpointer.get(root, parentPointer);\n      if (\n        pointer !== `${parentPointer}/value` ||\n        parent.nodeType !== \"YulVariableDeclaration\"\n      ) {\n        break;\n      }\n      node = parent;\n      pointer = parentPointer;\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"YulVariableDeclaration\": {\n      const sourceIndex = yield select(data.current.sourceIndex);\n      const sourceAndPointer = makePath(sourceIndex, pointer);\n      debug(\"sourceAndPointer: %s\", sourceAndPointer);\n      assignments = {};\n      //variables go on from bottom to top, so process from top to bottom\n      let position = top; //NOTE: remember that which stack we use depends on our node type!\n      for (let index = node.variables.length - 1; index >= 0; index--) {\n        //we only care about the pointer, not the variable\n        const variableSourceAndPointer = `${sourceAndPointer}/variables/${index}`;\n        const assignment = makeAssignment(\n          {\n            compilationId,\n            internalFor,\n            astRef: variableSourceAndPointer,\n            stackframe: currentDepth,\n            modifierDepth: inModifier ? modifierDepth : null\n          },\n          {\n            location: \"stack\",\n            from: position, //all Yul variables are size 1\n            to: position\n          }\n        );\n        assignments[assignment.id] = assignment;\n        position--;\n      }\n\n      //this case doesn't need preambleAssignments, obviously!\n      yield put(actions.assign(assignments));\n      break;\n    }\n\n    case \"YulTypedName\": {\n      //this case is used to handle output parameters in Yul in\n      //Solidity >=0.8.4\n      const sourceIndex = yield select(data.current.sourceIndex);\n      const sourceAndPointer = makePath(sourceIndex, pointer);\n      const assignment = makeAssignment(\n        {\n          compilationId,\n          internalFor,\n          astRef: sourceAndPointer,\n          stackframe: currentDepth,\n          modifierDepth: inModifier ? modifierDepth : null\n        },\n        {\n          location: \"stack\",\n          from: top, //all Yul variables are size 1\n          to: top\n        }\n      );\n      yield put(actions.assign({ [assignment.id]: assignment }));\n      break;\n    }\n\n    case \"IndexAccess\": {\n      // to track `mapping` types known indices\n      // (and also *some* known indices for arrays)\n\n      debug(\"Index access case\");\n\n      //we're going to start by doing the same thing as in the default case\n      //(see below) -- getting things ready for an assignment.  Then we're\n      //going to forget this for a bit while we handle the rest...\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          internalFor,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n\n      //we'll need this\n      const baseExpression = node.baseExpression;\n\n      //but first, a diversion -- is this something that could not *possibly*\n      //lead to a mapping?  i.e., either a bytes, or an array of non-reference\n      //types, or a non-storage array?\n      //if so, we'll just do the assign and quit out early\n      //(note: we write it this way because mappings aren't caught by\n      //isReference)\n      if (\n        Codec.Ast.Utils.typeClass(baseExpression) === \"bytes\" ||\n        (Codec.Ast.Utils.typeClass(baseExpression) === \"array\" &&\n          (Codec.Ast.Utils.isReference(node)\n            ? Codec.Ast.Utils.referenceType(baseExpression) !== \"storage\"\n            : !Codec.Ast.Utils.isMapping(node)))\n      ) {\n        debug(\"Index case bailed out early\");\n        debug(\"typeClass %s\", Codec.Ast.Utils.typeClass(baseExpression));\n        debug(\n          \"referenceType %s\",\n          Codec.Ast.Utils.referenceType(baseExpression)\n        );\n        debug(\"isReference(node) %o\", Codec.Ast.Utils.isReference(node));\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      const allocations = yield select(data.current.allocations.state);\n      const currentAssignments = yield select(data.proc.assignments);\n\n      const path = fetchBasePath(\n        compilationId,\n        internalFor,\n        baseExpression,\n        currentAssignments,\n        allocations,\n        currentDepth,\n        modifierDepth,\n        inModifier\n      );\n      //this may fail, so let's check for that\n      if (path === null) {\n        debug(\"bailed out due to failed path\");\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      const scopes = yield select(data.current.scopes.inlined);\n\n      let keyDefinition = Codec.Ast.Utils.keyDefinition(baseExpression, scopes);\n      //if we're dealing with an array, this will just spoof up a uint\n      //definition :)\n\n      //now... the decoding! (this is messy)\n      let indexValue = yield* decodeMappingKeySaga(\n        node.indexExpression,\n        keyDefinition\n      );\n\n      debug(\"index value %O\", indexValue);\n      debug(\"keyDefinition %o\", keyDefinition);\n\n      //whew! But we're not done yet -- we need to turn this decoded key into\n      //an actual path (assuming we *did* decode it; we check both for null\n      //and for the result being a Value and not an Error)\n      //OK, not an actual path -- we're just going to use a simple offset for\n      //the path.  But that's OK, because the mappedPaths reducer will turn\n      //it into an actual path.\n      if (indexValue != null && indexValue.value) {\n        let slot = { path };\n\n        //we need to do things differently depending on whether we're dealing\n        //with an array or mapping\n        switch (Codec.Ast.Utils.typeClass(baseExpression)) {\n          case \"array\":\n            const compiler = yield select(data.current.compiler);\n            const storageAllocations = yield select(\n              data.info.allocations.storage\n            );\n            const userDefinedTypes = yield select(data.views.userDefinedTypes);\n            slot.hashPath = Codec.Ast.Utils.isDynamicArray(baseExpression);\n            slot.offset = indexValue.value.asBN.muln(\n              Codec.Storage.Allocate.storageSize(\n                Codec.Ast.Import.definitionToType(\n                  node,\n                  compilationId,\n                  compiler\n                ),\n                userDefinedTypes,\n                storageAllocations\n              ).words\n            );\n            break;\n          case \"mapping\":\n            slot.key = indexValue;\n            slot.offset = new BN(0);\n            break;\n          default:\n            debug(\"unrecognized index access!\");\n        }\n        debug(\"slot %O\", slot);\n\n        //now, map it! (and do the assign as well)\n        yield put(\n          actions.mapPathAndAssign(\n            address,\n            slot,\n            assignments,\n            Codec.Ast.Utils.typeIdentifier(node),\n            Codec.Ast.Utils.typeIdentifier(baseExpression)\n          )\n        );\n      } else {\n        //if we failed to decode, just do the assign from above\n        debug(\"failed to decode, just assigning\");\n        yield put(actions.assign(assignments));\n      }\n\n      break;\n    }\n\n    case \"MemberAccess\": {\n      //we're going to start by doing the same thing as in the default case\n      //(see below) -- getting things ready for an assignment.  Then we're\n      //going to forget this for a bit while we handle the rest...\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          internalFor,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n\n      debug(\"Member access case\");\n\n      //MemberAccess uses expression, not baseExpression\n      const baseExpression = node.expression;\n\n      //if this isn't a storage struct, or the element isn't of reference type,\n      //we'll just do the assignment and quit out (again, note that mappings\n      //aren't caught by isReference)\n      if (\n        Codec.Ast.Utils.typeClass(baseExpression) !== \"struct\" ||\n        (Codec.Ast.Utils.isReference(node)\n          ? Codec.Ast.Utils.referenceType(baseExpression) !== \"storage\"\n          : !Codec.Ast.Utils.isMapping(node))\n      ) {\n        debug(\"Member case bailed out early\");\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      const allocations = yield select(data.current.allocations.state);\n      const currentAssignments = yield select(data.proc.assignments);\n\n      //but if it is a storage struct, we have to map the path as well\n      const path = fetchBasePath(\n        compilationId,\n        internalFor,\n        baseExpression,\n        currentAssignments,\n        allocations,\n        currentDepth,\n        modifierDepth,\n        inModifier\n      );\n      //this may fail, so let's check for that\n      if (path === null) {\n        debug(\"bailed out due to failed path\");\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      let slot = { path };\n\n      const compiler = yield select(data.current.compiler);\n      const structType = Codec.Ast.Import.definitionToType(\n        baseExpression,\n        compilationId,\n        compiler\n      );\n      const storageAllocations = yield select(data.info.allocations.storage);\n      const memberAllocations = storageAllocations[structType.id].members;\n      const scopes = yield select(data.current.scopes.inlined);\n      //members of a given struct have unique names so it's safe to look up the member by name\n      const memberName = scopes[node.referencedDeclaration].definition.name;\n      const memberAllocation = memberAllocations.find(\n        member => member.name === memberName\n      );\n\n      slot.offset = memberAllocation.pointer.range.from.slot.offset.clone();\n\n      debug(\"slot %o\", slot);\n      yield put(\n        actions.mapPathAndAssign(\n          address,\n          slot,\n          assignments,\n          Codec.Ast.Utils.typeIdentifier(node),\n          Codec.Ast.Utils.typeIdentifier(baseExpression)\n        )\n      );\n      break;\n    }\n\n    default:\n      if (node.id === undefined || node.typeDescriptions == undefined) {\n        break;\n      }\n\n      debug(\"decoding expression value %O\", node.typeDescriptions);\n      debug(\"default case\");\n      debug(\"currentDepth %d node.id %d\", currentDepth, node.id);\n\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          internalFor,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n      yield put(actions.assign(assignments));\n      break;\n  }\n}\n\nfunction* decodeMappingKeySaga(indexDefinition, keyDefinition) {\n  //something of a HACK -- cleans any out-of-range booleans\n  //resulting from the main mapping key decoding loop\n  const indexValue = yield* decodeMappingKeyCore(\n    indexDefinition,\n    keyDefinition\n  );\n  return indexValue ? Codec.Conversion.cleanBool(indexValue) : indexValue;\n}\n\nfunction* decodeMappingKeyCore(indexDefinition, keyDefinition) {\n  const scopes = yield select(data.current.scopes.inlined);\n  const compilationId = yield select(data.current.compilationId);\n  const internalFor = yield select(data.current.internalSourceFor); //should be null, but...\n  const currentAssignments = yield select(data.proc.assignments);\n  const currentDepth = yield select(data.current.functionDepth);\n  const modifierDepth = yield select(data.current.modifierDepth);\n  const inModifier = yield select(data.current.inModifier);\n\n  //why the loop? see the end of the block it heads for an explanatory\n  //comment\n  while (true) {\n    const indexId = indexDefinition.id;\n    //indices need to be identified by stackframe\n    const indexIdObj = {\n      compilationId,\n      internalFor,\n      astRef: indexId,\n      stackframe: currentDepth,\n      modifierDepth: inModifier ? modifierDepth : null\n    };\n    const fullIndexId = stableKeccak256(indexIdObj);\n\n    const indexReference = (currentAssignments[fullIndexId] || {}).ref;\n\n    if (Codec.Ast.Utils.isSimpleConstant(indexDefinition)) {\n      //while the main case is the next one, where we look for a prior\n      //assignment, we need this case (and need it first) for two reasons:\n      //1. some constant expressions (specifically, string and hex literals)\n      //aren't sourcemapped to and so won't have a prior assignment\n      //2. if the key type is bytesN but the expression is constant, the\n      //value will go on the stack *left*-padded instead of right-padded,\n      //so looking for a prior assignment will read the wrong value.\n      //so instead it's preferable to use the constant directly.\n      debug(\"about to decode simple literal\");\n      return yield* decode(\n        keyDefinition,\n        {\n          location: \"definition\",\n          definition: indexDefinition\n        },\n        compilationId\n      );\n    } else if (indexReference) {\n      //if a prior assignment is found\n      let splicedDefinition;\n      //in general, we want to decode using the key definition, not the index\n      //definition. however, the key definition may have the wrong location\n      //on it.  so, when applicable, we splice the index definition location\n      //onto the key definition location.\n      if (Codec.Ast.Utils.isReference(indexDefinition)) {\n        splicedDefinition = Codec.Ast.Utils.spliceLocation(\n          keyDefinition,\n          Codec.Ast.Utils.referenceType(indexDefinition)\n        );\n        //we could put code here to add on the \"_ptr\" ending when absent,\n        //but we presently ignore that ending, so we'll skip that\n      } else {\n        splicedDefinition = keyDefinition;\n      }\n      debug(\"about to decode\");\n      return yield* decode(splicedDefinition, indexReference, compilationId);\n    } else if (\n      indexDefinition.referencedDeclaration &&\n      scopes[indexDefinition.referencedDeclaration]\n    ) {\n      //there's one more reason we might have failed to decode it: it might be a\n      //constant state variable.  Unfortunately, we don't know how to decode all\n      //those at the moment, but we can handle the ones we do know how to decode.\n      //In the future hopefully we will decode all of them\n      debug(\"referencedDeclaration %d\", indexDefinition.referencedDeclaration);\n      let indexConstantDeclaration =\n        scopes[indexDefinition.referencedDeclaration].definition;\n      debug(\"indexConstantDeclaration %O\", indexConstantDeclaration);\n      if (indexConstantDeclaration.constant) {\n        let indexConstantDefinition = indexConstantDeclaration.value;\n        //next line filters out constants we don't know how to handle\n        if (Codec.Ast.Utils.isSimpleConstant(indexConstantDefinition)) {\n          debug(\"about to decode simple constant\");\n          return yield* decode(\n            keyDefinition,\n            {\n              location: \"definition\",\n              definition: indexConstantDeclaration.value\n            },\n            compilationId\n          );\n        } else {\n          return null; //can't decode; see below for more explanation\n        }\n      } else {\n        return null; //can't decode; see below for more explanation\n      }\n    }\n    //there's still one more reason we might have failed to decode it:\n    //certain (silent) type conversions aren't sourcemapped either.\n    //(thankfully, any type conversion that actually *does* something seems\n    //to be sourcemapped.)  So if we've failed to decode it, we try again\n    //with the argument of the type conversion, if it is one; we leave\n    //indexValue undefined so the loop will continue\n    //(note that this case is last for a reason; if this were earlier, it\n    //would catch *non*-silent type conversions, which we want to just read\n    //off the stack)\n    else if (indexDefinition.kind === \"typeConversion\") {\n      indexDefinition = indexDefinition.arguments[0];\n    }\n    //...also prior to 0.5.0, unary + was legal, which needs to be accounted\n    //for for the same reason\n    else if (\n      indexDefinition.nodeType === \"UnaryOperation\" &&\n      indexDefinition.operator === \"+\"\n    ) {\n      indexDefinition = indexDefinition.subExpression;\n    }\n    //otherwise, we've just totally failed to decode it, so we mark\n    //indexValue as null (as distinct from undefined) to indicate this.  In\n    //the future, we should be able to decode all mapping keys, but we're\n    //not quite there yet, sorry (because we can't yet handle all constant\n    //state variables)\n    else {\n      return null;\n    }\n    //now, as mentioned, retry in the typeConversion case\n    //(or unary + case)\n  }\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* recordAllocations() {\n  const contracts = yield select(data.views.contractAllocationInfo);\n  const referenceDeclarations = yield select(data.views.referenceDeclarations);\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const storageAllocations = Codec.Storage.Allocate.getStorageAllocations(\n    userDefinedTypes\n  );\n  const memoryAllocations = Codec.Memory.Allocate.getMemoryAllocations(\n    userDefinedTypes\n  );\n  const abiAllocations = Codec.AbiData.Allocate.getAbiAllocations(\n    userDefinedTypes\n  );\n  const calldataAllocations = Codec.AbiData.Allocate.getCalldataAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    abiAllocations\n  );\n  const returndataAllocations = Codec.AbiData.Allocate.getReturndataAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    abiAllocations\n  );\n  const stateAllocations = Codec.Storage.Allocate.getStateAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    storageAllocations\n  );\n  yield put(\n    actions.allocate(\n      storageAllocations,\n      memoryAllocations,\n      abiAllocations,\n      calldataAllocations,\n      returndataAllocations,\n      stateAllocations\n    )\n  );\n}\n\nfunction literalAssignments(\n  compilationId,\n  internalFor,\n  node,\n  stack,\n  currentDepth,\n  modifierDepth,\n  inModifier\n) {\n  let top = stack.length - 1;\n\n  let literal;\n  try {\n    literal = Codec.Stack.Read.readStack(\n      {\n        location: \"stack\",\n        from: top - Codec.Ast.Utils.stackSize(node) + 1,\n        to: top\n      },\n      {\n        stack,\n        storage: {} //irrelevant, but let's respect the type signature :)\n      }\n    );\n  } catch (error) {\n    literal = undefined; //not sure if this is right, but this is what would\n    //happen before, so I figure it's safe?\n  }\n\n  let assignment = makeAssignment(\n    {\n      compilationId,\n      internalFor,\n      astRef: node.id,\n      stackframe: currentDepth,\n      modifierDepth: inModifier ? modifierDepth : null\n    },\n    { location: \"stackliteral\", literal }\n  );\n\n  return { [assignment.id]: assignment };\n}\n\n//takes a parameter list as given in the AST\nfunction assignParameters(\n  compilationId,\n  internalFor,\n  parameters,\n  top,\n  functionDepth,\n  modifierDepth = 0,\n  forModifier = false\n) {\n  let reverseParameters = parameters.slice().reverse();\n  //reverse is in-place, so we use slice() to clone first\n  debug(\"reverseParameters %o\", parameters);\n\n  let currentPosition = top;\n  let assignments = {};\n\n  for (let parameter of reverseParameters) {\n    let words = Codec.Ast.Utils.stackSize(parameter);\n    let pointer = {\n      location: \"stack\",\n      from: currentPosition - words + 1,\n      to: currentPosition\n    };\n    let assignment = makeAssignment(\n      {\n        compilationId,\n        internalFor,\n        astRef: parameter.id,\n        stackframe: functionDepth,\n        modifierDepth: forModifier ? modifierDepth : null\n      },\n      pointer\n    );\n    assignments[assignment.id] = assignment;\n    currentPosition -= words;\n  }\n  return assignments;\n}\n\nfunction fetchBasePath(\n  compilationId,\n  internalFor,\n  baseNode,\n  currentAssignments,\n  allocations,\n  currentDepth,\n  modifierDepth,\n  inModifier\n) {\n  const fullId = stableKeccak256({\n    compilationId,\n    internalFor,\n    astRef: baseNode.id,\n    stackframe: currentDepth,\n    modifierDepth: inModifier ? modifierDepth : null\n  });\n  debug(\"astId: %d\", baseNode.id);\n  debug(\"stackframe: %d\", currentDepth);\n  debug(\"fullId: %s\", fullId);\n  debug(\"currentAssignments: %O\", currentAssignments);\n  //base expression is an expression, and so has a literal assigned to\n  //it (unless it doesn't, in which case we have to handle that case)\n  const baseAssignment = currentAssignments[fullId];\n  if (baseAssignment) {\n    const offset = Codec.Conversion.toBN(baseAssignment.ref.literal);\n    return { offset };\n  }\n  //if nothing was assigned to the base expression, we have a fallback we'll attempt:\n  //we'll check if it's a top-level state variable and look up its allocation if so.\n  const referencedId = baseNode.referencedDeclaration;\n  if (referencedId != undefined) {\n    //deliberate use of !=\n    const allocation = allocations[referencedId];\n    if (allocation && allocation.pointer.location === \"storage\") {\n      return allocation.pointer.range.from.slot;\n    }\n  }\n  //if that doesn't work either, give up\n  return null;\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"data\", saga);\n","export const START = \"SESSION_START\";\nexport function start(provider, txHash) {\n  return {\n    type: START,\n    provider,\n    txHash //OPTIONAL\n  };\n}\n\nexport const LOAD_TRANSACTION = \"SESSION_LOAD_TRANSACTION\";\nexport function loadTransaction(txHash) {\n  return {\n    type: LOAD_TRANSACTION,\n    txHash\n  };\n}\n\nexport const INTERRUPT = \"SESSION_INTERRUPT\";\nexport function interrupt() {\n  return { type: INTERRUPT };\n}\n\nexport const UNLOAD_TRANSACTION = \"SESSION_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n\nexport const READY = \"SESSION_READY\";\nexport function ready() {\n  return {\n    type: READY\n  };\n}\n\nexport const WAIT = \"SESSION_WAIT\";\nexport function wait() {\n  return {\n    type: WAIT\n  };\n}\n\nexport const ERROR = \"SESSION_ERROR\";\nexport function error(error) {\n  return {\n    type: ERROR,\n    error\n  };\n}\n\nexport const RECORD_CONTRACTS = \"SESSION_RECORD_CONTRACTS\";\nexport function recordContracts(contexts, sources) {\n  return {\n    type: RECORD_CONTRACTS,\n    contexts,\n    sources\n  };\n}\n\nexport const SAVE_TRANSACTION = \"SESSION_SAVE_TRANSACTION\";\nexport function saveTransaction(transaction) {\n  return {\n    type: SAVE_TRANSACTION,\n    transaction\n  };\n}\n\nexport const SAVE_RECEIPT = \"SESSION_SAVE_RECEIPT\";\nexport function saveReceipt(receipt) {\n  return {\n    type: SAVE_RECEIPT,\n    receipt\n  };\n}\n\nexport const SAVE_BLOCK = \"SESSION_SAVE_BLOCK\";\nexport function saveBlock(block) {\n  return {\n    type: SAVE_BLOCK,\n    block\n  };\n}\n\nexport const SET_LIGHT_MODE = \"SESSION_SET_LIGHT_MODE\";\nexport function setLightMode() {\n  return { type: SET_LIGHT_MODE };\n}\n\nexport const SET_FULL_MODE = \"SESSION_SET_FULL_MODE\";\nexport function setFullMode() {\n  return { type: SET_FULL_MODE };\n}\n\nexport const START_FULL_MODE = \"SESSION_START_FULL_MODE\";\nexport function startFullMode() {\n  return { type: START_FULL_MODE };\n}\n\nexport const ADD_COMPILATIONS = \"SESSION_ADD_COMPILATIONS\";\nexport function addCompilations(sources, contexts) {\n  return {\n    type: ADD_COMPILATIONS,\n    sources,\n    contexts\n  };\n}\n","module.exports = require(\"babel-runtime/core-js/object/values\");","module.exports = require(\"json-pointer\");","module.exports = require(\"bn.js\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport trace from \"lib/trace/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport solidity from \"lib/solidity/selectors\";\n\nimport jsonpointer from \"json-pointer\";\nimport zipWith from \"lodash.zipwith\";\nimport { popNWhere } from \"lib/helpers\";\nimport * as Codec from \"@truffle/codec\";\n\nconst identity = x => x;\n\nfunction generateReport(callstack, location, status, message) {\n  //step 1: shift everything over by 1 and recombine :)\n  let locations = callstack.map(frame => frame.calledFromLocation);\n  //remove initial null, add final location on end\n  locations.shift();\n  locations.push(location);\n  debug(\"locations: %O\", locations);\n  const names = callstack.map(\n    ({ functionName, contractName, address, type }) => ({\n      functionName,\n      contractName,\n      address,\n      type\n    })\n  );\n  debug(\"names: %O\", names);\n  let report = zipWith(locations, names, (location, nameInfo) => ({\n    ...nameInfo,\n    location\n  }));\n  //finally: set the status in the top frame\n  //and the message in the bottom\n  if (status !== null) {\n    report[report.length - 1].status = status;\n  }\n  if (message !== undefined) {\n    if (message.Error !== undefined) {\n      report[0].message = message.Error;\n    } else if (message.Panic !== undefined) {\n      report[0].panic = message.Panic;\n    } else if (message.custom !== undefined) {\n      report[0].custom = message.custom;\n    }\n  }\n  return report;\n}\n\nfunction createMultistepSelectors(stepSelector) {\n  return {\n    /**\n     * .location\n     */\n    location: {\n      /**\n       * .source\n       */\n      source: createLeaf([stepSelector.source], identity),\n      /**\n       * .sourceRange\n       */\n      sourceRange: createLeaf([stepSelector.sourceRange], identity),\n      /**\n       * .node\n       */\n      node: createLeaf([stepSelector.node], identity),\n      /**\n       * .pointer\n       */\n      pointer: createLeaf([stepSelector.pointer], identity)\n    },\n\n    /**\n     * .strippedLocation\n     */\n    strippedLocation: createLeaf(\n      [\"./location/source\", \"./location/sourceRange\", \"./location/node\"],\n      ({ id, sourcePath, internal }, sourceRange, node) => ({\n        source: { id, sourcePath, internal },\n        sourceRange,\n        node: node ? { id: node.id } : null\n      })\n    ),\n\n    /**\n     * .contractNode\n     * WARNING: ad-hoc selector only meant to be used\n     * when you're on a function node!\n     * should probably be replaced by something better;\n     * the data submodule handles these things a better way\n     */\n    contractNode: createLeaf(\n      [\"./location/source\", \"./location/pointer\"],\n      ({ ast }, pointer) =>\n        pointer\n          ? jsonpointer.get(\n              ast,\n              pointer.replace(/\\/nodes\\/\\d+$/, \"\") //cut off end\n            )\n          : ast\n    )\n  };\n}\n\nlet stacktrace = createSelectorTree({\n  /**\n   * stacktrace.state\n   */\n  state: state => state.stacktrace,\n\n  /**\n   * stacktrace.current\n   */\n  current: {\n    /**\n     * stacktrace.current.callstack\n     */\n    callstack: createLeaf([\"/state\"], state => state.proc.callstack),\n\n    /**\n     * stacktrace.current.returnCounter\n     */\n    returnCounter: createLeaf([\"/state\"], state => state.proc.returnCounter),\n\n    /**\n     * stacktrace.current.lastPosition\n     */\n    lastPosition: createLeaf([\"/state\"], state => state.proc.lastPosition),\n\n    /**\n     * stacktrace.current.innerReturnPosition\n     */\n    innerReturnPosition: createLeaf(\n      [\"/state\"],\n      state => state.proc.innerReturnPosition\n    ),\n\n    /**\n     * stacktrace.current.innerReturnStatus\n     */\n    innerReturnStatus: createLeaf(\n      [\"/state\"],\n      state => state.proc.innerReturnStatus\n    ),\n\n    /**\n     * stacktrace.current.innerErrorIndex\n     * Index of the most recent error (but not this)\n     */\n    innerErrorIndex: createLeaf(\n      [\"/state\"],\n      state => state.proc.innerErrorIndex\n    ),\n\n    ...createMultistepSelectors(solidity.current),\n\n    /**\n     * stacktrace.current.index\n     */\n    index: createLeaf([trace.index], identity),\n\n    /**\n     * stacktrace.current.updateIndex\n     * We only want to update the index if:\n     * 1. the return counter is 0 (we're not in the middle of an\n     * error already being thrown -- we want to keep it at the\n     * initial index for that error)\n     * 2. we're not on the last step (we don't want to accidentally\n     * save the final step as the last error, it would be confusing)\n     * 3. the return status is actually false\n     */\n    updateIndex: createLeaf(\n      [\"./returnCounter\", trace.stepsRemaining, \"./returnStatus\"],\n      (returnCounter, stepsRemaining, returnStatus) =>\n        returnCounter === 0 && stepsRemaining > 1 && !returnStatus\n    ),\n\n    /**\n     * stacktrace.current.willJumpIn\n     */\n    willJumpIn: createLeaf(\n      [solidity.current.willJump, solidity.current.jumpDirection],\n      (willJump, jumpDirection) => willJump && jumpDirection === \"i\"\n    ),\n\n    /**\n     * stacktrace.current.willJumpOut\n     */\n    willJumpOut: createLeaf(\n      [solidity.current.willJump, solidity.current.jumpDirection],\n      (willJump, jumpDirection) => willJump && jumpDirection === \"o\"\n    ),\n\n    /**\n     * stacktrace.current.willCall\n     * note: includes creations!\n     */\n    willCall: createLeaf([solidity.current.willCall], identity),\n\n    /**\n     * stacktrace.current.context\n     */\n    context: createLeaf([evm.current.context], identity),\n\n    /**\n     * stacktrace.current.callContext\n     */\n    callContext: createLeaf([evm.current.step.callContext], identity),\n\n    /**\n     * stacktrace.current.willReturn\n     */\n    willReturn: createLeaf([solidity.current.willReturn], identity),\n\n    /**\n     * stacktrace.current.returnStatus\n     */\n    returnStatus: createLeaf([evm.current.step.returnStatus], identity),\n\n    /**\n     * stacktrace.current.address\n     * Initial call can't be a delegate, so we just use the storage address\n     * (thus allowing us to handle both calls & creates in one)\n     */\n    address: createLeaf([evm.current.call], call => call.storageAddress),\n\n    /**\n     * stacktrace.current.callAddress\n     *\n     * Covers both calls and creates\n     * NOTE: for this selector, we treat delegates just like any other call!\n     * we want to report the *code* address here, not the storage address\n     * (exception: for creates we report the storage address, as that's where\n     * the code *will* live)\n     */\n    callAddress: createLeaf(\n      [\n        evm.current.step.isCall,\n        evm.current.step.isCreate,\n        evm.current.step.callAddress,\n        evm.current.step.createdAddress\n      ],\n      (isCall, isCreate, callAddress, createdAddress) => {\n        if (isCall) {\n          return callAddress;\n        } else if (isCreate) {\n          if (createdAddress !== Codec.Evm.Utils.ZERO_ADDRESS) {\n            return createdAddress;\n          } else {\n            return undefined; //if created address appears to be 0, omit it\n          }\n        } else {\n          return null; //I guess??\n        }\n      }\n    ),\n\n    /**\n     * stacktrace.current.revertString\n     * Crudely decodes the current revert string, OR the current panic,\n     * *or* an indication of a custom error (but not what, we can't do\n     * that here)\n     * Returns { Error: <string> } or { Panic: <BN> } or { custom: true }\n     * (or undefined)\n     * Not meant to account for crazy things, just there to produce\n     * a simple string or number.\n     * NOTE: if panic code is overlarge, we'll use -1 instead to indicate\n     * an unknown type of panic.\n     */\n    revertString: createLeaf(\n      [evm.current.step.returnValue],\n      rawRevertMessage => {\n        let revertDecodings = Codec.decodeRevert(\n          Codec.Conversion.toBytes(rawRevertMessage)\n        );\n        if (\n          revertDecodings.length === 1 &&\n          revertDecodings[0].kind === \"revert\"\n        ) {\n          const decoding = revertDecodings[0];\n          switch (decoding.abi.name) {\n            case \"Error\":\n              const revertStringInfo = decoding.arguments[0].value.value;\n              switch (revertStringInfo.kind) {\n                case \"valid\":\n                  return { Error: revertStringInfo.asString };\n                case \"malformed\":\n                  //turn into a JS string while smoothing over invalid UTF-8\n                  //slice 2 to remove 0x prefix\n                  return {\n                    Error: Buffer.from(\n                      revertStringInfo.asHex.slice(2),\n                      \"hex\"\n                    ).toString()\n                  };\n              }\n            case \"Panic\":\n              const panicCode = decoding.arguments[0].value.value.asBN;\n              return { Panic: panicCode };\n            default:\n              return undefined;\n          }\n        } else if (revertDecodings.length === 0) {\n          return { custom: true };\n        } else {\n          return undefined;\n        }\n      }\n    ),\n\n    /**\n     * stacktrace.current.positionWillChange\n     * note: we disregard internal sources here!\n     */\n    positionWillChange: createLeaf(\n      [\"/next/location\", \"/current/location\", \"./lastPosition\"],\n      (nextLocation, currentLocation, lastLocation) => {\n        let oldLocation =\n          currentLocation.source.id !== undefined &&\n          !currentLocation.source.internal\n            ? currentLocation\n            : lastLocation;\n        return (\n          Boolean(oldLocation) && //if there's no current or last position, we don't need this check\n          Boolean(nextLocation.source) &&\n          nextLocation.source.id !== undefined && //if next location is unmapped, we consider ourselves to have not moved\n          !nextLocation.source.internal && //similarly if it's internal\n          (nextLocation.source.id !== oldLocation.source.id ||\n            nextLocation.sourceRange.start !== oldLocation.sourceRange.start ||\n            nextLocation.sourceRange.length !== oldLocation.sourceRange.length)\n        );\n      }\n    ),\n\n    /**\n     * stacktrace.current.finalReport\n     * Contains the report object for outside consumption.\n     * Still needs to be processed into a string, mind you.\n     */\n    finalReport: createLeaf(\n      [\n        \"./callstack\",\n        \"./innerReturnPosition\",\n        \"./innerReturnStatus\",\n        \"./revertString\"\n      ],\n      generateReport\n    ),\n\n    /**\n     * stacktrace.current.report\n     * Similar to stacktrace.current.report, but meant for use as at\n     * an intermediate point instead of at the end (it reflects how things\n     * actually currently are rather than taking into account exited\n     * stackframes that caused the revert)\n     */\n    report: createLeaf(\n      [\n        \"./callstack\",\n        \"./returnCounter\",\n        \"./lastPosition\",\n        \"/current/strippedLocation\"\n      ],\n      (callstack, returnCounter, lastPosition, currentLocation) =>\n        generateReport(\n          popNWhere(\n            callstack,\n            returnCounter,\n            frame => frame.type === \"external\"\n          ),\n          currentLocation || lastPosition,\n          null,\n          undefined\n        )\n    )\n  },\n\n  /**\n   * stacktrace.next\n   */\n  next: {\n    ...createMultistepSelectors(solidity.next)\n  }\n});\n\nexport default stacktrace;\n","module.exports = require(\"babel-runtime/helpers/asyncToGenerator\");","export const ADVANCE = \"CONTROLLER_ADVANCE\";\nexport function advance(count) {\n  return { type: ADVANCE, count };\n}\n\nexport const STEP_NEXT = \"CONTROLLER_STEP_NEXT\";\nexport function stepNext() {\n  return { type: STEP_NEXT };\n}\n\nexport const STEP_OVER = \"CONTROLLER_STEP_OVER\";\nexport function stepOver() {\n  return { type: STEP_OVER };\n}\n\nexport const STEP_INTO = \"CONTROLLER_STEP_INTO\";\nexport function stepInto() {\n  return { type: STEP_INTO };\n}\n\nexport const STEP_OUT = \"CONTROLLER_STEP_OUT\";\nexport function stepOut() {\n  return { type: STEP_OUT };\n}\n\nexport const RESET = \"CONTROLLER_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const INTERRUPT = \"CONTROLLER_INTERRUPT\";\nexport function interrupt() {\n  return { type: INTERRUPT };\n}\n\nexport const CONTINUE = \"CONTROLLER_CONTINUE\";\nexport function continueUntilBreakpoint(breakpoints) {\n  //\"continue\" is not a legal name\n  return {\n    type: CONTINUE,\n    breakpoints\n  };\n}\n\nexport const ADD_BREAKPOINT = \"CONTROLLER_ADD_BREAKPOINT\";\nexport function addBreakpoint(breakpoint) {\n  return {\n    type: ADD_BREAKPOINT,\n    breakpoint\n  };\n}\n\nexport const REMOVE_BREAKPOINT = \"CONTROLLER_REMOVE_BREAKPOINT\";\nexport function removeBreakpoint(breakpoint) {\n  return {\n    type: REMOVE_BREAKPOINT,\n    breakpoint\n  };\n}\n\nexport const REMOVE_ALL_BREAKPOINTS = \"CONTROLLER_REMOVE_ALL_BREAKPOINTS\";\nexport function removeAllBreakpoints() {\n  return {\n    type: REMOVE_ALL_BREAKPOINTS\n  };\n}\n\nexport const SET_INTERNAL_STEPPING = \"CONTROLLER_SET_INTERNAL_STEPPING\";\nexport function setInternalStepping(status) {\n  return {\n    type: SET_INTERNAL_STEPPING,\n    status\n  }\n}\n\nexport const START_STEPPING = \"CONTROLLER_START_STEPPING\";\nexport function startStepping() {\n  return {\n    type: START_STEPPING\n  };\n}\n\nexport const DONE_STEPPING = \"CONTROLLER_DONE_STEPPING\";\nexport function doneStepping() {\n  return {\n    type: DONE_STEPPING\n  };\n}\n","module.exports = require(\"babel-runtime/core-js/object/keys\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:txlog:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport data from \"lib/data/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport trace from \"lib/trace/selectors\";\nimport solidity from \"lib/solidity/selectors\";\n\nimport * as Codec from \"@truffle/codec\";\n\nconst identity = x => x;\n\nfunction createMultistepSelectors(stepSelector) {\n  return {\n    /**\n     * .source\n     * HACK: see notes in solidity selectors about cases\n     * where this won't work\n     */\n    source: createLeaf([stepSelector.source], identity),\n\n    /**\n     * .astNode\n     * HACK: see notes in solidity selectors about cases\n     * where this won't work\n     */\n    astNode: createLeaf([stepSelector.node], identity),\n\n    /**\n     * .inInternalSourceOrYul\n     */\n    inInternalSourceOrYul: createLeaf(\n      [\"./source\", \"./astNode\"],\n      (source, node) =>\n        !node || source.internal || node.nodeType.startsWith(\"Yul\")\n        || node.nodeType === \"ContractDefinition\" //HACK\n        //HACK: this last case is to handle a Solidity bug where code that\n        //should be unmapped instead gets mapped to the to the contract\n        //definition node.  I'm worried that this might screw things up for\n        //optimized code, but... we'll see?\n    )\n  };\n}\n\nlet txlog = createSelectorTree({\n  /**\n   * txlog.state\n   */\n  state: state => state.txlog,\n\n  /**\n   * txlog.proc\n   */\n  proc: {\n    /**\n     * txlog.proc.transactionLog\n     */\n    transactionLog: createLeaf([\"/state\"], state => state.proc.transactionLog.byPointer),\n  },\n\n  /**\n   * txlog.transaction\n   */\n  transaction: {\n    /**\n     * txlog.transaction.origin\n     */\n    origin: createLeaf([evm.transaction.globals.tx], tx => tx.origin),\n\n    /**\n     * txlog.transaction.initialCall\n     */\n    initialCall: createLeaf([\"/state\"], state => state.transaction.initialCall),\n\n    /**\n     * txlog.transaction.absorbFirstInternalCall\n     */\n    absorbFirstInternalCall: createLeaf(\n      [solidity.transaction.bottomStackframeRequiresPhantomFrame],\n      identity\n    )\n  },\n\n  /**\n   * txlog.current\n   */\n  current: {\n    ...createMultistepSelectors(solidity.current),\n\n    /**\n     * txlog.current.state\n     */\n    state: createLeaf([evm.current.state], identity),\n\n    /**\n     * txlog.current.pointer\n     * NOTE: transaction log pointer; NOT the AST pointer!\n     */\n    pointer: createLeaf([\"/state\"], state => state.proc.currentNodePointer),\n\n    /**\n     * txlog.current.pointerStack\n     */\n    pointerStack: createLeaf([\"/state\"], state => state.proc.pointerStack),\n\n    /**\n     * txlog.current.node\n     * NOTE: transaction log node; NOT the AST node!\n     */\n    node: createLeaf(\n      [\"./pointer\", \"/proc/transactionLog\"],\n      (pointer, log) => log[pointer]\n    ),\n\n    /**\n     * txlog.current.waitingForFunctionDefinition\n     * This selector indicates whether there's a call (internal or external)\n     * that is waiting to have its function definition identified when we hit\n     * a function definition node.\n     */\n    waitingForFunctionDefinition: createLeaf(\n      [\"./node\"],\n      node =>\n        (node.type === \"callinternal\" ||\n          node.type === \"callexternal\") &&\n        node.waitingForFunctionDefinition\n    ),\n\n    /**\n     * txlog.current.waitingForInternalCallToAbsorb\n     */\n    waitingForInternalCallToAbsorb: createLeaf(\n      [\"./node\"],\n      node =>\n        node.type === \"callexternal\" &&\n        node.absorbNextInternalCall\n    ),\n\n    /**\n     * txlog.current.nextCallPointer\n     * the pointer where a new call will be added\n     */\n    nextCallPointer: createLeaf(\n      [\"./pointer\", \"./node\"],\n      (pointer, node) => `${pointer}/actions/${node.actions.length}`\n    ),\n\n    /**\n     * txlog.current.internalReturnPointer\n     * the pointer where we'll end up after an internal return\n     * (if we're on an internal call, it returns; if we're not,\n     * we stay put and just absorb the info)\n     */\n    internalReturnPointer: createLeaf(\n      [\"./pointer\", \"./node\"],\n      (pointer, node) =>\n        node.type === \"callinternal\"\n          ? pointer.replace(/\\/actions\\/\\d+$/, \"\")\n          : pointer\n    ),\n\n    /**\n     * txlog.current.externalReturnPointer\n     * the pointer where we'll end up after an external return\n     * (take the top stack entry, then go up one more)\n     * (there should always be something on the stack when this\n     * selector is used)\n     */\n    externalReturnPointer: createLeaf(\n      [\"./pointerStack\"],\n      stack => stack[stack.length - 1].replace(/\\/actions\\/\\d+$/, \"\")\n    ),\n\n    /**\n     * txlog.current.context\n     * Note we use data context, not evm context\n     * (i.e. decoder context, not debugger context)\n     */\n    context: createLeaf([data.current.context], identity),\n\n    /**\n     * txlog.current.call\n     */\n    call: createLeaf([evm.current.call], identity),\n\n    /**\n     * txlog.current.contract\n     */\n    contract: createLeaf([data.current.contract], identity),\n\n    /**\n     * txlog.current.isSourceRangeFinal\n     */\n    isSourceRangeFinal: createLeaf(\n      [solidity.current.isSourceRangeFinal],\n      identity\n    ),\n\n    /**\n     * txlog.current.onFunctionDefinition\n     */\n    onFunctionDefinition: createLeaf(\n      [\"./astNode\", \"./isSourceRangeFinal\", \"/next/inInternalSourceOrYul\", trace.stepsRemaining],\n      (node, ready, isNextInternal, stepsRemaining) =>\n        (ready || stepsRemaining <= 2) && //HACK: see below\n        node &&\n        node.nodeType === \"FunctionDefinition\" &&\n        !isNextInternal //need to make sure we're not just jumping to a generated source or unmapped code\n        //hack above: the last step doesn't get processed, so...\n    ),\n\n    /**\n     * txlog.current.currentFunctionIsAsExpected\n     *\n     * Does the function we're currently in according to the AST,\n     * match the function we're currently in according to the txlog?\n     * (if we're in a modifier we'll ignore this check)\n     */\n    currentFunctionIsAsExpected: createLeaf(\n      [\"./node\", data.current.function, data.current.contract],\n      (txlogNode, currentFunction, contractNode) =>\n      currentFunction && \n      (\n        currentFunction.nodeType === \"ContractDefinition\" ||\n        currentFunction.nodeType === \"ModifierDefinition\" ||\n        (\n          currentFunction.nodeType === \"FunctionDefinition\" &&\n          currentFunction.name === txlogNode.functionName &&\n          (\n            txlogNode.kind === \"callexternal\" ||\n            (contractNode && contractNode.name === txlogNode.contractName)\n          )\n        )\n      )\n    ),\n\n    /**\n     * txlog.current.compilationId\n     */\n    compilationId: createLeaf([data.current.compilationId], identity),\n\n    /**\n     * txlog.current.isJump\n     */\n    isJump: createLeaf([evm.current.step.isJump], identity),\n\n    /**\n     * txlog.current.jumpDirection\n     */\n    jumpDirection: createLeaf([solidity.current.jumpDirection], identity),\n\n    /**\n     * txlog.current.isCall\n     */\n    isCall: createLeaf([evm.current.step.isCall], identity),\n\n    /**\n     * txlog.current.isDelegateCallBroad\n     */\n    isDelegateCallBroad: createLeaf(\n      [evm.current.step.isDelegateCallBroad],\n      identity\n    ),\n\n    /**\n     * txlog.current.isCreate\n     */\n    isCreate: createLeaf([evm.current.step.isCreate], identity),\n\n    /**\n     * txlog.current.isInstantCallOrCreate\n     */\n    isInstantCallOrCreate: createLeaf(\n      [evm.current.step.isInstantCallOrCreate],\n      identity\n    ),\n\n    /**\n     * txlog.current.isHalting\n     */\n    isHalting: createLeaf([evm.current.step.isHalting], identity),\n\n    /**\n     * txlog.current.returnStatus\n     */\n    returnStatus: createLeaf([evm.current.step.returnStatus], identity),\n\n    /**\n     * txlog.current.callValue\n     */\n    callValue: createLeaf([evm.current.step.callValue], identity),\n\n    /**\n     * txlog.current.callAddress\n     */\n    callAddress: createLeaf([evm.current.step.callAddress], identity),\n\n    /**\n     * txlog.current.callContext\n     * note we make sure to use data, not evm, context!\n     * (i.e. decoder context, not debugger context)\n     */\n    callContext: createLeaf([data.current.callContext], identity),\n\n    /**\n     * txlog.current.absorbNextInternalCall\n     */\n    absorbNextInternalCall: createLeaf(\n      [solidity.current.callRequiresPhantomFrame],\n      identity\n    ),\n\n    /**\n     * txlog.current.callData\n     */\n    callData: createLeaf([evm.current.step.callData], identity),\n\n    /**\n     * txlog.current.createBinary\n     */\n    createBinary: createLeaf([evm.current.step.createBinary], identity),\n\n    /**\n     * txlog.current.createValue\n     */\n    createValue: createLeaf([evm.current.step.createValue], identity),\n\n    /**\n     * txlog.current.createdAddress\n     */\n    createdAddress: createLeaf([evm.current.step.createdAddress], identity),\n\n    /**\n     * txlog.current.salt\n     */\n    salt: createLeaf([evm.current.step.salt], identity),\n\n    /**\n     * txlog.current.isSelfDestruct\n     */\n    isSelfDestruct: createLeaf([evm.current.step.isSelfDestruct], identity),\n\n    /**\n     * txlog.current.beneficiary\n     */\n    beneficiary: createLeaf([evm.current.step.beneficiary], identity),\n\n    /**\n     * txlog.current.returnData\n     */\n    returnData: createLeaf([evm.current.step.returnValue], identity),\n\n    /**\n     * txlog.current.inputParameterAllocations\n     */\n    inputParameterAllocations: createLeaf(\n      [\"./astNode\", \"./state\"],\n      (functionDefinition, { stack }) => {\n        if (\n          !functionDefinition ||\n          functionDefinition.nodeType !== \"FunctionDefinition\"\n        ) {\n          return null;\n        }\n        return locateParameters(\n          functionDefinition.parameters.parameters,\n          stack.length - 1\n        );\n      }\n    ),\n\n    /**\n     * txlog.current.outputParameterAllocations\n     */\n    outputParameterAllocations: createLeaf(\n      [\"./astNode\", \"./state\"],\n      (functionDefinition, { stack }) => {\n        if (\n          !functionDefinition ||\n          functionDefinition.nodeType !== \"FunctionDefinition\"\n        ) {\n          return null;\n        }\n        //when this selector is invoked, we're on the jump out step, so the\n        //top element of the stack is the return address; we need to skip past that\n        return locateParameters(\n          functionDefinition.returnParameters.parameters,\n          stack.length - 2\n        );\n      }\n    )\n  },\n\n  /**\n   * txlog.next\n   */\n  next: {\n    ...createMultistepSelectors(solidity.next)\n  },\n\n  /**\n   * txlog.views\n   */\n  views: {\n    /**\n     * txlog.views.transactionLog\n     * contains the actual transformed transaction log ready for use!\n     */\n    transactionLog: createLeaf(\n      [\"/proc/transactionLog\"],\n      log => {\n        const tie = node =>\n          node.actions\n            ? {\n              ...node,\n              actions: node.actions.map(\n                pointer => tie(log[pointer])\n              )\n            }\n            : node;\n        return tie(log[\"\"]); //\"\" is always the root node\n      }\n    )\n  }\n\n});\n\nfunction locateParameters(parameters, top) {\n  const reverseParameters = parameters.slice().reverse();\n  //note we clone before reversing because reverse() is in place\n\n  let results = [];\n  let currentPosition = top;\n  for (let parameter of reverseParameters) {\n    const words = Codec.Ast.Utils.stackSize(parameter);\n    const pointer = {\n      location: \"stack\",\n      from: currentPosition - words + 1,\n      to: currentPosition\n    };\n\n    results.unshift({\n      name: parameter.name ? parameter.name : undefined, //replace \"\" with undefined\n      definition: parameter,\n      pointer\n    });\n    currentPosition -= words;\n  }\n  return results;\n}\n\nexport default txlog;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport evm from \"lib/evm/selectors\";\nimport trace from \"lib/trace/selectors\";\nimport solidity from \"lib/solidity/selectors\";\n\nconst session = createSelectorTree({\n  /*\n   * session.state\n   */\n  state: state => state.session,\n\n  /**\n   * session.info\n   */\n  info: {\n    /**\n     * session.info.affectedInstances\n     * NOTE: this really belongs in session.transaction,\n     * but that would be a breaking change\n     */\n    affectedInstances: createLeaf(\n      [\n        evm.transaction.affectedInstances,\n        evm.info.contexts,\n        solidity.info.sources\n      ],\n\n      (instances, contexts, sources) =>\n        Object.assign(\n          {},\n          ...Object.entries(instances).map(\n            ([\n              address,\n              {\n                context: contextId,\n                binary,\n                creationBinary,\n                creationContext: creationContextId\n              }\n            ]) => {\n              debug(\"instances %O\", instances);\n              debug(\"contexts %O\", contexts);\n              let context = contexts[contextId];\n              if (!context) {\n                return { [address]: { binary } };\n              }\n              let { contractName, compilationId, primarySource } = context;\n\n              debug(\"primarySource: %o\", primarySource);\n              debug(\"compilationId: %s\", compilationId);\n              debug(\"sources: %o\", sources);\n\n              let source =\n                primarySource !== undefined // note this is an index, not an ID\n                  ? sources.byCompilationId[compilationId].byIndex[\n                      primarySource\n                    ]\n                  : undefined;\n\n              let constructorArgs;\n              if (creationBinary !== undefined) {\n                let creationContext = contexts[creationContextId];\n                if (creationContext) {\n                  //slice off the bytecode part of the constructor to leave the arguments\n                  constructorArgs = creationBinary.slice(\n                    creationContext.binary.length\n                  );\n                }\n              }\n\n              return {\n                [address]: {\n                  contractName,\n                  source,\n                  binary,\n                  constructorArgs //will be defined only if created by this tx\n                }\n              };\n            }\n          )\n        )\n    )\n  },\n\n  /**\n   * session.transaction (namespace)\n   */\n  transaction: {\n    /**\n     * session.transaction (selector)\n     * contains the web3 transaction object\n     */\n    _: createLeaf([\"/state\"], state => state.transaction),\n\n    /**\n     * session.transaction.receipt\n     * contains the web3 receipt object\n     */\n    receipt: createLeaf([\"/state\"], state => state.receipt),\n\n    /**\n     * session.transaction.block\n     * contains the web3 block object\n     */\n    block: createLeaf([\"/state\"], state => state.block)\n  },\n\n  /**\n   * session.status (namespace)\n   */\n  status: {\n    /**\n     * session.status.readyOrError\n     */\n    readyOrError: createLeaf([\"/state\"], state => state.ready),\n\n    /**\n     * session.status.ready\n     */\n    ready: createLeaf(\n      [\"./readyOrError\", \"./isError\"],\n      (readyOrError, error) => readyOrError && !error\n    ),\n\n    /**\n     * session.status.waiting\n     */\n    waiting: createLeaf([\"/state\"], state => !state.ready),\n\n    /**\n     * session.status.error\n     */\n    error: createLeaf([\"/state\"], state => state.lastLoadingError),\n\n    /**\n     * session.status.isError\n     */\n    isError: createLeaf([\"./error\"], error => error !== null),\n\n    /**\n     * session.status.success\n     */\n    success: createLeaf([\"./error\"], error => error === null),\n\n    /**\n     * session.status.errored\n     */\n    errored: createLeaf(\n      [\"./readyOrError\", \"./isError\"],\n      (readyOrError, error) => readyOrError && error\n    ),\n\n    /**\n     * session.status.loaded\n     */\n    loaded: createLeaf([trace.loaded], loaded => loaded),\n\n    /**\n     * session.status.lightMode\n     */\n    lightMode: createLeaf([\"/state\"], state => state.lightMode)\n  }\n});\n\nexport default session;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName, keccak256 } from \"lib/helpers\";\n\nimport { TICK } from \"lib/trace/actions\";\nimport * as actions from \"../actions\";\n\nimport evm from \"../selectors\";\n\nimport * as trace from \"lib/trace/sagas\";\n\n/**\n * Adds EVM bytecode context\n *\n * @return {string} ID (0x-prefixed keccak of binary)\n */\nexport function* addContext(context) {\n  //get context hash if context doesn't already have it\n  const contextHash =\n    context.context || keccak256({ type: \"string\", value: context.binary });\n  //NOTE: we take hash as *string*, not as bytes, because the binary may\n  //contain link references!\n\n  debug(\"context %O\", context);\n  yield put(actions.addContext({ ...context, context: contextHash }));\n\n  return contextHash;\n}\n\n/**\n * Adds to codex known deployed instance of binary at address\n * (not to list of affected instances)\n *\n * @param {string} binary - may be undefined (e.g. precompiles)\n * @return {string} ID (0x-prefixed keccak of binary)\n */\nexport function* addInstance(address, binary) {\n  const search = yield select(evm.info.binaries.search);\n  const context = search(binary);\n\n  //now, whether we needed a new context or not, add the instance\n  yield put(actions.addInstance(address, context, binary));\n\n  return context;\n}\n\n/**\n * Adds known deployed instance of binary at address\n * to list of affected instances, *not* to codex\n *\n * creationBinary may also be specified\n *\n * @param {string} binary - may be undefined (e.g. precompiles)\n * @return {string} ID (0x-prefixed keccak of binary)\n */\nexport function* addAffectedInstance(address, binary, creationBinary) {\n  const search = yield select(evm.info.binaries.search);\n  const context = search(binary);\n  const creationContext = creationBinary ? search(creationBinary) : null;\n\n  //now, whether we needed a new context or not, add the instance\n  //note that these last two arguments may be undefined/null\n  yield put(\n    actions.addAffectedInstance(\n      address,\n      context,\n      binary,\n      creationBinary,\n      creationContext\n    )\n  );\n\n  return context;\n}\n\n//goes through all instances (codex & affected) and re-adds them with their new\n//context (used if new contexts have been added -- something\n//that currently only happens when adding external compilations)\nexport function* refreshInstances() {\n  const instances = yield select(evm.current.codex.instances);\n  const affectedInstances = yield select(evm.transaction.affectedInstances);\n  for (let [address, { binary }] of Object.entries(instances)) {\n    const search = yield select(evm.info.binaries.search);\n    const context = search(binary);\n    yield put(actions.addInstance(address, context, binary));\n  }\n  for (let [address, { binary, creationBinary }] of Object.entries(\n    affectedInstances\n  )) {\n    const search = yield select(evm.info.binaries.search);\n    const context = search(binary);\n    const creationContext = creationBinary ? search(creationBinary) : null;\n    yield put(\n      actions.addAffectedInstance(\n        address,\n        context,\n        binary,\n        creationBinary,\n        creationContext\n      )\n    );\n  }\n}\n\nexport function* begin({\n  address,\n  binary,\n  data,\n  storageAddress,\n  status,\n  sender,\n  value,\n  gasprice,\n  block\n}) {\n  yield put(actions.saveGlobals(sender, gasprice, block));\n  yield put(actions.saveStatus(status));\n  debug(\"codex: %O\", yield select(evm.current.codex));\n  if (address) {\n    yield put(actions.call(address, data, storageAddress, sender, value));\n  } else {\n    yield put(actions.create(binary, storageAddress, sender, value));\n  }\n}\n\nfunction* tickSaga() {\n  debug(\"got TICK\");\n\n  yield* callstackAndCodexSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\n//NOTE: We don't account here for multiple simultaneous returns.\n//Such a case is *vanishingly* unlikely to come up in real code\n//so it's simply not worth the trouble.  Such a case will screw\n//up the debugger pretty good as a result.\n//(...but I might go back and do it later. :P )\n\nexport function* callstackAndCodexSaga() {\n  if (yield select(evm.current.step.isExceptionalHalting)) {\n    //let's handle this case first so we can be sure everything else is *not*\n    //an exceptional halt\n    debug(\"exceptional halt!\");\n\n    yield put(actions.fail());\n  } else if (yield select(evm.current.step.isInstantCallOrCreate)) {\n    // if there is no binary (e.g. for precompiles or externally owned\n    // accounts), or if the call fails instantly (callstack overflow or not\n    // enough ether), there will be no trace steps for the called code, and so\n    // we shouldn't tell the debugger that we're entering another execution\n    // context\n    // (so we do nothing)\n  } else if (yield select(evm.current.step.isCall)) {\n    debug(\"got call\");\n\n    let address = yield select(evm.current.step.callAddress);\n    let data = yield select(evm.current.step.callData);\n\n    debug(\"calling address %s\", address);\n\n    if (yield select(evm.current.step.isDelegateCallStrict)) {\n      //if delegating, leave storageAddress, sender, and value the same\n      let { storageAddress, sender, value } = yield select(evm.current.call);\n      yield put(actions.call(address, data, storageAddress, sender, value));\n    } else {\n      //this branch covers CALL, CALLCODE, and STATICCALL\n      let currentCall = yield select(evm.current.call);\n      let storageAddress = (yield select(evm.current.step.isDelegateCallBroad))\n        ? currentCall.storageAddress //for CALLCODE\n        : address;\n      let sender = currentCall.storageAddress; //not the code address!\n      let value = yield select(evm.current.step.callValue); //0 if static\n      yield put(actions.call(address, data, storageAddress, sender, value));\n    }\n  } else if (yield select(evm.current.step.isCreate)) {\n    debug(\"got create\");\n    let binary = yield select(evm.current.step.createBinary);\n    let createdAddress = yield select(evm.current.step.createdAddress);\n    let value = yield select(evm.current.step.createValue);\n    let sender = (yield select(evm.current.call)).storageAddress;\n    //not the code address!\n\n    yield put(actions.create(binary, createdAddress, sender, value));\n    //as above, storageAddress handles when calling from a creation call\n  } else if (yield select(evm.current.step.isNormalHalting)) {\n    debug(\"got return\");\n\n    let { binary, storageAddress } = yield select(evm.current.call);\n\n    if (binary) {\n      //if we're returning from a successful creation call, let's log the\n      //result\n      let returnedBinary = yield select(evm.current.step.returnValue);\n      let search = yield select(evm.info.binaries.search);\n      let returnedContext = search(returnedBinary);\n      yield put(\n        actions.returnCreate(storageAddress, returnedBinary, returnedContext)\n      );\n    } else {\n      yield put(actions.returnCall());\n    }\n  } else if (yield select(evm.current.step.isStore)) {\n    let storageAddress = (yield select(evm.current.call)).storageAddress;\n    let slot = yield select(evm.current.step.storageAffected);\n    let storedValue = yield select(evm.current.step.valueStored);\n    yield put(actions.store(storageAddress, slot, storedValue));\n  } else if (yield select(evm.current.step.isLoad)) {\n    let storageAddress = (yield select(evm.current.call)).storageAddress;\n    let slot = yield select(evm.current.step.storageAffected);\n    let loadedValue = yield select(evm.current.step.valueLoaded);\n    yield put(actions.load(storageAddress, slot, loadedValue));\n  }\n}\n\nexport function* reset() {\n  const initialCall = yield select(evm.transaction.initialCall);\n  yield put(actions.reset());\n  yield put(initialCall);\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"evm\", saga);\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:selectors\"); //eslint-disable-line no-unused-vars\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport { isSkippedNodeType } from \"lib/helpers\";\n\nimport evm from \"lib/evm/selectors\";\nimport solidity from \"lib/solidity/selectors\";\nimport data from \"lib/data/selectors\";\nimport trace from \"lib/trace/selectors\";\n\n/**\n * @private\n */\nconst identity = x => x;\n\nfunction anyNonSkippedInRange(\n  findOverlappingRange,\n  node,\n  sourceStart,\n  sourceLength\n) {\n  let sourceEnd = sourceStart + sourceLength;\n  return findOverlappingRange(sourceStart, sourceLength).some(\n    ({ range, node }) =>\n      isOldStyleAssembly(node) ||\n      (sourceStart <= range[0] && //we want to go by starting line\n        range[0] < sourceEnd &&\n        !isSkippedNodeType(node))\n    //NOTE: this doesn't actually catch everything skipped!  But doing better\n    //is hard\n  );\n}\n\n//catches InlineAssembly nodes from before 0.6.0.\n//We want to be able to place breakpoints if something merely *overlaps*\n//one of these, because, well, we can't really look inside and do better.\nfunction isOldStyleAssembly(node) {\n  return node.nodeType === \"InlineAssembly\" && !node.AST;\n}\n\n/**\n * controller\n */\nconst controller = createSelectorTree({\n  /**\n   * controller.state\n   */\n  state: state => state.controller,\n  /**\n   * controller.current\n   */\n  current: {\n    /**\n     * controller.current.functionDepth\n     */\n    functionDepth: createLeaf([solidity.current.functionDepth], identity),\n\n    /**\n     * controller.current.executionContext\n     */\n    executionContext: createLeaf([evm.current.call], identity),\n\n    /**\n     * controller.current.willJump\n     */\n    willJump: createLeaf([evm.current.step.isJump], identity),\n\n    /**\n     * controller.current.location\n     */\n    location: {\n      /**\n       * controller.current.location.sourceRange\n       */\n      sourceRange: createLeaf(\n        [solidity.current.sourceRange, \"/current/trace/loaded\"],\n        (range, loaded) => (loaded ? range : null)\n      ),\n\n      /**\n       * controller.current.location.source\n       */\n      source: createLeaf(\n        [solidity.current.source, \"/current/trace/loaded\"],\n        (source, loaded) => (loaded ? source : null)\n      ),\n\n      /**\n       * controller.current.location.node\n       */\n      node: createLeaf(\n        [solidity.current.node, \"/current/trace/loaded\"],\n        (node, loaded) => (loaded ? node : null)\n      ),\n\n      /**\n       * controller.current.location.astRef\n       */\n      astRef: createLeaf([data.current.astRef], identity),\n\n      /**\n       * controller.current.location.isMultiline\n       */\n      isMultiline: createLeaf(\n        [solidity.current.isMultiline, \"/current/trace/loaded\"],\n        (raw, loaded) => (loaded ? raw : false)\n      )\n    },\n\n    /*\n     * controller.current.trace\n     */\n    trace: {\n      /**\n       * controller.current.trace.finished\n       */\n      finished: createLeaf([trace.finished], identity),\n\n      /**\n       * controller.current.trace.loaded\n       */\n      loaded: createLeaf([trace.loaded], identity)\n    }\n  },\n\n  /**\n   * controller.breakpoints (namespace)\n   */\n  breakpoints: {\n    /**\n     * controller.breakpoints (selector)\n     */\n    _: createLeaf([\"/state\"], state => state.breakpoints),\n\n    /**\n     * controller.breakpoints.resolver (selector)\n     * this selector returns a function that adjusts a given line-based\n     * breakpoint (on node-based breakpoints it simply returns the input) by\n     * repeatedly moving it down a line until it lands on a line where there's\n     * actually somewhere to break.  if no such line exists beyond that point, it\n     * returns null instead.\n     */\n    resolver: createLeaf(\n      [solidity.views.sources, solidity.views.overlapFunctions],\n      (sources, functions) => breakpoint => {\n        let adjustedBreakpoint;\n        if (breakpoint.node === undefined) {\n          let line = breakpoint.line;\n          if (line < 0) {\n            line = 0; //prevents hang if user enters large negative number\n          }\n          const { sourceId } = breakpoint;\n          debug(\"breakpoint: %O\", breakpoint);\n          debug(\"sources: %o\", sources);\n          const { source, ast } = sources[sourceId];\n          if (!ast) {\n            //if no ast, don't attempt to adjust\n            return breakpoint;\n          }\n          const findOverlappingRange = functions[sourceId];\n          const lineLengths = source.split(\"\\n\").map(line => line.length);\n          //why does neither JS nor lodash have a scan function like Haskell??\n          //guess we'll have to do our scan manually\n          let lineStarts = [0];\n          for (let length of lineLengths) {\n            lineStarts.push(lineStarts[lineStarts.length - 1] + length + 1);\n            //+1 for the /n itself\n          }\n          debug(\n            \"line: %s\",\n            source.slice(lineStarts[line], lineStarts[line] + lineLengths[line])\n          );\n          while (\n            line < lineLengths.length &&\n            !anyNonSkippedInRange(\n              findOverlappingRange,\n              ast,\n              lineStarts[line],\n              lineLengths[line]\n            )\n          ) {\n            debug(\"incrementing\");\n            line++;\n          }\n          if (line >= lineLengths.length) {\n            adjustedBreakpoint = null;\n          } else {\n            adjustedBreakpoint = { ...breakpoint, line };\n          }\n        } else {\n          debug(\"node-based breakpoint\");\n          adjustedBreakpoint = breakpoint;\n        }\n        return adjustedBreakpoint;\n      }\n    )\n  },\n\n  /**\n   * controller.finished\n   * deprecated alias for controller.current.trace.finished\n   */\n  finished: createLeaf([\"/current/trace/finished\"], finished => finished),\n\n  /**\n   * controller.isStepping\n   */\n  isStepping: createLeaf([\"./state\"], state => state.isStepping),\n\n  /**\n   * controller.stepIntoInternalSources\n   */\n  stepIntoInternalSources: createLeaf([\"./state\"], state => state.stepIntoInternalSources)\n});\n\nexport default controller;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:ast:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport solidity from \"lib/solidity/selectors\";\n\n/**\n * ast\n */\nconst ast = createSelectorTree({\n  /**\n   * ast.views\n   */\n  views: {\n    /**\n     * ast.views.sources\n     * let's just flatten this into an array\n     */\n    sources: createLeaf([solidity.views.sources], sources =>\n      Object.values(sources)\n    )\n  }\n});\n\nexport default ast;\n","module.exports = require(\"semver\");","export const SCOPE = \"DATA_SCOPE\";\nexport function scope(id, pointer, parentId, sourceIndex, sourceId) {\n  return {\n    type: SCOPE,\n    id,\n    pointer,\n    parentId,\n    sourceIndex,\n    sourceId\n  };\n}\n\nexport const DECLARE = \"DATA_DECLARE_VARIABLE\";\nexport function declare(name, astRef, scopeAstRef, sourceId) {\n  return {\n    type: DECLARE,\n    name,\n    astRef,\n    scopeAstRef,\n    sourceId\n  };\n}\n\nexport const ASSIGN = \"DATA_ASSIGN\";\nexport function assign(assignments) {\n  return {\n    type: ASSIGN,\n    assignments\n  };\n}\n\nexport const MAP_PATH_AND_ASSIGN = \"DATA_MAP_PATH_AND_ASSIGN\";\nexport function mapPathAndAssign(\n  address,\n  slot,\n  assignments,\n  typeIdentifier,\n  parentType\n) {\n  return {\n    type: MAP_PATH_AND_ASSIGN,\n    address,\n    slot,\n    assignments,\n    typeIdentifier,\n    parentType\n  };\n}\n\nexport const RESET = \"DATA_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const DEFINE_TYPE = \"DATA_DEFINE_TYPE\";\nexport function defineType(node, sourceId) {\n  return {\n    type: DEFINE_TYPE,\n    node,\n    sourceId\n  };\n}\n\nexport const DEFINE_TAGGED_OUTPUT = \"DATA_DEFINE_TAGGED_OUTPUT\";\nexport function defineTaggedOutput(node, sourceId) {\n  return {\n    type: DEFINE_TAGGED_OUTPUT,\n    node,\n    sourceId\n  };\n}\n\nexport const ALLOCATE = \"DATA_ALLOCATE\";\nexport function allocate(storage, memory, abi, calldata, returndata, state) {\n  return {\n    type: ALLOCATE,\n    storage,\n    memory,\n    abi,\n    calldata,\n    returndata,\n    state\n  };\n}\n","export const ADD_CONTEXT = \"EVM_ADD_CONTEXT\";\nexport function addContext({\n  context,\n  contractName,\n  binary,\n  sourceMap,\n  primarySource,\n  immutableReferences,\n  compiler,\n  compilationId,\n  abi,\n  contractId,\n  contractKind,\n  isConstructor,\n  linearizedBaseContracts\n}) {\n  return {\n    type: ADD_CONTEXT,\n    context,\n    contractName,\n    binary,\n    sourceMap,\n    primarySource,\n    immutableReferences,\n    compiler,\n    compilationId,\n    abi,\n    contractId,\n    contractKind,\n    isConstructor,\n    linearizedBaseContracts\n  };\n}\n\nexport const ADD_INSTANCE = \"EVM_ADD_INSTANCE\";\nexport function addInstance(address, context, binary) {\n  return {\n    type: ADD_INSTANCE,\n    address,\n    context,\n    binary\n  };\n}\n\nexport const ADD_AFFECTED_INSTANCE = \"EVM_ADD_AFFECTED_INSTANCE\";\nexport function addAffectedInstance(\n  address,\n  context,\n  binary,\n  creationBinary,\n  creationContext\n) {\n  return {\n    type: ADD_AFFECTED_INSTANCE,\n    address,\n    context,\n    binary,\n    creationBinary, //may be undefined\n    creationContext\n  };\n}\n\nexport const REFRESH_INSTANCE = \"EVM_REFRESH_INSTANCE\";\nexport function refreshInstances(address, context) {\n  return {\n    type: REFRESH_INSTANCE,\n    address,\n    context\n  };\n}\n\nexport const SAVE_GLOBALS = \"EVM_SAVE_GLOBALS\";\nexport function saveGlobals(origin, gasprice, block) {\n  return {\n    type: SAVE_GLOBALS,\n    origin,\n    gasprice,\n    block\n  };\n}\n\nexport const SAVE_STATUS = \"EVM_SAVE_STATUS\";\nexport function saveStatus(status) {\n  return {\n    type: SAVE_STATUS,\n    status\n  };\n}\n\nexport const CALL = \"EVM_CALL\";\nexport function call(address, data, storageAddress, sender, value) {\n  return {\n    type: CALL,\n    address,\n    data,\n    storageAddress,\n    sender,\n    value\n  };\n}\n\nexport const CREATE = \"EVM_CREATE\";\nexport function create(binary, storageAddress, sender, value) {\n  return {\n    type: CREATE,\n    binary,\n    storageAddress,\n    sender,\n    value\n  };\n}\n\nexport const RETURN_CALL = \"EVM_RETURN_CALL\";\nexport function returnCall() {\n  return {\n    type: RETURN_CALL\n  };\n}\n\nexport const RETURN_CREATE = \"EVM_RETURN_CREATE\";\nexport function returnCreate(address, code, context) {\n  return {\n    type: RETURN_CREATE,\n    address,\n    code,\n    context\n  };\n}\n\nexport const FAIL = \"EVM_FAIL\";\nexport function fail() {\n  return {\n    type: FAIL\n  };\n}\n\nexport const STORE = \"EVM_STORE\";\nexport function store(address, slot, value) {\n  return {\n    type: STORE,\n    address,\n    slot,\n    value\n  };\n}\n\nexport const LOAD = \"EVM_LOAD\";\nexport function load(address, slot, value) {\n  return {\n    type: LOAD,\n    address,\n    slot,\n    value\n  };\n}\n\nexport const RESET = \"EVM_RESET\";\nexport function reset(storageAddress) {\n  return {\n    type: RESET,\n    storageAddress\n  };\n}\n\nexport const UNLOAD_TRANSACTION = \"EVM_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:web3:sagas\");\n\nimport {\n  all,\n  takeEvery,\n  apply,\n  fork,\n  join,\n  take,\n  put\n} from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport * as session from \"lib/session/actions\";\n\nimport BN from \"bn.js\";\nimport Web3 from \"web3\"; //just for utils!\nimport * as Codec from \"@truffle/codec\";\n\nimport Web3Adapter from \"../adapter\";\n\n//the following two functions are for Besu compatibility\nfunction padStackAndMemory(steps) {\n  return steps.map(step => ({\n    ...step,\n    stack: step.stack.map(padHexString),\n    memory: step.memory.map(padHexString)\n  }));\n}\n\n//turns Besu-style (begins with 0x, may be shorter than 64 hexdigits)\n//to Geth/Ganache-style (no 0x, always 64 hexdigits)\n//(I say 64 hexdigits rather than 32 bytes because Besu-style will use\n//non-whole numbers of bytes!)\nfunction padHexString(hexString) {\n  return hexString.startsWith(\"0x\") //Besu-style or Geth/Ganache-style?\n    ? hexString.slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"0\") //convert Besu to Geth/Ganache\n    : hexString; //leave Geth/Ganache style alone\n}\n\nfunction* fetchTransactionInfo(adapter, { txHash }) {\n  debug(\"inspecting transaction\");\n  var trace;\n  try {\n    trace = yield apply(adapter, adapter.getTrace, [txHash]);\n  } catch (e) {\n    debug(\"putting error\");\n    yield put(actions.error(e));\n    return;\n  }\n\n  debug(\"got trace\");\n  trace = padStackAndMemory(trace); //for Besu compatibility\n  yield put(actions.receiveTrace(trace));\n\n  const tx = yield apply(adapter, adapter.getTransaction, [txHash]);\n  debug(\"tx %O\", tx);\n  const receipt = yield apply(adapter, adapter.getReceipt, [txHash]);\n  debug(\"receipt %O\", receipt);\n  const block = yield apply(adapter, adapter.getBlock, [tx.blockNumber]);\n  debug(\"block %O\", block);\n  const chainId = yield apply(adapter, adapter.getChainId);\n\n  yield put(session.saveTransaction(tx));\n  yield put(session.saveReceipt(receipt));\n  yield put(session.saveBlock(block));\n\n  //these ones get grouped together for convenience\n  let solidityBlock = {\n    coinbase: block.miner,\n    difficulty: new BN(block.difficulty),\n    gaslimit: new BN(block.gasLimit),\n    number: new BN(block.number),\n    timestamp: new BN(block.timestamp),\n    chainid: new BN(chainId), //key is lowercase because that's what Solidity does\n    basefee: new BN(parseInt(block.baseFeePerGas)) //will be 0 if pre-London [new BN(NaN) yields 0]\n    //note we need parseInt on basefee because some web3 versions return it as a hex string,\n    //and BN doesn't allow for hex strings as input\n  };\n\n  if (tx.to != null) {\n    yield put(\n      actions.receiveCall({\n        address: tx.to,\n        data: tx.input,\n        storageAddress: tx.to,\n        status: receipt.status,\n        sender: tx.from,\n        value: new BN(tx.value),\n        gasprice: new BN(tx.gasPrice),\n        block: solidityBlock\n      })\n    );\n  } else {\n    let storageAddress = Web3.utils.isAddress(receipt.contractAddress)\n      ? receipt.contractAddress\n      : Codec.Evm.Utils.ZERO_ADDRESS;\n    yield put(\n      actions.receiveCall({\n        binary: tx.input,\n        storageAddress,\n        status: receipt.status,\n        sender: tx.from,\n        value: new BN(tx.value),\n        gasprice: new BN(tx.gasPrice),\n        block: solidityBlock\n      })\n    );\n  }\n}\n\nfunction* fetchBinary(adapter, { address, block }) {\n  debug(\"fetching binary for %s\", address);\n  let binary = yield apply(adapter, adapter.getDeployedCode, [address, block]);\n\n  debug(\"received binary for %s\", address);\n  yield put(actions.receiveBinary(address, binary));\n}\n\nexport function* inspectTransaction(txHash) {\n  yield put(actions.inspect(txHash));\n\n  let action = yield take([actions.RECEIVE_TRACE, actions.ERROR_WEB3]);\n  debug(\"action %o\", action);\n\n  var trace;\n  if (action.type == actions.RECEIVE_TRACE) {\n    trace = action.trace;\n    debug(\"received trace\");\n  } else {\n    return { error: action.error };\n  }\n\n  let {\n    address,\n    binary,\n    data,\n    storageAddress,\n    status,\n    sender,\n    value,\n    gasprice,\n    block\n  } = yield take(actions.RECEIVE_CALL);\n  debug(\"received call\");\n\n  return {\n    trace,\n    address,\n    binary,\n    data,\n    storageAddress,\n    status,\n    sender,\n    value,\n    gasprice,\n    block\n  };\n}\n\n//NOTE: the block argument is optional\nexport function* obtainBinaries(addresses, block) {\n  let tasks = yield all(addresses.map(address => fork(receiveBinary, address)));\n\n  debug(\"requesting binaries\");\n  yield all(addresses.map(address => put(actions.fetchBinary(address, block))));\n\n  let binaries = [];\n  binaries = yield join(tasks);\n\n  debug(\"binaries %o\", binaries);\n\n  return binaries;\n}\n\nfunction* receiveBinary(address) {\n  let { binary } = yield take(\n    action => action.type == actions.RECEIVE_BINARY && action.address == address\n  );\n  debug(\"got binary for %s\", address);\n\n  return binary;\n}\n\nexport function* init(provider) {\n  yield put(actions.init(provider));\n}\n\nexport function* saga() {\n  // wait for web3 init signal\n  let { provider } = yield take(actions.INIT_WEB3);\n  let adapter = new Web3Adapter(provider);\n\n  yield takeEvery(actions.INSPECT, fetchTransactionInfo, adapter);\n  yield takeEvery(actions.FETCH_BINARY, fetchBinary, adapter);\n}\n\nexport default prefixName(\"web3\", saga);\n","module.exports = require(\"web3\");","module.exports = require(\"util\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:sagas\");\n\nimport { put, call, race, take, select } from \"redux-saga/effects\";\n\nimport { prefixName, isDeliberatelySkippedNodeType } from \"lib/helpers\";\n\nimport * as trace from \"lib/trace/sagas\";\nimport * as data from \"lib/data/sagas\";\nimport * as txlog from \"lib/txlog/sagas\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as solidity from \"lib/solidity/sagas\";\nimport * as stacktrace from \"lib/stacktrace/sagas\";\n\nimport * as actions from \"../actions\";\n\nimport controller from \"../selectors\";\n\nconst STEP_SAGAS = {\n  [actions.ADVANCE]: advance,\n  [actions.STEP_NEXT]: stepNext,\n  [actions.STEP_OVER]: stepOver,\n  [actions.STEP_INTO]: stepInto,\n  [actions.STEP_OUT]: stepOut,\n  [actions.CONTINUE]: continueUntilBreakpoint\n};\n\nexport function* saga() {\n  while (true) {\n    debug(\"waiting for control action\");\n    let action = yield take(Object.keys(STEP_SAGAS));\n    if (!(yield select(controller.current.trace.loaded))) {\n      continue; //while no trace is loaded, step actions are ignored\n    }\n    debug(\"got control action\");\n    let saga = STEP_SAGAS[action.type];\n\n    yield put(actions.startStepping());\n    yield race({\n      exec: call(saga, action), //not all will use this\n      interrupt: take(actions.INTERRUPT)\n    });\n    yield put(actions.doneStepping());\n  }\n}\n\nexport default prefixName(\"controller\", saga);\n\n/**\n * Advance the state by the given number of instructions (but not past the end)\n * (if no count given, advance 1)\n */\nfunction* advance(action) {\n  let count =\n    action !== undefined && action.count !== undefined ? action.count : 1;\n  //default is, as mentioned, to advance 1\n  for (\n    let i = 0;\n    i < count && !(yield select(controller.current.trace.finished));\n    i++\n  ) {\n    yield* trace.advance();\n  }\n}\n\n/**\n * stepNext - step to the next logical code segment\n *\n * Note: It might take multiple instructions to express the same section of code.\n * \"Stepping\", then, is stepping to the next logical item, not stepping to the next\n * instruction. See advance() if you'd like to advance by one instruction.\n *\n * Note that if you are not in an internal source, this function will not stop in one\n * (unless it hits the end of the trace); you will need to use advance() to get into\n * one.  However, if you are already in an internal source, this function will not\n * automatically step all the way out of it.\n */\nfunction* stepNext() {\n  const starting = yield select(controller.current.location);\n  const allowInternal = yield select(controller.stepIntoInternalSources);\n\n  let upcoming, finished;\n\n  do {\n    // advance at least once step\n    yield* advance();\n\n    // and check the next source range\n    upcoming = yield select(controller.current.location);\n\n    finished = yield select(controller.current.trace.finished);\n\n    // if the next step's source range is still the same, keep going\n  } while (\n    !finished &&\n    (!upcoming ||\n      //don't stop on an internal source unless allowInternal is on or\n      //we started in an internal source\n      (!allowInternal &&\n        upcoming.source.internal &&\n        !starting.source.internal) ||\n      upcoming.sourceRange.length === 0 ||\n      upcoming.source.id === undefined ||\n      (upcoming.node && isDeliberatelySkippedNodeType(upcoming.node)) ||\n      (upcoming.sourceRange.start === starting.sourceRange.start &&\n        upcoming.sourceRange.length === starting.sourceRange.length &&\n        upcoming.source.id === starting.source.id))\n  );\n}\n\n/**\n * stepInto - step into the current function\n *\n * Conceptually this is easy, but from a programming standpoint it's hard.\n * Code like `getBalance(msg.sender)` might be highlighted, but there could\n * be a number of different intermediate steps (like evaluating `msg.sender`)\n * before `getBalance` is stepped into. This function will step into the first\n * function available (where instruction.jump == \"i\"), ignoring any intermediate\n * steps that fall within the same code range. If there's a step encountered\n * that exists outside of the range, then stepInto will only execute until that\n * step.\n */\nfunction* stepInto() {\n  const startingDepth = yield select(controller.current.functionDepth);\n  const startingLocation = yield select(controller.current.location);\n  debug(\"startingDepth: %d\", startingDepth);\n  debug(\"starting source range: %O\", (startingLocation || {}).sourceRange);\n  let currentDepth;\n  let currentLocation;\n  let finished;\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    currentLocation = yield select(controller.current.location);\n    finished = yield select(controller.current.trace.finished);\n    debug(\"currentDepth: %d\", currentDepth);\n    debug(\"current source range: %O\", (currentLocation || {}).sourceRange);\n    debug(\"finished: %o\", finished);\n  } while (\n    //we aren't finished,\n    !finished &&\n    // the function stack has not increased,\n    currentDepth <= startingDepth &&\n    // we haven't changed files,\n    currentLocation.source.id === startingLocation.source.id &&\n    //and we haven't changed lines\n    currentLocation.sourceRange.lines.start.line ===\n      startingLocation.sourceRange.lines.start.line\n  );\n}\n\n/**\n * Step out of the current function\n *\n * This will run until the debugger encounters a decrease in function depth\n * (or finishes)\n */\nfunction* stepOut() {\n  if (yield select(controller.current.location.isMultiline)) {\n    yield* stepOver();\n    return;\n  }\n\n  const startingDepth = yield select(controller.current.functionDepth);\n  var currentDepth;\n  var finished;\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    finished = yield select(controller.current.trace.finished);\n  } while (!finished && currentDepth >= startingDepth);\n}\n\n/**\n * stepOver - step over the current line\n *\n * Step over the current line. This will step to the next instruction that\n * exists on a different line of code within the same function depth.\n */\nfunction* stepOver() {\n  const startingDepth = yield select(controller.current.functionDepth);\n  const startingLocation = yield select(controller.current.location);\n  var currentDepth;\n  var currentLocation;\n  var finished;\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    currentLocation = yield select(controller.current.location);\n    finished = yield select(controller.current.trace.finished);\n  } while (\n    // keep stepping provided:\n    //\n    // we haven't finished\n    !finished &&\n    // we haven't jumped out\n    currentDepth >= startingDepth &&\n    // either: function depth is greater than starting (ignore function calls)\n    // or, if we're at the same depth, keep stepping until we're on a new\n    // line (which may be in a new file)\n    (currentDepth > startingDepth ||\n      (currentLocation.source.id === startingLocation.source.id &&\n        currentLocation.sourceRange.lines.start.line ===\n          startingLocation.sourceRange.lines.start.line))\n  );\n}\n\n/**\n * continueUntilBreakpoint - step through execution until a breakpoint\n */\nfunction* continueUntilBreakpoint(action) {\n  //if breakpoints was not specified, use the stored list from the state.\n  //if it was, override that with the specified list.\n  //note that explicitly specifying an empty list will advance to the end.\n  let breakpoints =\n    action !== undefined && action.breakpoints !== undefined\n      ? action.breakpoints\n      : yield select(controller.breakpoints);\n\n  let breakpointHit = false;\n\n  let currentLocation = yield select(controller.current.location);\n  let currentSourceId = currentLocation.source.id;\n  let currentLine = currentLocation.sourceRange.lines.start.line;\n  let currentStart = currentLocation.sourceRange.start;\n  let currentLength = currentLocation.sourceRange.start;\n  //note that if allow internal is on, we don't turn on the special treatment\n  //of user sources even if we started in one\n  const startedInUserSource =\n    !(yield select(controller.stepIntoInternalSources)) &&\n    currentLocation.source.id !== undefined &&\n    !currentLocation.source.internal;\n  //the following are set regardless, but only used if startedInUserSource\n  let lastUserSourceId = currentSourceId;\n  let lastUserLine = currentLine;\n  let lastUserStart = currentStart;\n  let lastUserLength = currentLength;\n\n  do {\n    yield* advance(); //note: this avoids using stepNext in order to\n    //allow breakpoints in internal sources to work properly\n\n    //note these three have not been updated yet; they'll be updated a\n    //few lines down.  but at this point these are still the previous\n    //values.\n    let previousLine = currentLine;\n    let previousStart = currentStart;\n    let previousLength = currentLength;\n    let previousSourceId = currentSourceId;\n    if (!currentLocation.source.internal) {\n      lastUserSourceId = currentSourceId;\n      lastUserLine = currentLine;\n      lastUserStart = currentStart;\n      lastUserLength = currentLength;\n    }\n\n    currentLocation = yield select(controller.current.location);\n    let finished = yield select(controller.current.trace.finished);\n    if (finished) {\n      break; //can break immediately if finished\n    }\n\n    currentSourceId = currentLocation.source.id;\n    if (currentSourceId === undefined) {\n      continue; //never stop on an unmapped instruction\n    }\n    currentLine = currentLocation.sourceRange.lines.start.line;\n    currentStart = currentLocation.sourceRange.start;\n    currentLength = currentLocation.sourceRange.length;\n\n    breakpointHit =\n      breakpoints.filter(({ sourceId, line, start, length }) => {\n        if (start !== undefined && length !== undefined) {\n          //node-based (well, source-range-based) breakpoint\n          return (\n            sourceId === currentSourceId &&\n            start === currentStart &&\n            length === currentLength &&\n            (currentSourceId !== previousSourceId ||\n              currentStart !== previousStart ||\n              currentLength !== previousLength\n            ) &&\n            //if we started in a user source (& allow internal is off),\n            //we need to make sure we've moved from a user-source POV\n            (!startedInUserSource ||\n              currentSourceId !== lastUserSourceId ||\n              currentStart !== lastUserStart || \n              currentLength !== lastUserLength\n            )\n          );\n        }\n        //otherwise, we have a line-style breakpoint; we want to stop at the\n        //*first* point on the line\n        return (\n          sourceId === currentSourceId &&\n          line === currentLine &&\n          (currentSourceId !== previousSourceId ||\n            currentLine !== previousLine) &&\n          //again, if started in a user source w/ allow internal off,\n          //need to make sure we've moved from a *user*-source POV\n          (!startedInUserSource ||\n            currentSourceId !== lastUserSourceId ||\n            currentLine !== lastUserLine)\n        );\n      }).length > 0;\n  } while (!breakpointHit);\n}\n\n/**\n * reset -- reset the state of the debugger\n * (we'll just reset all submodules regardless of which are in use)\n */\nexport function* reset() {\n  yield* data.reset();\n  yield* evm.reset();\n  yield* solidity.reset();\n  yield* trace.reset();\n  yield* stacktrace.reset();\n  yield* txlog.reset();\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:txlog:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\nimport * as Codec from \"@truffle/codec\";\n\nimport * as actions from \"../actions\";\nimport { TICK } from \"lib/trace/actions\";\nimport * as trace from \"lib/trace/sagas\";\nimport * as data from \"lib/data/sagas\";\n\nimport txlog from \"../selectors\";\n\nfunction* tickSaga() {\n  yield* updateTransactionLogSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\nfunction* updateTransactionLogSaga() {\n  const pointer = yield select(txlog.current.pointer); //log pointer, not AST pointer\n  if (yield select(txlog.current.isHalting)) {\n    //note that we process this case first so that it overrides the others!\n    const newPointer = yield select(txlog.current.externalReturnPointer);\n    const status = yield select(txlog.current.returnStatus);\n    if (status) {\n      if (yield select(txlog.current.isSelfDestruct)) {\n        const beneficiary = yield select(txlog.current.beneficiary);\n        //note: this selector returns null for a value-destroying selfdestruct\n        debug(\"sd: %o %o\", pointer, newPointer);\n        yield put(actions.selfdestruct(pointer, newPointer, beneficiary));\n      } else {\n        const decodings = yield* data.decodeReturnValue();\n        const rawData = yield select(txlog.current.returnData);\n        debug(\"external return: %o %o\", pointer, newPointer);\n        yield put(\n          actions.externalReturn(pointer, newPointer, decodings, rawData)\n        );\n      }\n    } else {\n      const error = (yield* data.decodeReturnValue())[0];\n      debug(\"revert: %o %o\", pointer, newPointer);\n      yield put(actions.revert(pointer, newPointer, error));\n    }\n  } else if (yield select(txlog.current.isJump)) {\n    const jumpDirection = yield select(txlog.current.jumpDirection);\n    if (jumpDirection === \"i\") {\n      const internal = yield select(txlog.next.inInternalSourceOrYul); //don't log jumps into internal sources or Yul\n      if (!internal) {\n        //we don't do any decoding/fn identification here because that's handled by\n        //the function identification case\n        if (!(yield select(txlog.current.waitingForInternalCallToAbsorb))) {\n          const newPointer = yield select(txlog.current.nextCallPointer);\n          debug(\"internal call: %o %o\", pointer, newPointer);\n          yield put(actions.internalCall(pointer, newPointer));\n        } else {\n          debug(\"absorbed call: %o\", pointer);\n          yield put(actions.absorbedCall(pointer));\n        }\n      }\n    } else if (jumpDirection === \"o\") {\n      const internal = yield select(txlog.current.inInternalSourceOrYul); //don't log jumps out of internal sources or Yul\n      const astMatchesTxLog = yield select(txlog.current.currentFunctionIsAsExpected); //don't log returns from the wrong function...?\n      //(I've added this second check due to a strange case Amal found, hopefully this doesn't screw anything up)\n      if (!internal && astMatchesTxLog) {\n        //in this case, we have to do decoding & fn identification\n        const newPointer = yield select(txlog.current.internalReturnPointer);\n        const outputAllocations = yield select(\n          txlog.current.outputParameterAllocations\n        );\n        if (outputAllocations) {\n          const compilationId = yield select(txlog.current.compilationId);\n          //can't do a yield* inside a map, have to do this loop manually\n          let variables = [];\n          for (let { name, definition, pointer } of outputAllocations) {\n            name = name ? name : undefined; //replace \"\" with undefined\n            const decodedValue = yield* data.decode(\n              definition,\n              pointer,\n              compilationId\n            );\n            variables.push({ name, value: decodedValue });\n          }\n          debug(\"internal return: %o %o\", pointer, newPointer);\n          yield put(actions.internalReturn(pointer, newPointer, variables));\n        } else {\n          debug(\"internal return: %o %o\", pointer, newPointer);\n          yield put(actions.internalReturn(pointer, newPointer, undefined)); //I guess?\n        }\n      }\n    }\n  } else if (yield select(txlog.current.isCall)) {\n    const newPointer = yield select(txlog.current.nextCallPointer);\n    const address = yield select(txlog.current.callAddress);\n    const value = yield select(txlog.current.callValue);\n    //distinguishing DELEGATECALL vs CALLCODE seems unnecessary here\n    const isDelegate = yield select(txlog.current.isDelegateCallBroad);\n    //we need to determine what kind of call this is.\n    //we'll sort them into: function, constructor, message, library\n    //(library is a placeholder to be replaced later)\n    const context = yield select(txlog.current.callContext);\n    const calldata = yield select(txlog.current.callData);\n    const instant = yield select(txlog.current.isInstantCallOrCreate);\n    const kind = callKind(context, calldata, instant);\n    const absorb = yield select(txlog.current.absorbNextInternalCall);\n    const decoding = yield* data.decodeCall();\n    if (instant) {\n      const status = yield select(txlog.current.returnStatus);\n      debug(\"instacall: %o %o\", pointer, newPointer);\n      yield put(\n        actions.instantExternalCall(\n          pointer,\n          newPointer, //note: doesn't actually change the current pointer\n          address,\n          context,\n          value,\n          isDelegate,\n          kind,\n          decoding,\n          calldata,\n          absorb,\n          status\n        )\n      );\n    } else {\n      debug(\"external call: %o %o\", pointer, newPointer);\n      yield put(\n        actions.externalCall(\n          pointer,\n          newPointer,\n          address,\n          context,\n          value,\n          isDelegate,\n          kind,\n          decoding,\n          calldata,\n          absorb\n        )\n      );\n    }\n  } else if (yield select(txlog.current.isCreate)) {\n    const newPointer = yield select(txlog.current.nextCallPointer);\n    const address = yield select(txlog.current.createdAddress);\n    const context = yield select(txlog.current.callContext);\n    const value = yield select(txlog.current.createValue);\n    const salt = yield select(txlog.current.salt); //is null for an ordinary create\n    const instant = yield select(txlog.current.isInstantCallOrCreate);\n    const binary = yield select(txlog.current.createBinary);\n    const decoding = yield* data.decodeCall();\n    if (instant) {\n      const status = yield select(txlog.current.returnStatus);\n      debug(\"instacreate: %o %o\", pointer, newPointer);\n      yield put(\n        actions.instantCreate(\n          pointer,\n          newPointer, //note: doesn't actually change the current pointer\n          address,\n          context,\n          value,\n          salt,\n          decoding,\n          binary,\n          status\n        )\n      );\n    } else {\n      debug(\"create: %o %o\", pointer, newPointer);\n      yield put(\n        actions.create(\n          pointer,\n          newPointer,\n          address,\n          context,\n          value,\n          salt,\n          decoding,\n          binary\n        )\n      );\n    }\n  }\n  //we process this last in case jump & function def on same step\n  //(which is in fact how it typically goes!)\n  if (yield select(txlog.current.onFunctionDefinition)) {\n    if (yield select(txlog.current.waitingForFunctionDefinition)) {\n      debug(\"identifying\");\n      const inputAllocations = yield select(\n        txlog.current.inputParameterAllocations\n      );\n      debug(\"inputAllocations: %O\", inputAllocations);\n      if (inputAllocations) {\n        const functionNode = yield select(txlog.current.astNode);\n        const contractNode = yield select(txlog.current.contract);\n        const compilationId = yield select(txlog.current.compilationId);\n        //can't do a yield* inside a map, have to do this loop manually\n        let variables = [];\n        for (let { name, definition, pointer } of inputAllocations) {\n          const decodedValue = yield* data.decode(\n            definition,\n            pointer,\n            compilationId\n          );\n          variables.push({ name, value: decodedValue });\n        }\n        debug(\"identify: %o\", pointer);\n        yield put(\n          actions.identifyFunctionCall(\n            pointer,\n            functionNode,\n            contractNode,\n            variables\n          )\n        );\n      }\n    }\n  }\n}\n\nfunction callKind(context, calldata, instant) {\n  if (context) {\n    if (context.contractKind === \"library\") {\n      return instant ? \"message\" : \"library\";\n      //for an instant return, just get it out of the way and set it to\n      //message rather than leaving it open (it'll get resolved in favor\n      //of message by our criteria)\n    } else {\n      const abi = context.abi;\n      const selector = calldata\n        .slice(0, 2 + 2 * Codec.Evm.Utils.SELECTOR_SIZE)\n        .padEnd(\"00\", 2 + 2 * Codec.Evm.Utils.SELECTOR_SIZE);\n      debug(\"selector: %s\", selector);\n      if (abi && selector in abi) {\n        return \"function\";\n      }\n    }\n  }\n  return \"message\";\n}\n\nexport function* reset() {\n  const initialCall = yield select(txlog.transaction.initialCall);\n  yield put(actions.reset());\n  yield put(initialCall);\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* begin() {\n  const pointer = yield select(txlog.current.pointer);\n  const newPointer = yield select(txlog.current.nextCallPointer);\n  const origin = yield select(txlog.transaction.origin);\n  debug(\"origin: %o\", pointer);\n  yield put(actions.recordOrigin(pointer, origin));\n  const {\n    address,\n    binary,\n    storageAddress,\n    value,\n    data: calldata\n  } = yield select(txlog.current.call);\n  const context = yield select(txlog.current.context);\n  //note: there was an instant check here (based on checking if there are no\n  //trace steps) but I took it out, because even though having no trace steps\n  //is essentially an insta-call, the debugger doesn't treat it that way (it\n  //will see the return later), so we shouldn't here either\n  const decoding = yield* data.decodeCall(true); //pass flag to decode *current* call\n  if (address) {\n    const kind = callKind(context, calldata, false); //no insta-calls here!\n    const absorb = yield select(txlog.transaction.absorbFirstInternalCall);\n    debug(\"initial call: %o %o\", pointer, newPointer);\n    yield put(actions.externalCall(\n      pointer,\n      newPointer,\n      address,\n      context,\n      value,\n      false, //initial call is never delegate\n      kind,\n      decoding,\n      calldata,\n      absorb\n    ));\n  } else {\n    debug(\"initial create: %o %o\", pointer, newPointer);\n    yield put(actions.create(\n      pointer,\n      newPointer,\n      storageAddress,\n      context,\n      value,\n      null, //initial create never has salt\n      decoding,\n      binary\n    ));\n  }\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"txlog\", saga);\n","export const INTERNAL_CALL = \"TXLOG_INTERNAL_CALL\";\nexport function internalCall(pointer, newPointer) {\n  return {\n    type: INTERNAL_CALL,\n    pointer,\n    newPointer\n  };\n}\n\nexport const ABSORBED_CALL = \"TXLOG_ABSORBED_CALL\";\nexport function absorbedCall(pointer) {\n  return {\n    type: ABSORBED_CALL,\n    pointer\n  };\n}\n\nexport const INTERNAL_RETURN = \"TXLOG_INTERNAL_RETURN\";\nexport function internalReturn(pointer, newPointer, variables) {\n  return {\n    type: INTERNAL_RETURN,\n    pointer,\n    newPointer,\n    variables\n  };\n}\n\nexport const EXTERNAL_CALL = \"TXLOG_EXTERNAL_CALL\";\nexport function externalCall(\n  pointer,\n  newPointer,\n  address,\n  context,\n  value,\n  isDelegate,\n  kind,\n  decoding,\n  calldata,\n  absorbNextInternalCall\n) {\n  return {\n    type: EXTERNAL_CALL,\n    pointer,\n    newPointer,\n    address,\n    context,\n    value,\n    isDelegate,\n    kind,\n    decoding,\n    calldata,\n    absorbNextInternalCall\n  };\n}\n\nexport const INSTANT_EXTERNAL_CALL = \"TXLOG_INSTANT_EXTERNAL_CALL\";\nexport function instantExternalCall(\n  pointer,\n  newPointer, //does not actually affect the current pointer!\n  address,\n  context,\n  value,\n  isDelegate,\n  kind,\n  decoding,\n  calldata,\n  absorbNextInternalCall,\n  status\n) {\n  return {\n    type: INSTANT_EXTERNAL_CALL,\n    pointer,\n    newPointer,\n    address,\n    context,\n    value,\n    isDelegate,\n    kind,\n    decoding,\n    calldata,\n    absorbNextInternalCall,\n    status\n  };\n}\n\nexport const CREATE = \"TXLOG_CREATE\";\nexport function create(\n  pointer,\n  newPointer,\n  address,\n  context,\n  value,\n  salt,\n  decoding,\n  binary\n) {\n  return {\n    type: CREATE,\n    pointer,\n    newPointer,\n    address,\n    context,\n    value,\n    salt,\n    decoding,\n    binary\n  };\n}\n\nexport const INSTANT_CREATE = \"TXLOG_INSTANT_CREATE\";\nexport function instantCreate(\n  pointer,\n  newPointer, //does not actually affect the current pointer!\n  address,\n  context,\n  value,\n  salt,\n  decoding,\n  binary,\n  status\n) {\n  return {\n    type: INSTANT_CREATE,\n    pointer,\n    newPointer,\n    address,\n    context,\n    value,\n    salt,\n    decoding,\n    binary,\n    status\n  };\n}\n\nexport const EXTERNAL_RETURN = \"TXLOG_EXTERNAL_RETURN\";\nexport function externalReturn(pointer, newPointer, decodings, returnData) {\n  return {\n    type: EXTERNAL_RETURN,\n    pointer,\n    newPointer,\n    decodings,\n    returnData\n  };\n}\n\nexport const SELFDESTRUCT = \"TXLOG_SELFDESTRUCT\";\nexport function selfdestruct(pointer, newPointer, beneficiary) {\n  return {\n    type: SELFDESTRUCT,\n    pointer,\n    newPointer,\n    beneficiary\n  };\n}\n\nexport const REVERT = \"TXLOG_REVERT\";\nexport function revert(pointer, newPointer, error) {\n  return {\n    type: REVERT,\n    pointer,\n    newPointer,\n    error\n  };\n}\n\nexport const IDENTIFY_FUNCTION_CALL = \"TXLOG_IDENTIFY_FUNCTION_CALL\";\nexport function identifyFunctionCall(\n  pointer,\n  functionNode,\n  contractNode,\n  variables\n) {\n  return {\n    type: IDENTIFY_FUNCTION_CALL,\n    pointer,\n    functionNode,\n    contractNode,\n    variables\n  };\n}\n\nexport const RECORD_ORIGIN = \"TXLOG_RECORD_ORIGIN\";\nexport function recordOrigin(pointer, address) {\n  return {\n    type: RECORD_ORIGIN,\n    pointer,\n    address\n  };\n}\n\nexport const RESET = \"TXLOG_RESET\";\nexport function reset() {\n  return {\n    type: RESET\n  };\n}\n\nexport const UNLOAD_TRANSACTION = \"TXLOG_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:solidity:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport { TICK } from \"lib/trace/actions\";\nimport * as trace from \"lib/trace/sagas\";\n\nimport solidity from \"../selectors\";\n\nexport function* addSources(sources) {\n  yield put(actions.addSources(sources));\n}\n\nfunction* tickSaga() {\n  debug(\"got TICK\");\n\n  yield* functionDepthSaga();\n  debug(\"instruction: %O\", yield select(solidity.current.instruction));\n  yield* trace.signalTickSagaCompletion();\n}\n\nfunction* functionDepthSaga() {\n  if (yield select(solidity.current.willReturn)) {\n    //we do this case first so we can be sure we're not failing in any of the\n    //other cases below!\n    yield put(actions.externalReturn());\n  } else if (yield select(solidity.current.willJump)) {\n    let jumpDirection = yield select(solidity.current.jumpDirection);\n    debug(\"checking guard\");\n    let guard = yield select(solidity.current.nextFrameIsPhantom);\n    let nextSource = yield select(solidity.next.source);\n    if (jumpDirection === \"i\" && guard && nextSource.id !== undefined) {\n      yield put(actions.clearPhantomGuard());\n    } else {\n      yield put(actions.jump(jumpDirection));\n    }\n  } else if (yield select(solidity.current.willCall)) {\n    //note: includes creations; does not include insta-returns\n    debug(\"checking if guard needed\");\n    let guard = yield select(solidity.current.callRequiresPhantomFrame);\n    yield put(actions.externalCall(guard));\n  }\n}\n\nexport function* reset() {\n  let guard = yield select(\n    solidity.transaction.bottomStackframeRequiresPhantomFrame\n  );\n  yield put(actions.reset(guard));\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* begin() {\n  let guard = yield select(\n    solidity.transaction.bottomStackframeRequiresPhantomFrame\n  );\n  yield put(actions.externalCall(guard));\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"solidity\", saga);\n","export const ADD_SOURCES = \"SOLIDITY_ADD_SOURCES\";\nexport function addSources(sources) {\n  return {\n    type: ADD_SOURCES,\n    sources\n  };\n}\n\nexport const JUMP = \"SOLIDITY_JUMP\";\nexport function jump(jumpDirection) {\n  return {\n    type: JUMP,\n    jumpDirection\n  };\n}\n\nexport const EXTERNAL_CALL = \"SOLIDITY_EXTERNAL_CALL\";\nexport function externalCall(guard) {\n  return { type: EXTERNAL_CALL, guard };\n}\n\nexport const EXTERNAL_RETURN = \"SOLIDITY_EXTERNAL_RETURN\";\nexport function externalReturn() {\n  return { type: EXTERNAL_RETURN };\n}\n\nexport const CLEAR_PHANTOM_GUARD = \"SOLIDITY_CLEAR_PHANTOM_GUARD\";\nexport function clearPhantomGuard() {\n  return { type: CLEAR_PHANTOM_GUARD };\n}\n\nexport const RESET = \"SOLIDITY_RESET\";\nexport function reset(guard) {\n  return { type: RESET, guard };\n}\n\nexport const UNLOAD_TRANSACTION = \"SOLIDITY_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return { type: UNLOAD_TRANSACTION };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport { TICK } from \"lib/trace/actions\";\nimport * as trace from \"lib/trace/sagas\";\n\nimport stacktrace from \"../selectors\";\n\nfunction* tickSaga() {\n  yield* stacktraceSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\n//NOTE: we deliberately *don't* do any phantom-checking in this\n//submodule.  yes, it will result in some junk stackframes, but\n//I really don't want a fallback or constructor frame skipped over\n//due to phantom checking\n\nfunction* stacktraceSaga() {\n  const currentLocation = yield select(stacktrace.current.strippedLocation);\n  const lastLocation = yield select(stacktrace.current.lastPosition);\n  const returnCounter = yield select(stacktrace.current.returnCounter);\n  let positionUpdated = false;\n  //different possible outcomes:\n  //first: are we returning?\n  if (yield select(stacktrace.current.willReturn)) {\n    const status = yield select(stacktrace.current.returnStatus);\n    const index = yield select(stacktrace.current.index);\n    const updateIndex = yield select(stacktrace.current.updateIndex);\n    debug(\"returning!\");\n    yield put(actions.externalReturn(\n      lastLocation,\n      status,\n      currentLocation,\n      updateIndex ? index : null //we use null to mean don't update\n    ));\n    positionUpdated = true;\n  } else if (\n    //next: are we *executing* a return?\n    //note this needs to be an else if or else this could execute\n    //in an inconsistent state\n    returnCounter > 0 &&\n    (yield select(stacktrace.current.positionWillChange))\n  ) {\n    debug(\"executing!\");\n    debug(\"location: %o\", yield select(stacktrace.next.location));\n    debug(\"marked: %o\", lastLocation);\n    yield put(actions.executeReturn(returnCounter, currentLocation));\n    positionUpdated = true;\n  }\n  //we now process the other possibilities.\n  //technically, an EXECUTE_RETURN could happen as well as those below,\n  //resulting in 2 actions instead of just one, but it's pretty unlikely.\n  //(an EXTERNAL_RETURN, OTOH, is obviously exclusive of the possibilities below)\n  if ((yield select(stacktrace.current.willJumpIn)) && returnCounter === 0) {\n    //note: do NOT process jumps while there are returns waiting to execute\n    const nextLocation = yield select(stacktrace.next.location);\n    const nextParent = yield select(stacktrace.next.contractNode);\n    yield put(actions.jumpIn(currentLocation, nextLocation.node, nextParent));\n    positionUpdated = true;\n  } else if (\n    (yield select(stacktrace.current.willJumpOut)) &&\n    returnCounter === 0\n  ) {\n    //again, do not process jumps while there are returns waiting to execute\n    yield put(actions.jumpOut(currentLocation));\n    positionUpdated = true;\n  } else if (yield select(stacktrace.current.willCall)) {\n    //note: includes creations\n    //note: does *not* include calls that insta-return.  logically speaking,\n    //such calls should be a call + a return in one, right? and we could do that,\n    //making a call while also incrementing the return counter.  but the stacktraces\n    //this would generate would, I think, be more confusing than helpful, so I'm\n    //deliberately not doing that.\n    //NOTE: we can't use stacktrace.next.location here as that\n    //doesn't work across call contexts!\n    const nextContext = yield select(stacktrace.current.callContext);\n    const nextAddress = yield select(stacktrace.current.callAddress);\n    yield put(actions.externalCall(currentLocation, nextContext, nextAddress));\n    positionUpdated = true;\n  }\n  //finally, if no other action updated the position, do so here\n  if (!positionUpdated) {\n    yield put(actions.updatePosition(currentLocation));\n  }\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* begin() {\n  const context = yield select(stacktrace.current.context);\n  const address = yield select(stacktrace.current.address);\n  yield put(actions.externalCall(null, context, address));\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"stacktrace\", saga);\n","export const JUMP_IN = \"STACKTRACE_JUMP_IN\";\nexport function jumpIn(location, functionNode, contractNode) {\n  return {\n    type: JUMP_IN,\n    location,\n    functionNode,\n    contractNode,\n  };\n}\n\nexport const JUMP_OUT = \"STACKTRACE_JUMP_OUT\";\nexport function jumpOut(location) {\n  return {\n    type: JUMP_OUT,\n    location,\n  };\n}\n\nexport const EXTERNAL_CALL = \"STACKTRACE_EXTERNAL_CALL\";\nexport function externalCall(location, context, address) {\n  return {\n    type: EXTERNAL_CALL,\n    location,\n    context,\n    address,\n  };\n}\n\nexport const EXTERNAL_RETURN = \"STACKTRACE_EXTERNAL_RETURN\";\nexport function externalReturn(from, status, location, index) {\n  return {\n    type: EXTERNAL_RETURN,\n    from,\n    status,\n    location,\n    index\n  };\n}\n\nexport const EXECUTE_RETURN = \"STACKTRACE_EXECUTE_RETURN\";\nexport function executeReturn(counter, location) {\n  return {\n    type: EXECUTE_RETURN,\n    counter,\n    location,\n  };\n}\n\nexport const UPDATE_POSITION = \"STACKTRACE_UPDATE_POSITION\";\nexport function updatePosition(location) {\n  return {\n    type: UPDATE_POSITION,\n    location,\n  };\n}\n\nexport const RESET = \"STACKTRACE_RESET\";\nexport function reset() {\n  return {\n    type: RESET,\n  };\n}\n\nexport const UNLOAD_TRANSACTION = \"STACKTRACE_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION,\n  };\n}\n","/*\n\nThe MIT License (MIT)\n\nOriginal Library\n  - Copyright (c) Marak Squires\n\nAdditional functionality\n - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar colors = {};\nmodule['exports'] = colors;\n\ncolors.themes = {};\n\nvar util = require('util');\nvar ansiStyles = colors.styles = require('./styles');\nvar defineProps = Object.defineProperties;\nvar newLineRegex = new RegExp(/[\\r\\n]+/g);\n\ncolors.supportsColor = require('./system/supports-colors').supportsColor;\n\nif (typeof colors.enabled === 'undefined') {\n  colors.enabled = colors.supportsColor() !== false;\n}\n\ncolors.enable = function() {\n  colors.enabled = true;\n};\n\ncolors.disable = function() {\n  colors.enabled = false;\n};\n\ncolors.stripColors = colors.strip = function(str) {\n  return ('' + str).replace(/\\x1B\\[\\d+m/g, '');\n};\n\n// eslint-disable-next-line no-unused-vars\nvar stylize = colors.stylize = function stylize(str, style) {\n  if (!colors.enabled) {\n    return str+'';\n  }\n\n  var styleMap = ansiStyles[style];\n\n  // Stylize should work for non-ANSI styles, too\n  if(!styleMap && style in colors){\n    // Style maps like trap operate as functions on strings;\n    // they don't have properties like open or close.\n    return colors[style](str);\n  }\n\n  return styleMap.open + str + styleMap.close;\n};\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\nvar escapeStringRegexp = function(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return str.replace(matchOperatorsRe, '\\\\$&');\n};\n\nfunction build(_styles) {\n  var builder = function builder() {\n    return applyStyle.apply(builder, arguments);\n  };\n  builder._styles = _styles;\n  // __proto__ is used because we must return a function, but there is\n  // no way to create a function with a different prototype.\n  builder.__proto__ = proto;\n  return builder;\n}\n\nvar styles = (function() {\n  var ret = {};\n  ansiStyles.grey = ansiStyles.gray;\n  Object.keys(ansiStyles).forEach(function(key) {\n    ansiStyles[key].closeRe =\n      new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n    ret[key] = {\n      get: function() {\n        return build(this._styles.concat(key));\n      },\n    };\n  });\n  return ret;\n})();\n\nvar proto = defineProps(function colors() {}, styles);\n\nfunction applyStyle() {\n  var args = Array.prototype.slice.call(arguments);\n\n  var str = args.map(function(arg) {\n    // Use weak equality check so we can colorize null/undefined in safe mode\n    if (arg != null && arg.constructor === String) {\n      return arg;\n    } else {\n      return util.inspect(arg);\n    }\n  }).join(' ');\n\n  if (!colors.enabled || !str) {\n    return str;\n  }\n\n  var newLinesPresent = str.indexOf('\\n') != -1;\n\n  var nestedStyles = this._styles;\n\n  var i = nestedStyles.length;\n  while (i--) {\n    var code = ansiStyles[nestedStyles[i]];\n    str = code.open + str.replace(code.closeRe, code.open) + code.close;\n    if (newLinesPresent) {\n      str = str.replace(newLineRegex, function(match) {\n        return code.close + match + code.open;\n      });\n    }\n  }\n\n  return str;\n}\n\ncolors.setTheme = function(theme) {\n  if (typeof theme === 'string') {\n    console.log('colors.setTheme now only accepts an object, not a string.  ' +\n      'If you are trying to set a theme from a file, it is now your (the ' +\n      'caller\\'s) responsibility to require the file.  The old syntax ' +\n      'looked like colors.setTheme(__dirname + ' +\n      '\\'/../themes/generic-logging.js\\'); The new syntax looks like '+\n      'colors.setTheme(require(__dirname + ' +\n      '\\'/../themes/generic-logging.js\\'));');\n    return;\n  }\n  for (var style in theme) {\n    (function(style) {\n      colors[style] = function(str) {\n        if (typeof theme[style] === 'object') {\n          var out = str;\n          for (var i in theme[style]) {\n            out = colors[theme[style][i]](out);\n          }\n          return out;\n        }\n        return colors[theme[style]](str);\n      };\n    })(style);\n  }\n};\n\nfunction init() {\n  var ret = {};\n  Object.keys(styles).forEach(function(name) {\n    ret[name] = {\n      get: function() {\n        return build([name]);\n      },\n    };\n  });\n  return ret;\n}\n\nvar sequencer = function sequencer(map, str) {\n  var exploded = str.split('');\n  exploded = exploded.map(map);\n  return exploded.join('');\n};\n\n// custom formatter methods\ncolors.trap = require('./custom/trap');\ncolors.zalgo = require('./custom/zalgo');\n\n// maps\ncolors.maps = {};\ncolors.maps.america = require('./maps/america')(colors);\ncolors.maps.zebra = require('./maps/zebra')(colors);\ncolors.maps.rainbow = require('./maps/rainbow')(colors);\ncolors.maps.random = require('./maps/random')(colors);\n\nfor (var map in colors.maps) {\n  (function(map) {\n    colors[map] = function(str) {\n      return sequencer(colors.maps[map], str);\n    };\n  })(map);\n}\n\ndefineProps(colors, init());\n","var Debugger = require(\"./lib/debugger\").default;\n\nmodule.exports = Debugger;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger\");\n\nimport Session from \"./session\";\n\nimport { createNestedSelector } from \"reselect-tree\";\n\nimport dataSelector from \"./data/selectors\";\nimport txlogSelector from \"./txlog/selectors\";\nimport astSelector from \"./ast/selectors\";\nimport traceSelector from \"./trace/selectors\";\nimport evmSelector from \"./evm/selectors\";\nimport soliditySelector from \"./solidity/selectors\";\nimport sessionSelector from \"./session/selectors\";\nimport stacktraceSelector from \"./stacktrace/selectors\";\nimport controllerSelector from \"./controller/selectors\";\n\nimport { Compilations } from \"@truffle/codec\";\n\nconst Debugger = {\n  /**\n   * Instantiates a Debugger for a given transaction hash.\n   * Throws on failure.  If you want a more failure-tolerant method,\n   * use forProject and then do a session.load inside a try.\n   *\n   * @param {String} txHash - transaction hash with leading \"0x\"\n   * @param {{contracts: Array<Artifact>, files: Array<String>, provider: Web3Provider, compilations: Array<Compilation>}} options -\n   * @return {Debugger} instance\n   */\n  forTx: async function (txHash, options = {}) {\n    let { contracts, files, provider, compilations, lightMode } = options;\n    if (!compilations) {\n      compilations = Compilations.Utils.shimArtifacts(contracts, files);\n    }\n    let session = new Session(compilations, provider, { lightMode }, txHash);\n\n    await session.ready();\n\n    return session;\n  },\n\n  /*\n   * Instantiates a Debugger for a given project (with no transaction loaded)\n   *\n   * @param {{contracts: Array<Artifact>, files: Array<String>, provider: Web3Provider, compilations: Array<Compilation>}} options -\n   * @return {Debugger} instance\n   */\n  forProject: async function (options = {}) {\n    let { contracts, files, provider, compilations, lightMode } = options;\n    if (!compilations) {\n      compilations = Compilations.Utils.shimArtifacts(contracts, files);\n    }\n    let session = new Session(compilations, provider, { lightMode });\n\n    await session.ready();\n\n    return session;\n  },\n\n  /**\n   * Exported selectors\n   *\n   * See individual selector docs for full listing\n   *\n   * @example\n   * Debugger.selectors.ast.current.tree\n   *\n   * @example\n   * Debugger.selectors.solidity.current.instruction\n   *\n   * @example\n   * Debugger.selectors.trace.steps\n   */\n  get selectors() {\n    return createNestedSelector({\n      ast: astSelector,\n      data: dataSelector,\n      txlog: txlogSelector,\n      trace: traceSelector,\n      evm: evmSelector,\n      solidity: soliditySelector,\n      stacktrace: stacktraceSelector,\n      session: sessionSelector,\n      controller: controllerSelector\n    });\n  }\n};\n\nexport default Debugger;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session\");\n\nimport * as Abi from \"@truffle/abi-utils\";\nimport * as Codec from \"@truffle/codec\";\nimport { keccak256, stableKeccak256 } from \"lib/helpers\";\n\nimport configureStore from \"lib/store\";\n\nimport * as controller from \"lib/controller/actions\";\nimport * as actions from \"./actions\";\nimport data from \"lib/data/selectors\";\nimport txlog from \"lib/txlog/selectors\";\nimport stacktrace from \"lib/stacktrace/selectors\";\nimport session from \"lib/session/selectors\";\nimport * as dataSagas from \"lib/data/sagas\";\nimport * as controllerSagas from \"lib/controller/sagas\";\nimport * as sagas from \"./sagas\";\nimport controllerSelector from \"lib/controller/selectors\";\n\nimport { createNestedSelector } from \"reselect-tree\";\n\nimport ast from \"lib/ast/selectors\";\nimport trace from \"lib/trace/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport solidity from \"lib/solidity/selectors\";\n\nimport rootSaga from \"./sagas\";\nimport reducer from \"./reducers\";\n\nimport { Shims } from \"@truffle/compile-common\";\n\n/**\n * Debugger Session\n */\nexport default class Session {\n  /**\n   * @param {Array<Compilations>} compilations\n   * @param {Web3Provider} provider - web3 provider\n   * txHash parameter is now optional!\n   * @private\n   */\n  constructor(compilations, provider, moduleOptions, txHash) {\n    /**\n     * @private\n     */\n    let { store, sagaMiddleware } = configureStore(reducer, rootSaga, [\n      moduleOptions\n    ]);\n    this._store = store;\n    this._sagaMiddleware = sagaMiddleware;\n\n    let { contexts, sources } = Session.normalize(compilations);\n\n    // record contracts\n    this._store.dispatch(actions.recordContracts(contexts, sources));\n\n    //set up the ready listener\n    this._ready = new Promise((accept, reject) => {\n      const unsubscribe = this._store.subscribe(() => {\n        if (this.view(session.status.ready)) {\n          debug(\"ready!\");\n          unsubscribe();\n          accept();\n        } else if (this.view(session.status.errored)) {\n          debug(\"error!\");\n          unsubscribe();\n          reject(this.view(session.status.error));\n        }\n      });\n    });\n\n    //note that txHash is now optional\n    this._store.dispatch(actions.start(provider, txHash));\n  }\n\n  async ready() {\n    await this._ready;\n  }\n\n  async readyAgainAfterLoading(sessionAction) {\n    return new Promise((accept, reject) => {\n      let hasStartedWaiting = false;\n      debug(\"reready listener set up\");\n      const unsubscribe = this._store.subscribe(() => {\n        debug(\"reready?\");\n        if (hasStartedWaiting) {\n          if (this.view(session.status.ready)) {\n            debug(\"reready!\");\n            unsubscribe();\n            accept(true);\n          } else if (this.view(session.status.errored)) {\n            unsubscribe();\n            debug(\"error!\");\n            reject(this.view(session.status.error));\n          }\n        } else {\n          if (this.view(session.status.waiting)) {\n            debug(\"started waiting\");\n            hasStartedWaiting = true;\n          }\n          return;\n        }\n      });\n      this.dispatch(sessionAction);\n    });\n  }\n\n  /**\n   * Split up artifacts into \"contexts\" and \"sources\", dividing artifact\n   * data into appropriate buckets.\n   *\n   * Multiple contracts can be defined in the same source file, but have\n   * different bytecodes.\n   *\n   * (NOTE: now that this takes compilations, the splitting is largely already\n   * done.  However, there's still remaining work to do.)\n   *\n   * @private\n   */\n  static normalize(compilations) {\n    let contexts = [];\n    let sources = {\n      user: {}, //by compilation\n      internal: {} //by context\n    };\n\n    //we're actually going to ignore the passed-in IDs and make our own.\n    //note we'll set contextHash to null for user sources, and only set it\n    //for internal sources.\n    const makeSourceId = (compilationId, contextHash, index) =>\n      stableKeccak256({ compilationId, contextHash, index });\n\n    for (let compilation of compilations) {\n      if (compilation.unreliableSourceOrder) {\n        throw new Error(\n          `Error: Compilation ${compilation.id} has unreliable source order.`\n        );\n      }\n      let compiler = compilation.compiler; //note: we'll prefer one listed on contract or source\n      sources.user[compilation.id] = [];\n      for (let index in compilation.sources) {\n        //not the recommended way to iterate over an array,\n        //but the order doesn't matter here so it's safe\n        index = Number(index); //however due to the use of in we must explicitly convert to number\n        let source = compilation.sources[index];\n        if (!source) {\n          continue; //just for safety (in case there are gaps)\n        }\n        let ast = source.ast;\n        if (ast && !ast.nodeType) {\n          ast = undefined; //HACK: remove Vyper asts for now\n        }\n        sources.user[compilation.id][index] = {\n          ...source,\n          ast,\n          compiler: source.compiler || compiler,\n          compilationId: compilation.id,\n          index,\n          id: makeSourceId(compilation.id, null, index),\n          internal: false\n        };\n      }\n\n      for (let contract of compilation.contracts) {\n        let {\n          contractName,\n          bytecode: binary,\n          sourceMap,\n          deployedBytecode: deployedBinary,\n          deployedSourceMap,\n          immutableReferences,\n          abi,\n          compiler,\n          primarySourceId,\n          generatedSources,\n          deployedGeneratedSources\n        } = contract;\n        debug(\"contractName: %s\", contractName);\n\n        //hopefully we can get rid of this step eventually, but not yet\n        if (typeof binary === \"object\") {\n          binary = Shims.NewToLegacy.forBytecode(binary);\n        }\n        if (typeof deployedBinary === \"object\") {\n          deployedBinary = Shims.NewToLegacy.forBytecode(deployedBinary);\n        }\n\n        let primarySourceIndex;\n        if (primarySourceId !== undefined) {\n          //I'm assuming this finds it! it had better!\n          primarySourceIndex = compilation.sources.findIndex(\n            source => source && source.id === primarySourceId\n          );\n        }\n        //otherwise leave it undefined\n\n        //now: we need to find the contract node.\n        //note: ideally we'd hold this off till later, but that would break the\n        //direction of the evm/solidity dependence, so we do it now\n        const contractNode = Codec.Compilations.Utils.getContractNode(\n          contract,\n          compilation\n        );\n\n        const contractId = contractNode ? contractNode.id : undefined;\n        const contractKind = contractNode\n          ? contractNode.contractKind\n          : undefined;\n        const linearizedBaseContracts = contractNode\n          ? contractNode.linearizedBaseContracts\n          : undefined;\n        abi = Abi.normalize(abi); //let's handle this up front\n\n        debug(\"contractName %s\", contractName);\n        debug(\"sourceMap %o\", sourceMap);\n        debug(\"compiler %o\", compiler);\n        debug(\"abi %o\", abi);\n\n        //note: simpleShimSourceMap does not handle the case where we can't just extract\n        //the Solidity-style source map\n        sourceMap = Codec.Compilations.Utils.simpleShimSourceMap(sourceMap);\n        deployedSourceMap = Codec.Compilations.Utils.simpleShimSourceMap(\n          deployedSourceMap\n        );\n\n        if (binary && binary != \"0x\") {\n          //NOTE: we take hash as *string*, not as bytes, because the binary may\n          //contain link references!\n          const contextHash = keccak256({\n            type: \"string\",\n            value: binary\n          });\n          contexts.push({\n            context: contextHash,\n            contractName,\n            binary,\n            sourceMap,\n            primarySource: primarySourceIndex,\n            abi,\n            compiler,\n            compilationId: compilation.id,\n            contractId,\n            contractKind,\n            linearizedBaseContracts,\n            isConstructor: true\n          });\n          if (generatedSources) {\n            sources.internal[contextHash] = [];\n            for (let index in generatedSources) {\n              index = Number(index); //it comes out as a string due to in, so let's fix that\n              const source = generatedSources[index];\n              sources.internal[contextHash][index] = {\n                ...source,\n                compiler: source.compiler || compiler,\n                compilationId: compilation.id,\n                index,\n                id: makeSourceId(compilation.id, contextHash, index),\n                internal: true,\n                internalFor: contextHash\n              };\n            }\n          }\n        }\n\n        if (deployedBinary && deployedBinary != \"0x\") {\n          //NOTE: we take hash as *string*, not as bytes, because the binary may\n          //contain link references!\n          const contextHash = keccak256({\n            type: \"string\",\n            value: deployedBinary\n          });\n          contexts.push({\n            context: contextHash,\n            contractName,\n            binary: deployedBinary,\n            sourceMap: deployedSourceMap,\n            primarySource: primarySourceIndex,\n            immutableReferences,\n            abi,\n            compiler,\n            compilationId: compilation.id,\n            contractId,\n            contractKind,\n            linearizedBaseContracts,\n            isConstructor: false\n          });\n          if (deployedGeneratedSources) {\n            sources.internal[contextHash] = [];\n            for (let index in deployedGeneratedSources) {\n              index = Number(index); //it comes out as a string due to in, so let's fix that\n              const source = deployedGeneratedSources[index];\n              sources.internal[contextHash][index] = {\n                ...source,\n                compiler: source.compiler || compiler,\n                compilationId: compilation.id,\n                index,\n                id: makeSourceId(compilation.id, contextHash, index),\n                internal: true,\n                internalFor: contextHash\n              };\n            }\n          }\n        }\n      }\n    }\n\n    //now: turn contexts from array into object\n    contexts = Object.assign(\n      {},\n      ...contexts.map(context => ({\n        [context.context]: {\n          ...context\n        }\n      }))\n    );\n\n    //normalize contexts\n    //HACK: the type of contexts doesn't actually match!!\n    //fortunately it's good enough to work\n    contexts = Codec.Contexts.Utils.normalizeContexts(contexts);\n\n    return { contexts, sources };\n  }\n\n  get state() {\n    return this._store.getState();\n  }\n\n  view(selector) {\n    return selector(this.state);\n  }\n\n  async dispatch(action) {\n    this._store.dispatch(action);\n\n    return true;\n  }\n\n  /**\n   * @private\n   * Allows running any saga -- for internal use only!\n   * Using this could seriously screw up the debugger state if you\n   * don't know what you're doing!\n   */\n  async _runSaga(saga, ...args) {\n    return await this._sagaMiddleware.run(saga, ...args).toPromise();\n  }\n\n  async interrupt() {\n    await this.dispatch(actions.interrupt());\n    await this.dispatch(controller.interrupt());\n  }\n\n  async doneStepping(stepperAction) {\n    return new Promise(resolve => {\n      let hasStarted = false;\n      const unsubscribe = this._store.subscribe(() => {\n        const isStepping = this.view(controllerSelector.isStepping);\n\n        if (isStepping && !hasStarted) {\n          hasStarted = true;\n          return;\n        }\n\n        if (!isStepping && hasStarted) {\n          unsubscribe();\n          resolve(true);\n        }\n      });\n      this.dispatch(stepperAction);\n    });\n  }\n\n  //returns true on success, false on already loaded; throws on failure\n  async load(txHash) {\n    if (this.view(session.status.loaded)) {\n      return false;\n    }\n    return await this.readyAgainAfterLoading(actions.loadTransaction(txHash));\n  }\n\n  //returns true on success, false on already unloaded\n  async unload() {\n    if (!this.view(session.status.loaded)) {\n      return false;\n    }\n    debug(\"unloading\");\n    await this._runSaga(sagas.unload);\n    return true;\n  }\n\n  //Note: count is an optional argument; default behavior is to advance 1\n  async advance(count) {\n    return await this.doneStepping(controller.advance(count));\n  }\n\n  async stepNext() {\n    return await this.doneStepping(controller.stepNext());\n  }\n\n  async stepOver() {\n    return await this.doneStepping(controller.stepOver());\n  }\n\n  async stepInto() {\n    return await this.doneStepping(controller.stepInto());\n  }\n\n  async stepOut() {\n    return await this.doneStepping(controller.stepOut());\n  }\n\n  async reset() {\n    let loaded = this.view(session.status.loaded);\n    if (!loaded) {\n      return;\n    }\n    return await this._runSaga(controllerSagas.reset);\n  }\n\n  //NOTE: breakpoints is an OPTIONAL argument for if you want to supply your\n  //own list of breakpoints; leave it out to use the internal one (as\n  //controlled by the functions below)\n  async continueUntilBreakpoint(breakpoints) {\n    return await this.doneStepping(\n      controller.continueUntilBreakpoint(breakpoints)\n    );\n  }\n\n  async addBreakpoint(breakpoint) {\n    return await this.dispatch(controller.addBreakpoint(breakpoint));\n  }\n\n  async removeBreakpoint(breakpoint) {\n    return await this.dispatch(controller.removeBreakpoint(breakpoint));\n  }\n\n  async removeAllBreakpoints() {\n    return await this.dispatch(controller.removeAllBreakpoints());\n  }\n\n  async setInternalStepping(active) {\n    return await this.dispatch(controller.setInternalStepping(active));\n  }\n\n  //deprecated -- decode is now *always* ready!\n  async decodeReady() {\n    return true;\n  }\n\n  async variable(name) {\n    const definitions = this.view(data.current.identifiers.definitions);\n    const refs = this.view(data.current.identifiers.refs);\n    const compilationId = this.view(data.current.compilationId);\n    debug(\"name: %s\", name);\n    debug(\"refs: %O\", refs);\n    debug(\"definitions: %o\", definitions);\n\n    return await this._runSaga(\n      dataSagas.decode,\n      definitions[name],\n      refs[name],\n      compilationId\n    );\n  }\n\n  async variables() {\n    if (!this.view(session.status.loaded)) {\n      return {};\n    }\n    let definitions = this.view(data.current.identifiers.definitions);\n    let refs = this.view(data.current.identifiers.refs);\n    let compilationId = this.view(data.current.compilationId);\n    let decoded = {};\n    for (let [identifier, ref] of Object.entries(refs)) {\n      if (identifier in definitions) {\n        decoded[identifier] = await this._runSaga(\n          dataSagas.decode,\n          definitions[identifier],\n          ref,\n          compilationId\n        );\n      }\n    }\n    return decoded;\n  }\n\n  async returnValue() {\n    if (\n      !this.view(session.status.loaded) ||\n      !this.view(evm.current.step.isHalting)\n    ) {\n      return null;\n    }\n    return await this._runSaga(dataSagas.decodeReturnValue);\n  }\n\n  callstack() {\n    if (!this.view(session.status.loaded)) {\n      return null;\n    }\n    return this.view(stacktrace.current.report);\n  }\n\n  stacktrace() {\n    if (!this.view(session.status.loaded)) {\n      return null;\n    }\n    return this.view(stacktrace.current.finalReport);\n  }\n\n  connect() {\n    return this; //for compatibility\n  }\n\n  async addExternalCompilations(compilations) {\n    let { contexts, sources } = Session.normalize(compilations);\n    return await this.dispatch(actions.addCompilations(sources, contexts));\n  }\n\n  async startFullMode() {\n    return await this.dispatch(actions.startFullMode());\n  }\n\n  get selectors() {\n    return createNestedSelector({\n      ast,\n      data,\n      txlog,\n      trace,\n      evm,\n      solidity,\n      stacktrace,\n      session,\n      controller: controllerSelector\n    });\n  }\n}\n","module.exports = require(\"babel-runtime/core-js/promise\");","module.exports = require(\"@truffle/abi-utils\");","module.exports = require(\"json-stable-stringify\");","if (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./production\");\n} else if (process.env.NODE_ENV === \"test\") {\n  module.exports = require(\"./test\");\n} else {\n  module.exports = require(\"./development\");\n}\n","import configureStore from \"./common\";\nexport default configureStore;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:store:common\");\n\nimport { compose, createStore, applyMiddleware } from \"redux\";\nimport createSagaMiddleware from \"redux-saga\";\n\nexport default function configureStore(\n  reducer,\n  saga,\n  sagaArgs,\n  initialState,\n  composeEnhancers\n) {\n  const sagaMiddleware = createSagaMiddleware();\n\n  if (!composeEnhancers) {\n    composeEnhancers = compose;\n  }\n\n  let store = createStore(\n    reducer,\n    initialState,\n\n    composeEnhancers(applyMiddleware(sagaMiddleware))\n  );\n\n  sagaMiddleware.run(saga, ...sagaArgs);\n\n  return { store, sagaMiddleware };\n}\n","module.exports = require(\"redux-saga\");","module.exports = require(\"lodash.merge\");","module.exports = require(\"@truffle/source-map-utils\");","module.exports = require(\"lodash.zipwith\");","module.exports = require(\"babel-runtime/core-js/set\");","export const INIT_WEB3 = \"INIT_WEB3\";\nexport function init(provider) {\n  return {\n    type: INIT_WEB3,\n    provider\n  };\n}\n\nexport const INSPECT = \"INSPECT_TRANSACTION\";\nexport function inspect(txHash) {\n  return {\n    type: INSPECT,\n    txHash\n  };\n}\n\nexport const FETCH_BINARY = \"FETCH_BINARY\";\nexport function fetchBinary(address, block) {\n  return {\n    type: FETCH_BINARY,\n    address,\n    block //optional\n  };\n}\n\nexport const RECEIVE_BINARY = \"RECEIVE_BINARY\";\nexport function receiveBinary(address, binary) {\n  return {\n    type: RECEIVE_BINARY,\n    address,\n    binary\n  };\n}\n\nexport const RECEIVE_TRACE = \"RECEIVE_TRACE\";\nexport function receiveTrace(trace) {\n  return {\n    type: RECEIVE_TRACE,\n    trace\n  };\n}\n\nexport const RECEIVE_CALL = \"RECEIVE_CALL\";\nexport function receiveCall({\n  address,\n  binary,\n  data,\n  storageAddress,\n  status,\n  sender,\n  value,\n  gasprice,\n  block\n}) {\n  return {\n    type: RECEIVE_CALL,\n    address,\n    binary,\n    data,\n    storageAddress,\n    status, //only used for creation calls at present!\n    sender,\n    value,\n    gasprice,\n    block\n  };\n}\n\nexport const ERROR_WEB3 = \"ERROR_WEB3\";\nexport function error(error) {\n  return {\n    type: ERROR_WEB3,\n    error\n  };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:web3:adapter\");\n\nimport Web3 from \"web3\";\nimport { promisify } from \"util\";\n\nexport default class Web3Adapter {\n  constructor(provider) {\n    this.web3 = new Web3(provider);\n  }\n\n  async getTrace(txHash) {\n    let result = await promisify(this.web3.currentProvider.send)(\n      //send *only* uses callbacks, so we use promsifiy to make things more\n      //readable\n      {\n        jsonrpc: \"2.0\",\n        method: \"debug_traceTransaction\",\n        params: [txHash, {}],\n        id: new Date().getTime()\n      }\n    );\n    if (!result.result) {\n      //we assume if there's no result then there is an error.\n      //note: some nodes may return an error even if there is a\n      //usable result, so we don't assume that the presence of\n      //an error means we should throw an error, but rather check\n      //for the absence of a result.\n      throw new Error(result.error.message);\n    } else {\n      return result.result.structLogs;\n    }\n  }\n\n  async getTransaction(txHash) {\n    return await this.web3.eth.getTransaction(txHash);\n  }\n\n  async getReceipt(txHash) {\n    return await this.web3.eth.getTransactionReceipt(txHash);\n  }\n\n  async getBlock(blockNumberOrHash) {\n    return await this.web3.eth.getBlock(blockNumberOrHash);\n  }\n\n  async getChainId() {\n    return await this.web3.eth.getChainId();\n  }\n\n  /**\n   * getDeployedCode - get the deployed code for an address from the client\n   * NOTE: the block argument is optional\n   * @param  {String} address\n   * @return {String}         deployedBinary\n   */\n  async getDeployedCode(address, block) {\n    debug(\"getting deployed code for %s\", address);\n    let code = await this.web3.eth.getCode(address, block);\n    return code === \"0x0\" ? \"0x\" : code;\n  }\n}\n","module.exports = require(\"lodash.sum\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:sagas\");\n\nimport { call, all, fork, take, put, race, select } from \"redux-saga/effects\";\n\nimport { prefixName } from \"lib/helpers\";\n\nimport * as ast from \"lib/ast/sagas\";\nimport * as controller from \"lib/controller/sagas\";\nimport * as solidity from \"lib/solidity/sagas\";\nimport * as stacktrace from \"lib/stacktrace/sagas\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as trace from \"lib/trace/sagas\";\nimport * as data from \"lib/data/sagas\";\nimport * as txlog from \"lib/txlog/sagas\";\nimport * as web3 from \"lib/web3/sagas\";\n\nimport * as actions from \"../actions\";\n\nimport session from \"../selectors\";\n\nconst LOAD_SAGAS = {\n  [actions.LOAD_TRANSACTION]: load,\n  //will also add reconstruct action/saga once it exists\n  //the following ones don't really relate to loading, but, oh well\n  [actions.ADD_COMPILATIONS]: addCompilations,\n  [actions.START_FULL_MODE]: startFullMode\n};\n\nfunction* listenerSaga() {\n  while (true) {\n    let action = yield take(Object.keys(LOAD_SAGAS));\n    let saga = LOAD_SAGAS[action.type];\n\n    yield put(actions.wait());\n    yield race({\n      exec: call(saga, action), //not all will use this\n      interrupt: take(actions.INTERRUPT)\n    });\n    yield put(actions.ready());\n  }\n}\n\nexport function* saga(moduleOptions) {\n  debug(\"starting listeners\");\n  yield* forkListeners(moduleOptions);\n\n  // receiving & saving contracts into state\n  debug(\"waiting for contract information\");\n  let { contexts, sources } = yield take(actions.RECORD_CONTRACTS);\n\n  debug(\"recording contract binaries\");\n  yield* recordContexts(contexts);\n\n  debug(\"recording contract sources\");\n  yield* recordSources(sources);\n\n  debug(\"waiting for start\");\n  // wait for start signal\n  let { txHash, provider } = yield take(actions.START);\n  debug(\"starting\");\n\n  if (!moduleOptions.lightMode) {\n    debug(\"visiting ASTs\");\n    // visit asts\n    yield* ast.visitAll();\n\n    //save allocation table\n    debug(\"saving allocation table\");\n    yield* data.recordAllocations();\n    //note: we don't need to explicitly set full mode, it's the default\n  } else {\n    debug(\"setting light mode\");\n    yield put(actions.setLightMode());\n  }\n\n  //initialize web3 adapter\n  debug(\"initializing adapter\");\n  yield* web3.init(provider);\n\n  //process transaction (if there is one)\n  //(note: this part may also set the error state)\n  if (txHash !== undefined) {\n    yield* processTransaction(txHash);\n  }\n\n  debug(\"readying\");\n  // signal that commands can begin\n  yield* ready();\n}\n\n//please only use in light mode!\nfunction* addCompilations({ sources, contexts }) {\n  debug(\"recording contract binaries\");\n  yield* recordContexts(contexts);\n\n  debug(\"recording contract sources\");\n  yield* recordSources(sources);\n\n  debug(\"refreshing instances\");\n  yield* evm.refreshInstances();\n}\n\nfunction* startFullMode() {\n  debug(\"session: %O\", session);\n  let lightMode = yield select(session.status.lightMode);\n  if (!lightMode) {\n    //better not start this twice!\n    return;\n  }\n  debug(\"turning on data & txlog listeners\");\n  const listenersToActivate = [data.saga, txlog.saga];\n  for (let listener of listenersToActivate) {\n    yield fork(listener);\n  }\n\n  debug(\"visiting ASTs\");\n  // visit asts\n  yield* ast.visitAll();\n\n  //save allocation table\n  debug(\"saving allocation table\");\n  yield* data.recordAllocations();\n\n  yield* trace.addSubmoduleToCount(listenersToActivate.length);\n\n  //begin any full-mode modules that need beginning\n  yield* txlog.begin();\n\n  yield put(actions.setFullMode());\n}\n\nexport function* processTransaction(txHash) {\n  // process transaction\n  debug(\"fetching transaction info\");\n  let err = yield* fetchTx(txHash);\n  if (err) {\n    debug(\"error %o\", err);\n    yield* error(err);\n  }\n}\n\nexport default prefixName(\"session\", saga);\n\nfunction* forkListeners(moduleOptions) {\n  yield fork(listenerSaga); //session listener; this one is separate, sorry\n  //(I didn't want to mess w/ the existing structure of defaults)\n  let mainApps = [evm, solidity, stacktrace];\n  if (!moduleOptions.lightMode) {\n    mainApps.push(data);\n    mainApps.push(txlog);\n  }\n  let otherApps = [trace, controller, web3];\n  const submoduleCount = mainApps.length;\n  const apps = mainApps.concat(otherApps);\n  yield* trace.setSubmoduleCount(submoduleCount);\n  return yield all(apps.map(app => fork(app.saga)));\n}\n\nfunction* fetchTx(txHash) {\n  let result = yield* web3.inspectTransaction(txHash);\n  debug(\"result %o\", result);\n\n  if (result.error) {\n    return result.error;\n  }\n\n  //get addresses created/called during transaction\n  debug(\"processing trace for addresses\");\n  let { calls, creations, selfdestructs } = yield* trace.processTrace(\n    result.trace\n  );\n  //add in the address of the call itself (if a call)\n  if (result.address && !calls.includes(result.address)) {\n    calls.push(result.address);\n  }\n\n  //if a create, only add in address if it was successful\n  if (result.binary && result.status && !(result.storageAddress in creations)) {\n    creations[result.storageAddress] = result.binary;\n  }\n\n  let blockNumber = result.block.number.toString(); //a BN is not accepted\n  let addresses = [...calls, ...selfdestructs, ...Object.keys(creations)];\n  let nonCallStartIndex = calls.length;\n  debug(\"obtaining binaries\");\n  let binaries = yield* web3.obtainBinaries(addresses, blockNumber);\n\n  debug(\"recording instances\");\n  yield all(\n    addresses.map((address, index) =>\n      call(\n        recordInstance,\n        address,\n        binaries[index],\n        index >= nonCallStartIndex,\n        creations[address] //may be undefined\n      )\n    )\n  );\n\n  debug(\"sending initial call\");\n  yield* evm.begin(result); //note: this must occur *before* the other ones!\n  yield* solidity.begin();\n  yield* stacktrace.begin();\n  if (!(yield select(session.status.lightMode))) {\n    //full-mode-only modules\n    yield* txlog.begin();\n  }\n}\n\nfunction* recordContexts(contexts) {\n  for (let context of Object.values(contexts)) {\n    yield* evm.addContext(context);\n  }\n}\n\nfunction* recordSources(sources) {\n  yield* solidity.addSources(sources);\n}\n\n//creationBinary can be omitted; should only be used for creations\nfunction* recordInstance(\n  address,\n  binary,\n  affectedInstanceOnly,\n  creationBinary\n) {\n  yield* evm.addAffectedInstance(address, binary, creationBinary);\n  if (!affectedInstanceOnly) {\n    //add it as a real codex instance\n    yield* evm.addInstance(address, binary);\n  }\n}\n\nfunction* ready() {\n  yield put(actions.ready());\n}\n\nfunction* error(err) {\n  yield put(actions.error(err));\n}\n\n//we'll just unload all modules regardless of which ones are currently present...\nexport function* unload() {\n  debug(\"unloading\");\n  yield* data.reset();\n  yield* solidity.unload();\n  yield* evm.unload();\n  yield* trace.unload();\n  yield* stacktrace.unload();\n  yield* txlog.unload();\n  yield put(actions.unloadTransaction());\n}\n\n//note that load takes an action as its argument, which is why it's separate\n//from processTransaction\nfunction* load({ txHash }) {\n  yield* processTransaction(txHash);\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:ast:sagas\");\n\nimport { all, call, select } from \"redux-saga/effects\";\n\nimport * as data from \"lib/data/sagas\";\n\nimport ast from \"../selectors\";\n\nimport jsonpointer from \"json-pointer\";\n\nfunction* walk(sourceId, sourceIndex, node, pointer = \"\", parentId = null) {\n  debug(\"walking %s %o %o\", sourceId, pointer, node);\n\n  yield* handleEnter(sourceId, sourceIndex, node, pointer, parentId);\n\n  if (Array.isArray(node)) {\n    for (let [i, child] of node.entries()) {\n      yield* walk(sourceId, sourceIndex, child, `${pointer}/${i}`, parentId);\n    }\n  } else if (node && node.nodeType && node.nodeType.startsWith(\"Yul\")) {\n    //defer to yul handler!\n    yield* handleYul(sourceId, sourceIndex, node, pointer, parentId);\n  } else if (node instanceof Object) {\n    for (let [key, child] of Object.entries(node)) {\n      yield* walk(sourceId, sourceIndex, child, `${pointer}/${key}`, node.id);\n    }\n  }\n\n  yield* handleExit(sourceId, sourceIndex, node, pointer);\n}\n\nfunction* handleEnter(sourceId, sourceIndex, node, pointer, parentId) {\n  debug(\"entering %s %s\", sourceId, pointer);\n\n  if (!(node instanceof Object)) {\n    return;\n  }\n\n  if (node.id !== undefined) {\n    debug(\"%s recording scope %s\", pointer, node.id);\n    yield* data.scope(node.id, pointer, parentId, sourceIndex, sourceId);\n  }\n\n  switch (node.nodeType) {\n    case \"VariableDeclaration\":\n      debug(\"%s recording variable %o\", pointer, node);\n      yield* data.declare(node, sourceId);\n      break;\n    case \"ContractDefinition\":\n    case \"StructDefinition\":\n    case \"EnumDefinition\":\n      debug(\"%s recording type %o\", pointer, node);\n      yield* data.defineType(node, sourceId);\n      break;\n    case \"EventDefinition\":\n    case \"ErrorDefinition\":\n      debug(\"%s recording type %o\", pointer, node);\n      yield* data.defineTaggedOutput(node, sourceId);\n      break;\n  }\n}\n\nfunction* handleExit(sourceId, sourceIndex, node, pointer) {\n  debug(\"exiting %s %s\", sourceId, pointer);\n\n  // no-op right now\n}\n\nexport function* visitAll() {\n  const sources = yield select(ast.views.sources);\n\n  yield all(\n    sources\n      .filter(({ ast }) => ast)\n      .map(({ ast, id, index }) => call(walk, id, index, ast))\n  );\n\n  debug(\"done visiting\");\n}\n\nfunction* handleYul(sourceId, sourceIndex, node, pointer, parentId) {\n  yield* yulWalk(sourceId, sourceIndex, node, pointer, node, pointer, parentId);\n}\n\nfunction* yulWalk(\n  sourceId,\n  sourceIndex,\n  node,\n  pointer,\n  base,\n  basePointer,\n  parentId = undefined\n) {\n  yield* handleYulEnter(\n    sourceId,\n    sourceIndex,\n    node,\n    pointer,\n    base,\n    basePointer,\n    parentId\n  );\n\n  if (Array.isArray(node)) {\n    for (let [i, child] of node.entries()) {\n      yield* yulWalk(\n        sourceId,\n        sourceIndex,\n        child,\n        `${pointer}/${i}`,\n        base,\n        basePointer\n      ); //no parent ID for subnodes\n    }\n  } else if (node instanceof Object) {\n    for (let [key, child] of Object.entries(node)) {\n      yield* yulWalk(\n        sourceId,\n        sourceIndex,\n        child,\n        `${pointer}/${key}`,\n        base,\n        basePointer\n      ); //no parent ID for subnodes\n    }\n  }\n\n  yield* handleYulExit(\n    sourceId,\n    sourceIndex,\n    node,\n    pointer,\n    base,\n    basePointer,\n    parentId\n  );\n}\n\nfunction* handleYulExit(\n  sourceId,\n  sourceIndex,\n  node,\n  pointer,\n  base,\n  basePointer,\n  _parentId = undefined\n) {\n  debug(\"exiting %s %s\", sourceId, pointer);\n\n  // no-op right now\n}\n\nfunction* handleYulEnter(\n  sourceId,\n  sourceIndex,\n  node,\n  pointer,\n  base,\n  basePointer,\n  parentId = undefined\n) {\n  debug(\"entering %s %s\", sourceId, pointer);\n\n  if (!node) {\n    return;\n  }\n\n  if (node.src !== undefined) {\n    debug(\"scoping!\");\n    yield* data.yulScope(pointer, sourceIndex, sourceId, parentId);\n  }\n\n  if (node.nodeType === \"YulTypedName\") {\n    let scopePointer = findYulScopePointer(node, pointer, base, basePointer);\n    yield* data.yulDeclare(node, pointer, scopePointer, sourceIndex, sourceId);\n  }\n}\n\nfunction findYulScopePointer(node, pointer, base, basePointer) {\n  //walk upward until we find a YulBlock or YulFunctionDefinition,\n  //with a special case for YulForLoop\n  debug(\"pointer: %s\", pointer);\n  debug(\"basePointer: %s\", basePointer);\n  let relativePointer = pointer.slice(basePointer.length);\n  debug(\"relativePointer: %s\", relativePointer);\n  let relativeParentPointer = relativePointer.replace(/\\/[^/]*$/, \"\"); //chop off last element\n  let parentPointer = basePointer + relativeParentPointer; //make it absolute again\n  debug(\"parentPointer: %s\", parentPointer);\n  let parent = jsonpointer.get(base, relativeParentPointer);\n  //NOTE: if node === base, then we'll just get parent = node,\n  //but that's fine, since we necessarily have base.nodeType === \"YulBlock\"\n  //(and the real parent of base is certainly not a for loop!)\n  if (node.nodeType === \"YulBlock\") {\n    if (parent.nodeType === \"YulForLoop\") {\n      if (pointer === `${parentPointer}/pre`) {\n        //variables declared in the pre block of a for loop\n        //are visible across the entire for loop\n        return parentPointer;\n      } else {\n        return pointer;\n      }\n    } else {\n      return pointer;\n    }\n  } else if (node.nodeType === \"YulFunctionDefinition\") {\n    return pointer;\n  } else {\n    return findYulScopePointer(parent, parentPointer, base, basePointer);\n  }\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport data from \"lib/data/reducers\";\nimport evm from \"lib/evm/reducers\";\nimport solidity from \"lib/solidity/reducers\";\nimport trace from \"lib/trace/reducers\";\nimport controller from \"lib/controller/reducers\";\nimport stacktrace from \"lib/stacktrace/reducers\";\nimport txlog from \"lib/txlog/reducers\";\n\nimport * as actions from \"./actions\";\n\nfunction ready(state = false, action) {\n  switch (action.type) {\n    case actions.READY:\n      debug(\"readying\");\n      return true;\n\n    case actions.WAIT:\n      return false;\n\n    default:\n      return state;\n  }\n}\n\nfunction lastLoadingError(state = null, action) {\n  switch (action.type) {\n    case actions.ERROR:\n      debug(\"error: %o\", action.error);\n      return action.error;\n\n    case actions.WAIT:\n      return null;\n\n    default:\n      return state;\n  }\n}\n\nfunction transaction(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_TRANSACTION:\n      return action.transaction;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction receipt(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_RECEIPT:\n      return action.receipt;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction block(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_BLOCK:\n      return action.block;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction lightMode(state = false, action) {\n  switch (action.type) {\n    case actions.SET_LIGHT_MODE:\n      return true;\n    case actions.SET_FULL_MODE:\n      return false;\n    default:\n      return state;\n  }\n}\n\nconst session = combineReducers({\n  ready,\n  lastLoadingError,\n  transaction,\n  receipt,\n  block,\n  lightMode\n});\n\nconst reduceState = combineReducers({\n  session,\n  data,\n  txlog,\n  evm,\n  solidity,\n  stacktrace,\n  trace,\n  controller\n});\n\nexport default reduceState;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nimport * as Codec from \"@truffle/codec\";\nimport { makeAssignment, makePath } from \"lib/helpers\";\n\nconst DEFAULT_SCOPES = {\n  bySourceId: {}\n};\n\nfunction scopes(state = DEFAULT_SCOPES, action) {\n  switch (action.type) {\n    case actions.SCOPE: {\n      const { sourceId, id, sourceIndex, parentId, pointer } = action;\n      const astRef = id !== undefined ? id : makePath(sourceIndex, pointer);\n      //astRef is used throughout the data saga.\n      //it identifies an AST node within a given compilation either by:\n      //1. its ast ID, if it has one, or\n      //2. a combination of its source index and its JSON pointer if not\n\n      return {\n        bySourceId: {\n          ...state.bySourceId,\n          [sourceId]: {\n            byAstRef: {\n              ...(state.bySourceId[sourceId] || {}).byAstRef,\n              [astRef]: {\n                ...(state.bySourceId[sourceId] || { byAstRef: {} }).byAstRef[\n                  astRef\n                ],\n                id,\n                parentId,\n                sourceIndex,\n                pointer,\n                sourceId\n              }\n            }\n          }\n        }\n      };\n    }\n\n    case actions.DECLARE: {\n      let { sourceId, name, astRef, scopeAstRef } = action;\n\n      //note: we can assume the scope already exists!\n      let scope = state.bySourceId[sourceId].byAstRef[scopeAstRef];\n      let variables = scope.variables || [];\n\n      return {\n        bySourceId: {\n          ...state.bySourceId,\n          [sourceId]: {\n            byAstRef: {\n              ...state.bySourceId[sourceId].byAstRef,\n              [scopeAstRef]: {\n                ...scope,\n                variables: [...variables, { name, astRef, sourceId }]\n              }\n            }\n          }\n        }\n      };\n    }\n\n    default:\n      return state;\n  }\n}\n\n//yes, this is just a flat array as that's what's convenient\nfunction userDefinedTypes(state = [], action) {\n  switch (action.type) {\n    case actions.DEFINE_TYPE:\n      debug(\"action: %O\", action);\n      return [...state, { id: action.node.id, sourceId: action.sourceId }];\n    default:\n      return state;\n  }\n}\n\n//just going to treat this like userDefinedTypes\nfunction taggedOutputs(state = [], action) {\n  switch (action.type) {\n    case actions.DEFINE_TAGGED_OUTPUT:\n      return [...state, { id: action.node.id, sourceId: action.sourceId }];\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_ALLOCATIONS = {\n  storage: {},\n  memory: {},\n  abi: {},\n  calldata: {},\n  returndata: {},\n  state: {}\n};\n\nfunction allocations(state = DEFAULT_ALLOCATIONS, action) {\n  if (action.type === actions.ALLOCATE) {\n    debug(\"action: %O\", action);\n    return {\n      storage: action.storage,\n      memory: action.memory,\n      abi: action.abi,\n      calldata: action.calldata,\n      returndata: action.returndata,\n      state: action.state\n    };\n  } else {\n    return state; //not to be confused with action.state!\n  }\n}\n\nconst info = combineReducers({\n  scopes,\n  userDefinedTypes,\n  taggedOutputs,\n  allocations\n});\n\nconst GLOBAL_ASSIGNMENTS = [\n  [{ builtin: \"msg\" }, { location: \"special\", special: \"msg\" }],\n  [{ builtin: \"tx\" }, { location: \"special\", special: \"tx\" }],\n  [{ builtin: \"block\" }, { location: \"special\", special: \"block\" }],\n  [{ builtin: \"this\" }, { location: \"special\", special: \"this\" }],\n  [{ builtin: \"now\" }, { location: \"special\", special: \"timestamp\" }] //we don't have an alias \"now\"\n].map(([idObj, ref]) => makeAssignment(idObj, ref));\n\nconst DEFAULT_ASSIGNMENTS = {\n  byId: Object.assign(\n    {}, //we start out with all globals assigned\n    ...GLOBAL_ASSIGNMENTS.map(assignment => ({ [assignment.id]: assignment }))\n  )\n};\n\nfunction assignments(state = DEFAULT_ASSIGNMENTS, action) {\n  switch (action.type) {\n    case actions.ASSIGN:\n    case actions.MAP_PATH_AND_ASSIGN:\n      debug(\"action.type %O\", action.type);\n      debug(\"action.assignments %O\", action.assignments);\n      return {\n        byId: {\n          ...state.byId,\n          ...action.assignments\n        }\n      };\n\n    case actions.RESET:\n      return DEFAULT_ASSIGNMENTS;\n\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_PATHS = {\n  byAddress: {}\n};\n\n//WARNING: do *not* rely on mappedPaths to keep track of paths that do not\n//involve mapping keys!  Yes, many will get mapped, but there is no guarantee.\n//Only when mapping keys are involved does it necessarily work reliably --\n//which is fine, as that's all we need it for.\nfunction mappedPaths(state = DEFAULT_PATHS, action) {\n  switch (action.type) {\n    case actions.MAP_PATH_AND_ASSIGN:\n      let { address, slot, typeIdentifier, parentType } = action;\n      //how this case works: first, we find the spot in our table (based on\n      //address, type identifier, and slot address) where the new entry should\n      //be added; if needed we set up all the objects needed along the way.  If\n      //there's already something there, we do nothing.  If there's nothing\n      //there, we record our given slot in that spot in that table -- however,\n      //we alter it in one key way.  Before entry, we check if the slot's\n      //*parent* has a spot in the table, based on address (same for both child\n      //and parent), parentType, and the parent's slot address (which can be\n      //found as the slotAddress of the slot's path object, if it exists -- if\n      //it doesn't then we conclude that no the parent does not have a spot in\n      //the table).  If the parent has a slot in the table already, then we\n      //alter the child slot by replacing its path with the parent slot.  This\n      //will keep the slotAddress the same, but since the versions kept in the\n      //table here are supposed to preserve path information, we'll be\n      //replacing a fairly bare-bones Slot object with one with a full path.\n\n      //we do NOT want to distinguish between types with and without \"_ptr\" on\n      //the end here! (or _slice)\n      debug(\"typeIdentifier %s\", typeIdentifier);\n      typeIdentifier = Codec.Ast.Utils.regularizeTypeIdentifier(typeIdentifier);\n      parentType = Codec.Ast.Utils.regularizeTypeIdentifier(parentType);\n\n      debug(\"slot %o\", slot);\n      let hexSlotAddress = Codec.Conversion.toHexString(\n        Codec.Storage.Utils.slotAddress(slot),\n        Codec.Evm.Utils.WORD_SIZE\n      );\n      let parentAddress = slot.path\n        ? Codec.Conversion.toHexString(\n            Codec.Storage.Utils.slotAddress(slot.path),\n            Codec.Evm.Utils.WORD_SIZE\n          )\n        : undefined;\n\n      //this is going to be messy and procedural, sorry.  but let's start with\n      //the easy stuff: create the new address if needed, clone if not\n      let newState = {\n        ...state,\n        byAddress: {\n          ...state.byAddress,\n          [address]: {\n            byType: {\n              ...(state.byAddress[address] || { byType: {} }).byType\n            }\n          }\n        }\n      };\n\n      //now, let's add in the new type, if needed\n      newState.byAddress[address].byType = {\n        ...newState.byAddress[address].byType,\n        [typeIdentifier]: {\n          bySlotAddress: {\n            ...(\n              newState.byAddress[address].byType[typeIdentifier] || {\n                bySlotAddress: {}\n              }\n            ).bySlotAddress\n          }\n        }\n      };\n\n      let oldSlot =\n        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[\n          hexSlotAddress\n        ];\n      //yes, this looks strange, but we haven't changed it yet except to\n      //clone or create empty (and we don't want undefined!)\n      //now: is there something already there or no?  if no, we must add\n      if (oldSlot === undefined) {\n        let newSlot;\n        debug(\"parentAddress %o\", parentAddress);\n        if (\n          parentAddress !== undefined &&\n          newState.byAddress[address].byType[parentType] &&\n          newState.byAddress[address].byType[parentType].bySlotAddress[\n            parentAddress\n          ]\n        ) {\n          //if the parent is already present, use that instead of the given\n          //parent!\n          newSlot = {\n            ...slot,\n            path:\n              newState.byAddress[address].byType[parentType].bySlotAddress[\n                parentAddress\n              ]\n          };\n        } else {\n          newSlot = slot;\n        }\n        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[\n          hexSlotAddress\n        ] = newSlot;\n      }\n      //if there's already something there, we don't need to do anything\n\n      return newState;\n\n    case actions.RESET:\n      return DEFAULT_PATHS;\n\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  assignments,\n  mappedPaths\n});\n\nconst reducer = combineReducers({\n  info,\n  proc\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\nimport * as Codec from \"@truffle/codec\";\n\nimport BN from \"bn.js\";\n\nconst DEFAULT_CONTEXTS = {\n  byContext: {}\n};\n\nfunction contexts(state = DEFAULT_CONTEXTS, action) {\n  switch (action.type) {\n    /*\n     * Adding a new context\n     */\n    case actions.ADD_CONTEXT:\n      const {\n        context,\n        contractName,\n        binary,\n        sourceMap,\n        primarySource,\n        immutableReferences,\n        compiler,\n        compilationId,\n        abi,\n        contractId,\n        contractKind,\n        isConstructor,\n        linearizedBaseContracts\n      } = action;\n      debug(\"action %O\", action);\n\n      return {\n        ...state,\n        byContext: {\n          ...state.byContext,\n          [context]: {\n            context,\n            contractName,\n            context,\n            binary,\n            sourceMap,\n            primarySource,\n            immutableReferences,\n            compiler,\n            compilationId,\n            abi,\n            contractId,\n            contractKind,\n            isConstructor,\n            linearizedBaseContracts,\n            payable: Codec.AbiData.Utils.abiHasPayableFallback(abi)\n          }\n        }\n      };\n\n    /*\n     * Default case\n     */\n    default:\n      return state;\n  }\n}\n\nconst info = combineReducers({\n  contexts\n});\n\nconst DEFAULT_TX = {\n  gasprice: new BN(0),\n  origin: Codec.Evm.Utils.ZERO_ADDRESS\n};\n\nfunction tx(state = DEFAULT_TX, action) {\n  switch (action.type) {\n    case actions.SAVE_GLOBALS:\n      let { gasprice, origin } = action;\n      return { gasprice, origin };\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_TX;\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_BLOCK = {\n  coinbase: Codec.Evm.Utils.ZERO_ADDRESS,\n  difficulty: new BN(0),\n  gaslimit: new BN(0),\n  number: new BN(0),\n  timestamp: new BN(0),\n  chainid: new BN(0),\n  basefee: new BN(0)\n};\n\nfunction block(state = DEFAULT_BLOCK, action) {\n  switch (action.type) {\n    case actions.SAVE_GLOBALS:\n      return action.block;\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_BLOCK;\n    default:\n      return state;\n  }\n}\n\nconst globals = combineReducers({\n  tx,\n  block\n});\n\nfunction status(state = null, action) {\n  switch (action.type) {\n    case actions.SAVE_STATUS:\n      return action.status;\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction initialCall(state = null, action) {\n  switch (action.type) {\n    case actions.CALL:\n    case actions.CREATE:\n      //we only want to save the initial call, so return\n      //the current state if it's not null\n      if (state !== null) {\n        return state;\n      } else {\n        //we'll just store the action itself in the state\n        return action;\n      }\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_AFFECTED_INSTANCES = { byAddress: {} };\n\nfunction affectedInstances(state = DEFAULT_AFFECTED_INSTANCES, action) {\n  switch (action.type) {\n    case actions.ADD_AFFECTED_INSTANCE:\n      const {\n        address,\n        binary,\n        context,\n        creationBinary,\n        creationContext\n      } = action;\n      return {\n        byAddress: {\n          ...state.byAddress,\n          [address]: {\n            address,\n            binary,\n            context,\n            creationBinary, //may be undefined\n            creationContext\n          }\n        }\n      };\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_AFFECTED_INSTANCES;\n    default:\n      return state;\n  }\n}\n\nconst transaction = combineReducers({\n  globals,\n  status,\n  initialCall,\n  affectedInstances\n});\n\nfunction callstack(state = [], action) {\n  switch (action.type) {\n    case actions.CALL: {\n      const { address, data, storageAddress, sender, value } = action;\n      return state.concat([{ address, data, storageAddress, sender, value }]);\n    }\n\n    case actions.CREATE: {\n      const { binary, storageAddress, sender, value } = action;\n      return state.concat(\n        [{ binary, data: \"0x\", storageAddress, sender, value }]\n        //the empty data field is to make msg.data and msg.sig come out right\n      );\n    }\n\n    case actions.RETURN_CALL:\n    case actions.RETURN_CREATE:\n    case actions.FAIL:\n      //pop the stack... unless (HACK) that would leave it empty (this will\n      //only happen at the end when we want to keep the last one around)\n      return state.length > 1 ? state.slice(0, -1) : state;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_CODEX = [\n  {\n    accounts: {}\n    //will be more here in the future!\n  }\n];\n\nfunction codex(state = DEFAULT_CODEX, action) {\n  let newState, topCodex;\n\n  const updateFrameStorage = (frame, address, slot, value) => ({\n    ...frame,\n    accounts: {\n      ...frame.accounts,\n      [address]: {\n        code: \"0x\", //this will get overridden if it already exists!\n        context: null, //similarly!\n        ...frame.accounts[address], //may be undefined\n        storage: {\n          ...(frame.accounts[address] || {}).storage, //may be undefined\n          [slot]: value\n        }\n      }\n    }\n  });\n  //(note that {...undefined} just expands to {} and is OK)\n\n  const updateFrameCode = (frame, address, code, context) => {\n    let existingPage = frame.accounts[address] || { storage: {} };\n    return {\n      ...frame,\n      accounts: {\n        ...frame.accounts,\n        [address]: {\n          ...existingPage,\n          code: code,\n          context: context\n        }\n      }\n    };\n  };\n\n  //later: will add \"force\" parameter\n  const safePop = array => (array.length > 2 ? array.slice(0, -1) : array);\n\n  //later: will add \"force\" parameter\n  const safeSave = array =>\n    array.length > 2\n      ? array.slice(0, -2).concat([array[array.length - 1]])\n      : array;\n\n  switch (action.type) {\n    case actions.CALL:\n      debug(\"call action\");\n      debug(\"codex: %O\", state);\n      //on a call, we can just make a new stackframe by cloning the top\n      //stackframe; there should already be an account for the address we're\n      //calling into, so we don't need to make one\n      return [...state, state[state.length - 1]];\n\n    case actions.CREATE:\n      debug(\"create action\");\n      //on a create, make a new stackframe, then add a new pages to the\n      //codex if necessary; don't add a zero page though (or pages that already\n      //exist)\n\n      //first, add a new stackframe by cloning the top one\n      newState = [...state, state[state.length - 1]];\n      topCodex = newState[newState.length - 1];\n      //now, do we need to add a new address to this stackframe?\n      if (\n        topCodex.accounts[action.storageAddress] !== undefined ||\n        action.storageAddress === Codec.Evm.Utils.ZERO_ADDRESS\n      ) {\n        //if we don't\n        return newState;\n      }\n      //if we do\n      newState[newState.length - 1] = {\n        ...topCodex,\n        accounts: {\n          ...topCodex.accounts,\n          [action.storageAddress]: {\n            storage: {},\n            code: \"0x\",\n            context: null\n            //there will be more here in the future!\n          }\n        }\n      };\n      return newState;\n\n    case actions.STORE: {\n      debug(\"store action\");\n      //on a store, the relevant page should already exist, so we can just\n      //add or update the needed slot\n      const { address, slot, value } = action;\n      if (address === Codec.Evm.Utils.ZERO_ADDRESS) {\n        //as always, we do not maintain a zero page\n        return state;\n      }\n      newState = state.slice(); //clone the state\n      topCodex = newState[newState.length - 1];\n      newState[newState.length - 1] = updateFrameStorage(\n        topCodex,\n        address,\n        slot,\n        value\n      );\n      return newState;\n    }\n\n    case actions.LOAD: {\n      debug(\"load action\");\n      //loads are a little more complicated -- usually we do nothing, but if\n      //it's an external load (there was nothing already there), then we want\n      //to update *every* stackframe\n      const { address, slot, value } = action;\n      if (address === Codec.Evm.Utils.ZERO_ADDRESS) {\n        //as always, we do not maintain a zero page\n        return state;\n      }\n      topCodex = state[state.length - 1];\n      if (topCodex.accounts[address].storage[slot] !== undefined) {\n        //if we already have a value in the *top* stackframe, update *no*\n        //stackframes; don't update the top (no need, it's just a load, not a\n        //store), don't update the rest (that would be wrong, you might be\n        //loading a value that will get reverted later)\n        return state;\n      } else {\n        //if we *don't* already have a value in the top stackframe, that means\n        //we're loading a value from a previous transaction!  That's not a\n        //value that will get reverted if this call fails, so update *every*\n        //stackframe\n        return state.map(frame =>\n          updateFrameStorage(frame, address, slot, value)\n        );\n      }\n    }\n\n    case actions.RETURN_CALL:\n      debug(\"return from call\");\n      //we want to pop the top while making the new top a copy of the old top;\n      //that is to say, we want to drop just the element *second* from the top\n      //NOTE: we don't ever go down to 1 element!\n      return safeSave(state);\n\n    case actions.RETURN_CREATE: {\n      debug(\"return from create\");\n      //we're going to do the same things in this case as in the usual return\n      //case, but first we need to record the code that was returned\n      const { address, code, context } = action;\n      newState = state.slice(); //clone the state\n      //NOTE: since this is only for RETURN_CREATE, and not FAIL, we shouldn't\n      //have to worry about accidentally getting a zero address here\n      newState[newState.length - 1] = updateFrameCode(\n        newState[newState.length - 1],\n        address,\n        code,\n        context\n      );\n      debug(\"newState: %O\", newState);\n      return safeSave(newState);\n    }\n\n    case actions.FAIL:\n      debug(\"fail action\");\n      //pop the stack\n      //NOTE: we don't ever go down to 1 element!\n      return safePop(state);\n\n    case actions.RESET:\n      debug(\"reset action\");\n      return [state[0]]; //leave the -1 frame on the stack\n\n    case actions.UNLOAD_TRANSACTION:\n      debug(\"unload action\");\n      return DEFAULT_CODEX;\n\n    case actions.ADD_INSTANCE: {\n      //add the instance to every frame\n      //(this is a little HACKy, but it *should* be fine)\n      debug(\"adding instance\");\n      const { address, binary, context } = action;\n      return state.map(frame =>\n        updateFrameCode(frame, address, binary, context)\n      );\n    }\n\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  callstack,\n  codex\n});\n\nconst reducer = combineReducers({\n  info,\n  transaction,\n  proc\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:solidity:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\nimport flatten from \"lodash.flatten\";\n\nconst DEFAULT_SOURCES = {\n  byCompilationId: {}, //user sources\n  byContext: {} //internal sources\n};\n\n//This piece of state is organized as follows:\n//1. byId: contains all the sources, by ID.  straightforward.\n//2. byCompilationId: contains the IDs of the user sources,\n//organized by compilation ID and then index (this last part\n//takes the form of an array).\n//3. byContext: contains the IDs of the internal sources,\n//organized by context hash and then index (again, this\n//last part takes the form of an array, although a sparse\n//array be aware).\nfunction sources(state = DEFAULT_SOURCES, action) {\n  switch (action.type) {\n    /*\n     * Adding new sources\n     */\n    case actions.ADD_SOURCES:\n      //NOTE: this code assumes that we are only ever adding compilations or contexts\n      //wholesale, and never adding to existing ones!\n      return {\n        byCompilationId: {\n          ...state.byCompilationId,\n          ...Object.assign(\n            {},\n            ...Object.entries(action.sources.user).map(([id, compilation]) => ({\n              [id]: {\n                byIndex: compilation.map(source => source.id)\n              }\n            }))\n          )\n        },\n        byContext: {\n          ...state.byContext,\n          ...Object.assign(\n            {},\n            ...Object.entries(action.sources.internal).map(\n              ([hash, context]) => ({\n                [hash]: {\n                  byIndex: context.map(source => source.id)\n                }\n              })\n            )\n          )\n        },\n        byId: {\n          ...state.byId,\n          ...Object.assign(\n            {},\n            ...flatten(\n              Object.values(action.sources.user).concat(\n                Object.values(action.sources.internal)\n              )\n            ).map(source => (source ? { [source.id]: source } : {}))\n          )\n        }\n      };\n    /*\n     * Default case\n     */\n    default:\n      return state;\n  }\n}\n\nconst info = combineReducers({\n  sources\n});\n\nfunction functionDepthStack(state = [], action) {\n  switch (action.type) {\n    case actions.JUMP:\n      let newState = state.slice(); //clone the state\n      const delta = spelunk(action.jumpDirection);\n      let top = newState[newState.length - 1];\n      let belowTop = newState.length > 1 ? newState[newState.length - 2] : -1;\n      newState[newState.length - 1] = Math.max(top + delta, belowTop + 1);\n      return newState;\n\n    case actions.RESET:\n      return [0];\n\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n\n    case actions.EXTERNAL_CALL:\n      if (state.length === 0) {\n        return [0];\n      }\n      return [...state, state[state.length - 1] + 1];\n\n    case actions.EXTERNAL_RETURN:\n      //just pop the stack! unless, HACK, that would leave it empty\n      return state.length > 1 ? state.slice(0, -1) : state;\n\n    default:\n      return state;\n  }\n}\n\nfunction nextFrameIsPhantom(state = null, action) {\n  switch (action.type) {\n    case actions.CLEAR_PHANTOM_GUARD:\n      return false;\n    case actions.EXTERNAL_RETURN:\n      return false;\n    case actions.EXTERNAL_CALL:\n      return action.guard;\n    case actions.RESET:\n      return action.guard;\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction spelunk(jump) {\n  if (jump === \"i\") {\n    return 1;\n  } else if (jump === \"o\") {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nconst proc = combineReducers({\n  functionDepthStack,\n  nextFrameIsPhantom\n});\n\nconst reducer = combineReducers({\n  info,\n  proc\n});\n\nexport default reducer;\n","module.exports = require(\"lodash.flatten\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:trace:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nfunction index(state = 0, action) {\n  switch (action.type) {\n    case actions.TOCK:\n      return state + 1;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return 0;\n\n    default:\n      return state;\n  }\n}\n\nfunction finished(state = false, action) {\n  switch (action.type) {\n    case actions.END_OF_TRACE:\n      return true;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return false;\n\n    default:\n      return state;\n  }\n}\n\nfunction steps(state = null, action) {\n  switch (action.type) {\n    case actions.SAVE_STEPS:\n      return action.steps;\n    case actions.UNLOAD_TRANSACTION:\n      debug(\"unloading\");\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction submoduleCount(state = 0, action) {\n  switch (action.type) {\n    case actions.SET_SUBMODULE_COUNT:\n      return action.count;\n    default:\n      return state;\n  }\n}\n\nconst transaction = combineReducers({\n  steps\n});\n\nconst proc = combineReducers({\n  index,\n  finished\n});\n\nconst application = combineReducers({\n  submoduleCount\n});\n\nconst reducer = combineReducers({\n  transaction,\n  proc,\n  application\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nfunction breakpoints(state = [], action) {\n  switch (action.type) {\n    case actions.ADD_BREAKPOINT:\n      //check for any existing identical breakpoints to avoid redundancy\n      if (\n        state.filter(\n          breakpoint =>\n            breakpoint.sourceId === action.breakpoint.sourceId &&\n            breakpoint.line === action.breakpoint.line &&\n            breakpoint.node === action.breakpoint.node //may be undefined\n        ).length > 0\n      ) {\n        //if it's already there, do nothing\n        return state;\n      } else {\n        //otherwise add it\n        return state.concat([action.breakpoint]);\n      }\n      break;\n\n    case actions.REMOVE_BREAKPOINT:\n      return state.filter(\n        breakpoint =>\n          breakpoint.sourceId !== action.breakpoint.sourceId ||\n          breakpoint.line !== action.breakpoint.line ||\n          breakpoint.node !== action.breakpoint.node //may be undefined\n      );\n      break;\n\n    case actions.REMOVE_ALL_BREAKPOINTS:\n      return [];\n\n    default:\n      return state;\n  }\n}\n\nfunction isStepping(state = false, action) {\n  switch (action.type) {\n    case actions.START_STEPPING:\n      debug(\"got step start action\");\n      return true;\n    case actions.DONE_STEPPING:\n      debug(\"got step stop action\");\n      return false;\n    default:\n      return state;\n  }\n}\n\nfunction stepIntoInternalSources(state = false, action) {\n  if (action.type === actions.SET_INTERNAL_STEPPING) {\n    return action.status;\n  } else {\n    return state;\n  }\n}\n\nconst reducer = combineReducers({\n  breakpoints,\n  stepIntoInternalSources,\n  isStepping\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:reducers\");\n\nimport { combineReducers } from \"redux\";\nimport { popNWhere } from \"lib/helpers\";\n\nimport * as actions from \"./actions\";\n\nfunction callstack(state = [], action) {\n  let newFrame;\n  switch (action.type) {\n    case actions.JUMP_IN:\n      let { location, functionNode, contractNode } = action;\n      newFrame = {\n        type: \"internal\",\n        calledFromLocation: location,\n        address: state[state.length - 1].address,\n        functionName:\n          functionNode &&\n          (functionNode.nodeType === \"FunctionDefinition\" ||\n            functionNode.nodeType === \"YulFunctionDefinition\")\n            ? functionNode.name\n            : undefined,\n        contractName:\n          contractNode && contractNode.nodeType === \"ContractDefinition\"\n            ? contractNode.name\n            : undefined\n        //note we don't currently account for getters because currently\n        //we can't; fallback, receive, constructors, & modifiers also remain\n        //unaccounted for at present\n        //(none of these things have associated jump-in markings!)\n      };\n      return [...state, newFrame];\n    case actions.JUMP_OUT:\n      let top = state[state.length - 1];\n      if (top && top.type === \"internal\") {\n        return state.slice(0, -1);\n      } else {\n        return state;\n      }\n    case actions.EXTERNAL_CALL:\n      newFrame = {\n        type: \"external\",\n        address: action.address,\n        calledFromLocation: action.location,\n        functionName: undefined,\n        contractName: action.context.contractName\n      };\n      return [...state, newFrame];\n    case actions.EXECUTE_RETURN:\n      return popNWhere(\n        state,\n        action.counter,\n        frame => frame.type === \"external\"\n      );\n    case actions.RESET:\n      return [state[0]];\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n    default:\n      //note that we don't do anything on EXTERNAL_RETURN!\n      //the callstack only changes on EXECUTE_RETURN!\n      return state;\n  }\n}\n\nfunction returnCounter(state = 0, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      return state + 1;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return 0;\n    default:\n      return state;\n  }\n}\n\nfunction lastPosition(state = null, action) {\n  switch (action.type) {\n    case actions.JUMP_IN:\n    case actions.JUMP_OUT:\n    case actions.ETERNAL_CALL:\n    case actions.EXTERNAL_RETURN:\n    case actions.UPDATE_POSITION:\n    case actions.EXECUTE_RETURN:\n      const { location } = action;\n      if (location.source.id === undefined || location.source.internal) {\n        //don't update for unmapped or internal!\n        return state;\n      }\n      return location;\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction innerReturnPosition(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      //we want the innermost return, so don't update\n      //this if it's not presently null\n      return state || action.from;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction innerReturnStatus(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      //we want the innermost return, so don't update\n      //this if it's not presently null\n      return state === null ? action.status : state;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction innerErrorIndex(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      //we use index null to mean don't update\n      return action.index !== null ? action.index : state;\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  callstack,\n  returnCounter,\n  lastPosition,\n  innerReturnPosition,\n  innerReturnStatus,\n  innerErrorIndex\n});\n\nconst reducer = combineReducers({\n  proc\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:txlog:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\n//NOTE: even though we refer to nodes by JSON pointer,\n//these pointers are \"fake\" in that we don't actually\n//use them *as* JSON pointers; it's just a convenient\n//method of IDing them that also has a nice intuitive\n//meaning (you'll notice we don't actually import\n//json-pointer here or anywhere else in this submodule)\nconst DEFAULT_TX_LOG = {\n  byPointer: {\n    \"\": {\n      // \"\" is the root node\n      type: \"transaction\",\n      actions: []\n    }\n  }\n};\n\nfunction transactionLog(state = DEFAULT_TX_LOG, action) {\n  const { pointer, newPointer } = action;\n  const node = state.byPointer[pointer];\n  switch (action.type) {\n    case actions.RECORD_ORIGIN:\n      if (node.type === \"transaction\") {\n        return {\n          byPointer: {\n            ...state.byPointer,\n            [pointer]: {\n              ...node,\n              origin: action.address\n            }\n          }\n        };\n      } else {\n        debug(\"attempt to set origin of bad node type!\");\n        return state;\n      }\n    case actions.INTERNAL_CALL:\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: {\n            ...node,\n            actions: [...node.actions, newPointer]\n          },\n          [newPointer]: {\n            type: \"callinternal\",\n            actions: [],\n            waitingForFunctionDefinition: true\n          }\n        }\n      };\n    case actions.ABSORBED_CALL:\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: {\n            ...node,\n            absorbNextInternalCall: false\n          }\n        }\n      };\n    case actions.INTERNAL_RETURN:\n      //pop the top call from the stack if it's internal (and set its return values)\n      //if the top call is instead external, just set its return values if appropriate.\n      //(this is how we handle internal/external return absorption)\n      const modifiedNode = { ...node };\n      if (modifiedNode.type === \"callinternal\") {\n        modifiedNode.returnKind = \"return\";\n        modifiedNode.returnValues = action.variables;\n        delete modifiedNode.waitingForFunctionDefinition;\n      } else if (modifiedNode.type === \"callexternal\") {\n        if (modifiedNode.kind === \"function\") {\n          //don't set return variables for non-function external calls\n          modifiedNode.returnValues = action.variables;\n        }\n      } else {\n        debug(\"returninternal once tx done!\");\n      }\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: modifiedNode\n        }\n      };\n    case actions.INSTANT_EXTERNAL_CALL:\n    case actions.EXTERNAL_CALL:\n    case actions.INSTANT_CREATE:\n    case actions.CREATE: {\n      const instant =\n        action.type === actions.INSTANT_EXTERNAL_CALL ||\n        action.type === actions.INSTANT_CREATE;\n      let modifiedNode = {\n        ...node,\n        actions: [...node.actions, newPointer]\n      };\n      if (\n        modifiedNode.type === \"callexternal\" &&\n        modifiedNode.kind === \"library\"\n      ) {\n        //didn't identify it as function, so set it to message\n        modifiedNode.kind = \"message\";\n      }\n      const {\n        address,\n        binary, //only for creates\n        context,\n        value,\n        salt, //only for creates\n        isDelegate,\n        decoding,\n        calldata,\n        status\n      } = action;\n      let kind;\n      if (\n        action.type === actions.CREATE ||\n        action.type === actions.INSTANT_CREATE\n      ) {\n        //these don't have kind in the action, so we instead determine\n        //it this way\n        kind = context ? \"constructor\" : \"unknowncreate\";\n      } else {\n        kind = action.kind;\n      }\n      const contractName = context ? context.contractName : undefined;\n      let functionName, variables;\n      if (decoding.kind === \"function\" || decoding.kind === \"constructor\") {\n        functionName = decoding.abi.name;\n        variables = decoding.arguments;\n      }\n      let call = {\n        type: \"callexternal\",\n        address,\n        contextHash: context.context || null,\n        value,\n        kind,\n        isDelegate,\n        functionName,\n        contractName,\n        arguments: variables,\n        actions: []\n      };\n      if (kind === \"message\" || kind === \"library\") {\n        call.data = calldata;\n      } else if (kind === \"unknowncreate\") {\n        call.binary = binary;\n      }\n      if (kind === \"constructor\" || kind === \"unknowncreate\") {\n        call.salt = salt;\n      }\n      if (instant) {\n        call.returnKind = status ? \"return\" : \"revert\";\n      } else {\n        //If kind === \"message\", set waiting to false.\n        //Why?  Well, because fallback functions and receive functions\n        //typically have their function definitions skipped over, so the next\n        //one we hit would instead be a function *called* from the fallback\n        //function, which is not what we want.\n        call.waitingForFunctionDefinition = kind !== \"message\";\n        //if kind is message or constructor, we don't want to absorb.\n        call.absorbNextInternalCall =\n          (kind === \"function\" || kind === \"library\") &&\n          action.absorbNextInternalCall;\n      }\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: modifiedNode,\n          [newPointer]: call\n        }\n      };\n    }\n    case actions.EXTERNAL_RETURN:\n    case actions.REVERT:\n    case actions.SELFDESTRUCT: {\n      //first: set the returnKind and other info\n      let modifiedNode = { ...node };\n      if (\n        modifiedNode.type === \"callexternal\" &&\n        modifiedNode.kind === \"library\"\n      ) {\n        //didn't identify it as function, so set it to message\n        modifiedNode.kind = \"message\";\n      }\n      switch (action.type) {\n        case actions.EXTERNAL_RETURN:\n          if (!modifiedNode.returnKind) {\n            modifiedNode.returnKind = \"return\";\n          }\n          break;\n        case actions.REVERT:\n          modifiedNode.returnKind = \"revert\";\n          modifiedNode.error = action.error;\n          break;\n        case actions.SELFDESTRUCT:\n          modifiedNode.returnKind = \"selfdestruct\";\n          modifiedNode.beneficiary = action.beneficiary;\n          break;\n      }\n      let newState = {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: modifiedNode\n        }\n      };\n      //now: pop all calls from stack until we pop an external call.\n      //we don't handle return values here since those are handled\n      //in returninternal (yay absorption)\n      let currentPointer;\n      for (\n        currentPointer = pointer;\n        currentPointer.replace(/\\/actions\\/\\d+$/, \"\") !== newPointer; //stop *before* the stop pointer\n        currentPointer = currentPointer.replace(/\\/actions\\/\\d+$/, \"\") //cut off end\n      ) {\n        debug(\"currentNode!\");\n        let currentNode = { ...newState.byPointer[currentPointer] }; //clone\n        if (!currentNode.returnKind) {\n          //set the return kind on any nodes popped along the way that don't have\n          //one already to note that they failed to return due to a call they made\n          //reverting\n          currentNode.returnKind = \"unwind\";\n        }\n        delete currentNode.waitingForFunctionDefinition;\n        debug(\"set currentNode!\");\n        newState.byPointer[currentPointer] = currentNode;\n      }\n      //now handle the external call.\n      //note that currentPointer now points to it.\n      debug(\"finalNode!\");\n      let finalNode = { ...newState.byPointer[currentPointer] }; //clone\n      //first let's set the returnKind if there isn't one already\n      //(in which case we can infer it was unwound).\n      if (!finalNode.returnKind) {\n        finalNode.returnKind = \"unwind\";\n      }\n      //now let's set its return variables if applicable.\n      if (\n        finalNode.kind === \"function\" &&\n        action.type === actions.EXTERNAL_RETURN &&\n        action.decodings\n      ) {\n        //functions get returnValues\n        const decoding = action.decodings.find(\n          decoding => decoding.kind === \"return\"\n        );\n        if (decoding) {\n          //we'll trust this method over the method resulting from an internal return,\n          //*if* it produces a valid return-value decoding.  if it doesn't, we ignore it.\n          finalNode.returnValues = decoding.arguments;\n        }\n      }\n      //and we'll set raw return data if applicable\n      //(we don't use codec here to increase robustness)\n      if (\n        finalNode.kind === \"message\" &&\n        action.type === actions.EXTERNAL_RETURN\n      ) {\n        finalNode.returnData = action.returnData;\n      }\n      //also, set immutables if applicable -- note that we do *not* attempt to set\n      //these the internal way, as we don't have a reliable way of doing that\n      if (\n        finalNode.kind === \"constructor\" &&\n        action.type === actions.EXTERNAL_RETURN &&\n        action.decodings\n      ) {\n        const decoding = action.decodings.find(\n          decoding => decoding.kind === \"bytecode\"\n        );\n        if (decoding && decoding.immutables) {\n          finalNode.returnImmutables = decoding.immutables;\n        }\n      }\n      //finally, delete internal info\n      delete finalNode.waitingForFunctionDefinition;\n      delete finalNode.absorbNextInternalCall;\n      debug(\"set finalNode!\");\n      newState.byPointer[currentPointer] = finalNode;\n      return newState;\n    }\n    case actions.IDENTIFY_FUNCTION_CALL: {\n      const { functionNode, contractNode, variables } = action;\n      const functionName = functionNode.name || undefined; //replace \"\" with undefined\n      const contractName =\n        contractNode && contractNode.nodeType === \"ContractDefinition\"\n          ? contractNode.name\n          : null;\n      let modifiedNode = {\n        ...node,\n        waitingForFunctionDefinition: false\n      };\n      //note: I don't handle the following in the object spread above\n      //because I don't want undefined or null counting against it\n      if (!modifiedNode.functionName) {\n        modifiedNode.functionName = functionName;\n      }\n      if (!modifiedNode.contractName) {\n        modifiedNode.contractName = contractName;\n      }\n      if (!modifiedNode.arguments) {\n        modifiedNode.arguments = variables;\n      }\n      if (\n        modifiedNode.type === \"callexternal\" &&\n        modifiedNode.kind === \"library\"\n      ) {\n        modifiedNode.kind = \"function\";\n        delete modifiedNode.data;\n      }\n      return {\n        byPointer: {\n          ...state.byPointer,\n          [pointer]: modifiedNode\n        }\n      };\n    }\n    case actions.RESET: //we'll reset everything and re-put initial action afterwards\n      //...well, almost everything.  we'll leave the origin in place.\n      return {\n        byPointer: {\n          \"\": {\n            type: \"transaction\",\n            origin: state.byPointer[\"\"].origin, //keep origin\n            actions: []\n          }\n        }\n      };\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_TX_LOG;\n    default:\n      return state;\n  }\n}\n\nfunction currentNodePointer(state = \"\", action) {\n  switch (action.type) {\n    case actions.INTERNAL_CALL:\n    case actions.EXTERNAL_CALL:\n    case actions.CREATE:\n    case actions.INTERNAL_RETURN:\n    case actions.EXTERNAL_RETURN:\n    case actions.REVERT:\n    case actions.SELFDESTRUCT:\n      //note that instant calls/creates are not included!\n      return action.newPointer;\n    case actions.RESET: //we'll reset everything and re-put initial action afterwards\n    case actions.UNLOAD_TRANSACTION:\n      return \"\";\n    default:\n      return state;\n  }\n}\n\n//this is a stack of the pointers to external calls.\n//note: not to the frames below them!\nfunction pointerStack(state = [], action) {\n  switch (action.type) {\n    case actions.EXTERNAL_CALL:\n    case actions.CREATE:\n      //note that instant calls & creates are not included!\n      return [...state, action.newPointer];\n    case actions.EXTERNAL_RETURN:\n    case actions.REVERT:\n    case actions.SELFDESTRUCT:\n      return state.slice(0, -1);\n    case actions.RESET: //we'll reset everything and re-put initial action afterwards\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n    default:\n      return state;\n  }\n}\n\nfunction initialCall(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_CALL:\n    case actions.CREATE:\n      //we only want to save the initial call, so return\n      //the current state if it's not null\n      //(we can skip instant case here, initial call is never instant)\n      if (state !== null) {\n        return state;\n      } else {\n        //we'll just store the action itself in the state\n        return action;\n      }\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  transactionLog,\n  currentNodePointer,\n  pointerStack\n});\n\nconst transaction = combineReducers({\n  initialCall\n});\n\nconst reducer = combineReducers({\n  proc,\n  transaction\n});\n\nexport default reducer;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Errors = exports.Sources = exports.Shims = void 0;\nexports.Shims = __importStar(require(\"./shims\"));\nexports.Sources = __importStar(require(\"./sources\"));\nexports.Errors = __importStar(require(\"./errors\"));\n__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NewToLegacy = exports.LegacyToNew = void 0;\nexports.LegacyToNew = __importStar(require(\"./LegacyToNew\"));\nexports.NewToLegacy = __importStar(require(\"./NewToLegacy\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forBytecode = exports.forContract = exports.forContracts = void 0;\nfunction forContracts(contracts) {\n    // convert to list\n    return Object.values(contracts).map(forContract);\n}\nexports.forContracts = forContracts;\nfunction forContract(contract) {\n    const { contractName, contract_name, sourcePath, source, sourceMap, deployedSourceMap, legacyAST, ast, abi, metadata, bytecode, deployedBytecode, compiler, devdoc, userdoc, immutableReferences, generatedSources, deployedGeneratedSources, db } = contract;\n    return {\n        contractName: contract_name || contractName,\n        sourcePath,\n        source,\n        sourceMap,\n        deployedSourceMap,\n        legacyAST,\n        ast,\n        abi,\n        metadata,\n        bytecode: forBytecode(bytecode),\n        deployedBytecode: forBytecode(deployedBytecode),\n        compiler,\n        devdoc,\n        userdoc,\n        immutableReferences,\n        generatedSources,\n        deployedGeneratedSources,\n        db\n    };\n}\nexports.forContract = forContract;\nfunction forBytecode(bytecode) {\n    if (!bytecode) {\n        return undefined;\n    }\n    if (typeof bytecode === \"object\") {\n        return bytecode;\n    }\n    const linkReferences = [];\n    const bytes = bytecode\n        .slice(2) // remove 0x prefix\n        .replace(/__[^_]+_*/g, (linkReference, characterOffset) => {\n        const [, name] = linkReference.match(/__([^_]+)_*/);\n        const characterLength = linkReference.length;\n        const offset = characterOffset / 2;\n        const length = characterLength / 2;\n        linkReferences.push({\n            offsets: [offset],\n            name,\n            length\n        });\n        return \"0\".repeat(characterLength);\n    });\n    return { bytes, linkReferences };\n}\nexports.forBytecode = forBytecode;\n//# sourceMappingURL=LegacyToNew.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forBytecode = exports.forContract = void 0;\nfunction forContract(contract) {\n    const { contractName, sourcePath, source, sourceMap, deployedSourceMap, legacyAST, ast, abi, metadata, bytecode, deployedBytecode, compiler, devdoc, userdoc, immutableReferences, generatedSources, deployedGeneratedSources, db } = contract;\n    return {\n        contract_name: contractName,\n        sourcePath,\n        source,\n        sourceMap,\n        deployedSourceMap,\n        legacyAST,\n        ast,\n        abi,\n        metadata,\n        bytecode: forBytecode(bytecode),\n        deployedBytecode: forBytecode(deployedBytecode),\n        unlinked_binary: forBytecode(bytecode),\n        compiler,\n        devdoc,\n        userdoc,\n        immutableReferences,\n        generatedSources,\n        deployedGeneratedSources,\n        db\n    };\n}\nexports.forContract = forContract;\nfunction forBytecode(bytecode) {\n    if (!bytecode) {\n        return bytecode;\n    }\n    if (typeof bytecode === \"string\") {\n        return bytecode;\n    }\n    let { bytes, linkReferences } = bytecode;\n    linkReferences = linkReferences || [];\n    // inline link references - start by flattening the offsets\n    const flattenedLinkReferences = linkReferences\n        // map each link ref to array of link refs with only one offset\n        .map(({ offsets, length, name }) => offsets.map(offset => ({ offset, length, name })))\n        // flatten\n        .reduce((a, b) => [...a, ...b], []);\n    // then overwite bytes with link reference\n    bytes = flattenedLinkReferences.reduce((bytes, { offset, name, length }) => {\n        // length is a byte offset\n        const characterLength = length * 2;\n        let linkId = `__${name.slice(0, characterLength - 2)}`;\n        while (linkId.length < characterLength) {\n            linkId += \"_\";\n        }\n        const start = offset * 2;\n        return `${bytes.substring(0, start)}${linkId}${bytes.substring(start + characterLength)}`;\n    }, bytes);\n    return `0x${bytes}`;\n}\nexports.forBytecode = forBytecode;\n//# sourceMappingURL=NewToLegacy.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectSources = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * Collects sources, targets into collections with OS-independent paths,\n * along with a reverse mapping to the original path (for post-processing)\n *\n * @param originalSources - { [originalSourcePath]: contents }\n * @param originalTargets - originalSourcePath[]\n * @param baseDirectory - a directory to remove as a prefix\n * @param replacement - what to replace it with\n * @return { sources, targets, originalSourcePaths }\n */\nfunction collectSources(originalSources, originalTargets = [], baseDirectory = \"\", replacement = \"/\") {\n    const mappedResults = Object.entries(originalSources)\n        .filter(([originalSourcePath, _]) => !path.isAbsolute(originalSourcePath) ||\n        originalSourcePath.startsWith(baseDirectory))\n        .map(([originalSourcePath, contents]) => ({\n        originalSourcePath,\n        contents,\n        sourcePath: getPortableSourcePath(replaceRootDirectory(originalSourcePath, baseDirectory, replacement))\n    }))\n        .map(({ originalSourcePath, sourcePath, contents }) => ({\n        sources: {\n            [sourcePath]: contents\n        },\n        // include transformed form as target if original is a target\n        targets: originalTargets.includes(originalSourcePath) ? [sourcePath] : [],\n        originalSourcePaths: {\n            [sourcePath]: originalSourcePath\n        }\n    }));\n    const defaultAccumulator = {\n        sources: {},\n        targets: [],\n        originalSourcePaths: {}\n    };\n    return mappedResults.reduce((accumulator, result) => ({\n        sources: Object.assign({}, accumulator.sources, result.sources),\n        targets: [...accumulator.targets, ...result.targets],\n        originalSourcePaths: Object.assign({}, accumulator.originalSourcePaths, result.originalSourcePaths)\n    }), defaultAccumulator);\n}\nexports.collectSources = collectSources;\n/**\n * @param sourcePath - string\n * @return string - operating system independent path\n * @private\n */\nfunction getPortableSourcePath(sourcePath) {\n    let replacement = sourcePath;\n    //on Windows, replace backslashes with forward slashes\n    if (path.sep === '\\\\') {\n        replacement = sourcePath.replace(/\\\\/g, \"/\");\n    }\n    // Turn G:/.../ into /G/.../ for Windows\n    if (replacement.length >= 2 && replacement[1] === \":\") {\n        replacement = \"/\" + replacement;\n        replacement = replacement.replace(\":\", \"\");\n    }\n    return replacement;\n}\nfunction replaceRootDirectory(sourcePath, rootDirectory, replacement) {\n    //make sure root directory ends in a separator\n    if (!rootDirectory.endsWith(path.sep)) {\n        rootDirectory = rootDirectory + path.sep;\n    }\n    return sourcePath.startsWith(rootDirectory)\n        ? replacement + sourcePath.slice(rootDirectory.length) //remove prefix\n        : sourcePath;\n}\n//# sourceMappingURL=sources.js.map","module.exports = require(\"path\");","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompileError = void 0;\nconst colors_1 = __importDefault(require(\"colors\"));\nconst error_1 = __importDefault(require(\"@truffle/error\"));\nclass CompileError extends error_1.default {\n    constructor(message) {\n        // Note we trim() because solc likes to add extra whitespace.\n        var fancy_message = message.trim() + \"\\n\\n\" + colors_1.default.red(\"Compilation failed. See above.\");\n        var normal_message = message.trim();\n        super(normal_message);\n        this.message = fancy_message; //?? I don't understand this, I just found it here\n    }\n}\nexports.CompileError = CompileError;\n//# sourceMappingURL=errors.js.map","var colors = require('./colors');\nmodule['exports'] = colors;\n\n// Remark: By default, colors will add style properties to String.prototype.\n//\n// If you don't wish to extend String.prototype, you can do this instead and\n// native String will not be touched:\n//\n//   var colors = require('colors/safe);\n//   colors.red(\"foo\")\n//\n//\nrequire('./extendStringPrototype')();\n","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar styles = {};\nmodule['exports'] = styles;\n\nvar codes = {\n  reset: [0, 0],\n\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  grey: [90, 39],\n\n  brightRed: [91, 39],\n  brightGreen: [92, 39],\n  brightYellow: [93, 39],\n  brightBlue: [94, 39],\n  brightMagenta: [95, 39],\n  brightCyan: [96, 39],\n  brightWhite: [97, 39],\n\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  bgGray: [100, 49],\n  bgGrey: [100, 49],\n\n  bgBrightRed: [101, 49],\n  bgBrightGreen: [102, 49],\n  bgBrightYellow: [103, 49],\n  bgBrightBlue: [104, 49],\n  bgBrightMagenta: [105, 49],\n  bgBrightCyan: [106, 49],\n  bgBrightWhite: [107, 49],\n\n  // legacy styles for colors pre v1.0.0\n  blackBG: [40, 49],\n  redBG: [41, 49],\n  greenBG: [42, 49],\n  yellowBG: [43, 49],\n  blueBG: [44, 49],\n  magentaBG: [45, 49],\n  cyanBG: [46, 49],\n  whiteBG: [47, 49],\n\n};\n\nObject.keys(codes).forEach(function(key) {\n  var val = codes[key];\n  var style = styles[key] = [];\n  style.open = '\\u001b[' + val[0] + 'm';\n  style.close = '\\u001b[' + val[1] + 'm';\n});\n","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n'use strict';\n\nvar os = require('os');\nvar hasFlag = require('./has-flag.js');\n\nvar env = process.env;\n\nvar forceColor = void 0;\nif (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {\n  forceColor = false;\n} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true')\n           || hasFlag('color=always')) {\n  forceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n  forceColor = env.FORCE_COLOR.length === 0\n    || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n  if (level === 0) {\n    return false;\n  }\n\n  return {\n    level: level,\n    hasBasic: true,\n    has256: level >= 2,\n    has16m: level >= 3,\n  };\n}\n\nfunction supportsColor(stream) {\n  if (forceColor === false) {\n    return 0;\n  }\n\n  if (hasFlag('color=16m') || hasFlag('color=full')\n      || hasFlag('color=truecolor')) {\n    return 3;\n  }\n\n  if (hasFlag('color=256')) {\n    return 2;\n  }\n\n  if (stream && !stream.isTTY && forceColor !== true) {\n    return 0;\n  }\n\n  var min = forceColor ? 1 : 0;\n\n  if (process.platform === 'win32') {\n    // Node.js 7.5.0 is the first version of Node.js to include a patch to\n    // libuv that enables 256 color output on Windows. Anything earlier and it\n    // won't work. However, here we target Node.js 8 at minimum as it is an LTS\n    // release, and Node.js 7 is not. Windows 10 build 10586 is the first\n    // Windows release that supports 256 colors. Windows 10 build 14931 is the\n    // first release that supports 16m/TrueColor.\n    var osRelease = os.release().split('.');\n    if (Number(process.versions.node.split('.')[0]) >= 8\n        && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n      return Number(osRelease[2]) >= 14931 ? 3 : 2;\n    }\n\n    return 1;\n  }\n\n  if ('CI' in env) {\n    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {\n      return sign in env;\n    }) || env.CI_NAME === 'codeship') {\n      return 1;\n    }\n\n    return min;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return (/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0\n    );\n  }\n\n  if ('TERM_PROGRAM' in env) {\n    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n    switch (env.TERM_PROGRAM) {\n      case 'iTerm.app':\n        return version >= 3 ? 3 : 2;\n      case 'Hyper':\n        return 3;\n      case 'Apple_Terminal':\n        return 2;\n      // No default\n    }\n  }\n\n  if (/-256(color)?$/i.test(env.TERM)) {\n    return 2;\n  }\n\n  if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n    return 1;\n  }\n\n  if ('COLORTERM' in env) {\n    return 1;\n  }\n\n  if (env.TERM === 'dumb') {\n    return min;\n  }\n\n  return min;\n}\n\nfunction getSupportLevel(stream) {\n  var level = supportsColor(stream);\n  return translateLevel(level);\n}\n\nmodule.exports = {\n  supportsColor: getSupportLevel,\n  stdout: getSupportLevel(process.stdout),\n  stderr: getSupportLevel(process.stderr),\n};\n","module.exports = require(\"os\");","/*\nMIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n'use strict';\n\nmodule.exports = function(flag, argv) {\n  argv = argv || process.argv;\n\n  var terminatorPos = argv.indexOf('--');\n  var prefix = /^-{1,2}/.test(flag) ? '' : '--';\n  var pos = argv.indexOf(prefix + flag);\n\n  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","module['exports'] = function runTheTrap(text, options) {\n  var result = '';\n  text = text || 'Run the trap, drop the bass';\n  text = text.split('');\n  var trap = {\n    a: ['\\u0040', '\\u0104', '\\u023a', '\\u0245', '\\u0394', '\\u039b', '\\u0414'],\n    b: ['\\u00df', '\\u0181', '\\u0243', '\\u026e', '\\u03b2', '\\u0e3f'],\n    c: ['\\u00a9', '\\u023b', '\\u03fe'],\n    d: ['\\u00d0', '\\u018a', '\\u0500', '\\u0501', '\\u0502', '\\u0503'],\n    e: ['\\u00cb', '\\u0115', '\\u018e', '\\u0258', '\\u03a3', '\\u03be', '\\u04bc',\n      '\\u0a6c'],\n    f: ['\\u04fa'],\n    g: ['\\u0262'],\n    h: ['\\u0126', '\\u0195', '\\u04a2', '\\u04ba', '\\u04c7', '\\u050a'],\n    i: ['\\u0f0f'],\n    j: ['\\u0134'],\n    k: ['\\u0138', '\\u04a0', '\\u04c3', '\\u051e'],\n    l: ['\\u0139'],\n    m: ['\\u028d', '\\u04cd', '\\u04ce', '\\u0520', '\\u0521', '\\u0d69'],\n    n: ['\\u00d1', '\\u014b', '\\u019d', '\\u0376', '\\u03a0', '\\u048a'],\n    o: ['\\u00d8', '\\u00f5', '\\u00f8', '\\u01fe', '\\u0298', '\\u047a', '\\u05dd',\n      '\\u06dd', '\\u0e4f'],\n    p: ['\\u01f7', '\\u048e'],\n    q: ['\\u09cd'],\n    r: ['\\u00ae', '\\u01a6', '\\u0210', '\\u024c', '\\u0280', '\\u042f'],\n    s: ['\\u00a7', '\\u03de', '\\u03df', '\\u03e8'],\n    t: ['\\u0141', '\\u0166', '\\u0373'],\n    u: ['\\u01b1', '\\u054d'],\n    v: ['\\u05d8'],\n    w: ['\\u0428', '\\u0460', '\\u047c', '\\u0d70'],\n    x: ['\\u04b2', '\\u04fe', '\\u04fc', '\\u04fd'],\n    y: ['\\u00a5', '\\u04b0', '\\u04cb'],\n    z: ['\\u01b5', '\\u0240'],\n  };\n  text.forEach(function(c) {\n    c = c.toLowerCase();\n    var chars = trap[c] || [' '];\n    var rand = Math.floor(Math.random() * chars.length);\n    if (typeof trap[c] !== 'undefined') {\n      result += trap[c][rand];\n    } else {\n      result += c;\n    }\n  });\n  return result;\n};\n","// please no\nmodule['exports'] = function zalgo(text, options) {\n  text = text || '   he is here   ';\n  var soul = {\n    'up': [\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '',\n    ],\n    'down': [\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n    ],\n    'mid': [\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '', '',\n      '', '', '',\n      '', '', '', '',\n      '', '', ' ',\n    ],\n  };\n  var all = [].concat(soul.up, soul.down, soul.mid);\n\n  function randomNumber(range) {\n    var r = Math.floor(Math.random() * range);\n    return r;\n  }\n\n  function isChar(character) {\n    var bool = false;\n    all.filter(function(i) {\n      bool = (i === character);\n    });\n    return bool;\n  }\n\n\n  function heComes(text, options) {\n    var result = '';\n    var counts;\n    var l;\n    options = options || {};\n    options['up'] =\n      typeof options['up'] !== 'undefined' ? options['up'] : true;\n    options['mid'] =\n      typeof options['mid'] !== 'undefined' ? options['mid'] : true;\n    options['down'] =\n      typeof options['down'] !== 'undefined' ? options['down'] : true;\n    options['size'] =\n      typeof options['size'] !== 'undefined' ? options['size'] : 'maxi';\n    text = text.split('');\n    for (l in text) {\n      if (isChar(l)) {\n        continue;\n      }\n      result = result + text[l];\n      counts = {'up': 0, 'down': 0, 'mid': 0};\n      switch (options.size) {\n        case 'mini':\n          counts.up = randomNumber(8);\n          counts.mid = randomNumber(2);\n          counts.down = randomNumber(8);\n          break;\n        case 'maxi':\n          counts.up = randomNumber(16) + 3;\n          counts.mid = randomNumber(4) + 1;\n          counts.down = randomNumber(64) + 3;\n          break;\n        default:\n          counts.up = randomNumber(8) + 1;\n          counts.mid = randomNumber(6) / 2;\n          counts.down = randomNumber(8) + 1;\n          break;\n      }\n\n      var arr = ['up', 'mid', 'down'];\n      for (var d in arr) {\n        var index = arr[d];\n        for (var i = 0; i <= counts[index]; i++) {\n          if (options[index]) {\n            result = result + soul[index][randomNumber(soul[index].length)];\n          }\n        }\n      }\n    }\n    return result;\n  }\n  // don't summon him\n  return heComes(text, options);\n};\n\n","module['exports'] = function(colors) {\n  return function(letter, i, exploded) {\n    if (letter === ' ') return letter;\n    switch (i%3) {\n      case 0: return colors.red(letter);\n      case 1: return colors.white(letter);\n      case 2: return colors.blue(letter);\n    }\n  };\n};\n","module['exports'] = function(colors) {\n  return function(letter, i, exploded) {\n    return i % 2 === 0 ? letter : colors.inverse(letter);\n  };\n};\n","module['exports'] = function(colors) {\n  // RoY G BiV\n  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];\n  return function(letter, i, exploded) {\n    if (letter === ' ') {\n      return letter;\n    } else {\n      return colors[rainbowColors[i++ % rainbowColors.length]](letter);\n    }\n  };\n};\n\n","module['exports'] = function(colors) {\n  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green',\n    'blue', 'white', 'cyan', 'magenta', 'brightYellow', 'brightRed',\n    'brightGreen', 'brightBlue', 'brightWhite', 'brightCyan', 'brightMagenta'];\n  return function(letter, i, exploded) {\n    return letter === ' ' ? letter :\n      colors[\n          available[Math.round(Math.random() * (available.length - 2))]\n      ](letter);\n  };\n};\n","var colors = require('./colors');\n\nmodule['exports'] = function() {\n  //\n  // Extends prototype of native string object to allow for \"foo\".red syntax\n  //\n  var addProperty = function(color, func) {\n    String.prototype.__defineGetter__(color, func);\n  };\n\n  addProperty('strip', function() {\n    return colors.strip(this);\n  });\n\n  addProperty('stripColors', function() {\n    return colors.strip(this);\n  });\n\n  addProperty('trap', function() {\n    return colors.trap(this);\n  });\n\n  addProperty('zalgo', function() {\n    return colors.zalgo(this);\n  });\n\n  addProperty('zebra', function() {\n    return colors.zebra(this);\n  });\n\n  addProperty('rainbow', function() {\n    return colors.rainbow(this);\n  });\n\n  addProperty('random', function() {\n    return colors.random(this);\n  });\n\n  addProperty('america', function() {\n    return colors.america(this);\n  });\n\n  //\n  // Iterate through all default styles and colors\n  //\n  var x = Object.keys(colors.styles);\n  x.forEach(function(style) {\n    addProperty(style, function() {\n      return colors.stylize(this, style);\n    });\n  });\n\n  function applyTheme(theme) {\n    //\n    // Remark: This is a list of methods that exist\n    // on String that you should not overwrite.\n    //\n    var stringPrototypeBlacklist = [\n      '__defineGetter__', '__defineSetter__', '__lookupGetter__',\n      '__lookupSetter__', 'charAt', 'constructor', 'hasOwnProperty',\n      'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString',\n      'valueOf', 'charCodeAt', 'indexOf', 'lastIndexOf', 'length',\n      'localeCompare', 'match', 'repeat', 'replace', 'search', 'slice',\n      'split', 'substring', 'toLocaleLowerCase', 'toLocaleUpperCase',\n      'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight',\n    ];\n\n    Object.keys(theme).forEach(function(prop) {\n      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {\n        console.log('warn: '.red + ('String.prototype' + prop).magenta +\n          ' is probably something you don\\'t want to override.  ' +\n          'Ignoring style name');\n      } else {\n        if (typeof(theme[prop]) === 'string') {\n          colors[prop] = colors[theme[prop]];\n          addProperty(prop, function() {\n            return colors[prop](this);\n          });\n        } else {\n          var themePropApplicator = function(str) {\n            var ret = str || this;\n            for (var t = 0; t < theme[prop].length; t++) {\n              ret = colors[theme[prop][t]](ret);\n            }\n            return ret;\n          };\n          addProperty(prop, themePropApplicator);\n          colors[prop] = function(str) {\n            return themePropApplicator(str);\n          };\n        }\n      }\n    });\n  }\n\n  colors.setTheme = function(theme) {\n    if (typeof theme === 'string') {\n      console.log('colors.setTheme now only accepts an object, not a string. ' +\n        'If you are trying to set a theme from a file, it is now your (the ' +\n        'caller\\'s) responsibility to require the file.  The old syntax ' +\n        'looked like colors.setTheme(__dirname + ' +\n        '\\'/../themes/generic-logging.js\\'); The new syntax looks like '+\n        'colors.setTheme(require(__dirname + ' +\n        '\\'/../themes/generic-logging.js\\'));');\n      return;\n    } else {\n      applyTheme(theme);\n    }\n  };\n};\n","\"use strict\";\n//Note: This class only exists for compatibility with some old Javascript\n//stuff that avoided using Error directly for whatever reason.  Eventually\n//it should be eliminated.\nclass ExtendableError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\nmodule.exports = ExtendableError;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map"],"sourceRoot":""}